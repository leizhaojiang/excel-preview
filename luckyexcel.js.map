{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/base64-js/index.js","node_modules/browser-resolve/empty.js","node_modules/buffer/index.js","node_modules/core-util-is/lib/util.js","node_modules/events/events.js","node_modules/ieee754/index.js","node_modules/immediate/lib/browser.js","node_modules/inherits/inherits_browser.js","node_modules/is-buffer/index.js","node_modules/isarray/index.js","node_modules/jszip/lib/base64.js","node_modules/jszip/lib/compressedObject.js","node_modules/jszip/lib/compressions.js","node_modules/jszip/lib/crc32.js","node_modules/jszip/lib/defaults.js","node_modules/jszip/lib/external.js","node_modules/jszip/lib/flate.js","node_modules/jszip/lib/generate/ZipFileWorker.js","node_modules/jszip/lib/generate/index.js","node_modules/jszip/lib/index.js","node_modules/jszip/lib/load.js","node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js","node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js","node_modules/jszip/lib/nodejsUtils.js","node_modules/jszip/lib/object.js","node_modules/jszip/lib/readable-stream-browser.js","node_modules/jszip/lib/reader/ArrayReader.js","node_modules/jszip/lib/reader/DataReader.js","node_modules/jszip/lib/reader/NodeBufferReader.js","node_modules/jszip/lib/reader/StringReader.js","node_modules/jszip/lib/reader/Uint8ArrayReader.js","node_modules/jszip/lib/reader/readerFor.js","node_modules/jszip/lib/signature.js","node_modules/jszip/lib/stream/ConvertWorker.js","node_modules/jszip/lib/stream/Crc32Probe.js","node_modules/jszip/lib/stream/DataLengthProbe.js","node_modules/jszip/lib/stream/DataWorker.js","node_modules/jszip/lib/stream/GenericWorker.js","node_modules/jszip/lib/stream/StreamHelper.js","node_modules/jszip/lib/support.js","node_modules/jszip/lib/utf8.js","node_modules/jszip/lib/utils.js","node_modules/jszip/lib/zipEntries.js","node_modules/jszip/lib/zipEntry.js","node_modules/jszip/lib/zipObject.js","node_modules/lie/lib/browser.js","node_modules/pako/index.js","node_modules/pako/lib/deflate.js","node_modules/pako/lib/inflate.js","node_modules/pako/lib/utils/common.js","node_modules/pako/lib/utils/strings.js","node_modules/pako/lib/zlib/adler32.js","node_modules/pako/lib/zlib/constants.js","node_modules/pako/lib/zlib/crc32.js","node_modules/pako/lib/zlib/deflate.js","node_modules/pako/lib/zlib/gzheader.js","node_modules/pako/lib/zlib/inffast.js","node_modules/pako/lib/zlib/inflate.js","node_modules/pako/lib/zlib/inftrees.js","node_modules/pako/lib/zlib/messages.js","node_modules/pako/lib/zlib/trees.js","node_modules/pako/lib/zlib/zstream.js","node_modules/process-nextick-args/index.js","node_modules/process/browser.js","node_modules/readable-stream/duplex-browser.js","node_modules/readable-stream/lib/_stream_duplex.js","node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/readable-stream/lib/_stream_readable.js","node_modules/readable-stream/lib/_stream_transform.js","node_modules/readable-stream/lib/_stream_writable.js","node_modules/readable-stream/lib/internal/streams/BufferList.js","node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/readable-stream/lib/internal/streams/stream-browser.js","node_modules/readable-stream/passthrough.js","node_modules/readable-stream/readable-browser.js","node_modules/readable-stream/transform.js","node_modules/readable-stream/writable-browser.js","node_modules/safe-buffer/index.js","node_modules/set-immediate-shim/index.js","node_modules/stream-browserify/index.js","node_modules/string_decoder/lib/string_decoder.js","node_modules/timers-browserify/main.js","node_modules/util-deprecate/browser.js","src/HandleZip.ts","src/ToLuckySheet/LuckyBase.ts","src/ToLuckySheet/LuckyCell.ts","src/ToLuckySheet/LuckyFile.ts","src/ToLuckySheet/LuckyImage.ts","src/ToLuckySheet/LuckySheet.ts","src/ToLuckySheet/ReadXml.ts","src/common/constant.ts","src/common/emf.ts","src/common/method.ts","src/main.ts"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACjvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACl1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACphDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnEA,IAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAGA,IAAA,SAAA;AAAA;AAAA,YAAA;AAII,WAAA,SAAA,CAAY,IAAZ,EAA4B;AACxB,QAAG,IAAI,YAAY,IAAnB,EAAwB;AACpB,WAAK,UAAL,GAAkB,IAAlB;AACH;AACJ;;AAED,EAAA,SAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,WAAV,EAAoD,SAApD,EAA+E;AAC3E;AACA,IAAA,OAAA,WAAA,CAAM,SAAN,CAAgB,KAAK,UAArB,EAAmE;AAAnE,KACC,IADD,CACM,UAAS,GAAT,EAAgB;AAClB,UAAI,QAAQ,GAAoC,EAAhD;AAAA,UAAoD,SAAS,GAAU,MAAM,CA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","file":"luckyexcel.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (!events)\n    return [];\n\n  var evlistener = events[type];\n  if (!evlistener)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","'use strict';\nvar utils = require('./utils');\nvar support = require('./support');\n// private property\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n\n// public method for encoding\nexports.encode = function(input) {\n    var output = [];\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0, len = input.length, remainingBytes = len;\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    while (i < input.length) {\n        remainingBytes = len - i;\n\n        if (!isArray) {\n            chr1 = input.charCodeAt(i++);\n            chr2 = i < len ? input.charCodeAt(i++) : 0;\n            chr3 = i < len ? input.charCodeAt(i++) : 0;\n        } else {\n            chr1 = input[i++];\n            chr2 = i < len ? input[i++] : 0;\n            chr3 = i < len ? input[i++] : 0;\n        }\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;\n        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;\n\n        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n\n    }\n\n    return output.join(\"\");\n};\n\n// public method for decoding\nexports.decode = function(input) {\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0, resultIndex = 0;\n\n    var dataUrlPrefix = \"data:\";\n\n    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n        // This is a common error: people give a data url\n        // (data:image/png;base64,iVBOR...) with a {base64: true} and\n        // wonders why things don't work.\n        // We can detect that the string input looks like a data url but we\n        // *can't* be sure it is one: removing everything up to the comma would\n        // be too dangerous.\n        throw new Error(\"Invalid base64 input, it looks like a data url.\");\n    }\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n    var totalLength = input.length * 3 / 4;\n    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (totalLength % 1 !== 0) {\n        // totalLength is not an integer, the length does not match a valid\n        // base64 content. That can happen if:\n        // - the input is not a base64 content\n        // - the input is *almost* a base64 content, with a extra chars at the\n        //   beginning or at the end\n        // - the input uses a base64 variant (base64url for example)\n        throw new Error(\"Invalid base64 input, bad content length.\");\n    }\n    var output;\n    if (support.uint8array) {\n        output = new Uint8Array(totalLength|0);\n    } else {\n        output = new Array(totalLength|0);\n    }\n\n    while (i < input.length) {\n\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        output[resultIndex++] = chr1;\n\n        if (enc3 !== 64) {\n            output[resultIndex++] = chr2;\n        }\n        if (enc4 !== 64) {\n            output[resultIndex++] = chr3;\n        }\n\n    }\n\n    return output;\n};\n","'use strict';\n\nvar external = require(\"./external\");\nvar DataWorker = require('./stream/DataWorker');\nvar DataLengthProbe = require('./stream/DataLengthProbe');\nvar Crc32Probe = require('./stream/Crc32Probe');\nvar DataLengthProbe = require('./stream/DataLengthProbe');\n\n/**\n * Represent a compressed object, with everything needed to decompress it.\n * @constructor\n * @param {number} compressedSize the size of the data compressed.\n * @param {number} uncompressedSize the size of the data after decompression.\n * @param {number} crc32 the crc32 of the decompressed file.\n * @param {object} compression the type of compression, see lib/compressions.js.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.\n */\nfunction CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n    this.compressedSize = compressedSize;\n    this.uncompressedSize = uncompressedSize;\n    this.crc32 = crc32;\n    this.compression = compression;\n    this.compressedContent = data;\n}\n\nCompressedObject.prototype = {\n    /**\n     * Create a worker to get the uncompressed content.\n     * @return {GenericWorker} the worker.\n     */\n    getContentWorker : function () {\n        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))\n        .pipe(this.compression.uncompressWorker())\n        .pipe(new DataLengthProbe(\"data_length\"));\n\n        var that = this;\n        worker.on(\"end\", function () {\n            if(this.streamInfo['data_length'] !== that.uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n        });\n        return worker;\n    },\n    /**\n     * Create a worker to get the compressed content.\n     * @return {GenericWorker} the worker.\n     */\n    getCompressedWorker : function () {\n        return new DataWorker(external.Promise.resolve(this.compressedContent))\n        .withStreamInfo(\"compressedSize\", this.compressedSize)\n        .withStreamInfo(\"uncompressedSize\", this.uncompressedSize)\n        .withStreamInfo(\"crc32\", this.crc32)\n        .withStreamInfo(\"compression\", this.compression)\n        ;\n    }\n};\n\n/**\n * Chain the given worker with other workers to compress the content with the\n * given compression.\n * @param {GenericWorker} uncompressedWorker the worker to pipe.\n * @param {Object} compression the compression object.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {GenericWorker} the new worker compressing the content.\n */\nCompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {\n    return uncompressedWorker\n    .pipe(new Crc32Probe())\n    .pipe(new DataLengthProbe(\"uncompressedSize\"))\n    .pipe(compression.compressWorker(compressionOptions))\n    .pipe(new DataLengthProbe(\"compressedSize\"))\n    .withStreamInfo(\"compression\", compression);\n};\n\nmodule.exports = CompressedObject;\n","'use strict';\n\nvar GenericWorker = require(\"./stream/GenericWorker\");\n\nexports.STORE = {\n    magic: \"\\x00\\x00\",\n    compressWorker : function (compressionOptions) {\n        return new GenericWorker(\"STORE compression\");\n    },\n    uncompressWorker : function () {\n        return new GenericWorker(\"STORE decompression\");\n    }\n};\nexports.DEFLATE = require('./flate');\n","'use strict';\n\nvar utils = require('./utils');\n\n/**\n * The following functions come from pako, from pako/lib/zlib/crc32.js\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n\n    for(var n =0; n < 256; n++){\n        c = n;\n        for(var k =0; k < 8; k++){\n            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n        }\n        table[n] = c;\n    }\n\n    return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n\n    crc = crc ^ (-1);\n\n    for (var i = pos; i < end; i++ ) {\n        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n}\n\n// That's all for the pako functions.\n\n/**\n * Compute the crc32 of a string.\n * This is almost the same as the function crc32, but for strings. Using the\n * same function for the two use cases leads to horrible performances.\n * @param {Number} crc the starting value of the crc.\n * @param {String} str the string to use.\n * @param {Number} len the length of the string.\n * @param {Number} pos the starting position for the crc32 computation.\n * @return {Number} the computed crc32.\n */\nfunction crc32str(crc, str, len, pos) {\n    var t = crcTable, end = pos + len;\n\n    crc = crc ^ (-1);\n\n    for (var i = pos; i < end; i++ ) {\n        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n}\n\nmodule.exports = function crc32wrapper(input, crc) {\n    if (typeof input === \"undefined\" || !input.length) {\n        return 0;\n    }\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n\n    if(isArray) {\n        return crc32(crc|0, input, input.length, 0);\n    } else {\n        return crc32str(crc|0, input, input.length, 0);\n    }\n};\n","'use strict';\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = true;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n","/* global Promise */\n'use strict';\n\n// load the global object first:\n// - it should be better integrated in the system (unhandledRejection in node)\n// - the environment may have a custom Promise implementation (see zone.js)\nvar ES6Promise = null;\nif (typeof Promise !== \"undefined\") {\n    ES6Promise = Promise;\n} else {\n    ES6Promise = require(\"lie\");\n}\n\n/**\n * Let the user use/change some implementations.\n */\nmodule.exports = {\n    Promise: ES6Promise\n};\n","'use strict';\nvar USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');\n\nvar pako = require(\"pako\");\nvar utils = require(\"./utils\");\nvar GenericWorker = require(\"./stream/GenericWorker\");\n\nvar ARRAY_TYPE = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\nexports.magic = \"\\x08\\x00\";\n\n/**\n * Create a worker that uses pako to inflate/deflate.\n * @constructor\n * @param {String} action the name of the pako function to call : either \"Deflate\" or \"Inflate\".\n * @param {Object} options the options to use when (de)compressing.\n */\nfunction FlateWorker(action, options) {\n    GenericWorker.call(this, \"FlateWorker/\" + action);\n\n    this._pako = null;\n    this._pakoAction = action;\n    this._pakoOptions = options;\n    // the `meta` object from the last chunk received\n    // this allow this worker to pass around metadata\n    this.meta = {};\n}\n\nutils.inherits(FlateWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nFlateWorker.prototype.processChunk = function (chunk) {\n    this.meta = chunk.meta;\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n};\n\n/**\n * @see GenericWorker.flush\n */\nFlateWorker.prototype.flush = function () {\n    GenericWorker.prototype.flush.call(this);\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push([], true);\n};\n/**\n * @see GenericWorker.cleanUp\n */\nFlateWorker.prototype.cleanUp = function () {\n    GenericWorker.prototype.cleanUp.call(this);\n    this._pako = null;\n};\n\n/**\n * Create the _pako object.\n * TODO: lazy-loading this object isn't the best solution but it's the\n * quickest. The best solution is to lazy-load the worker list. See also the\n * issue #446.\n */\nFlateWorker.prototype._createPako = function () {\n    this._pako = new pako[this._pakoAction]({\n        raw: true,\n        level: this._pakoOptions.level || -1 // default compression\n    });\n    var self = this;\n    this._pako.onData = function(data) {\n        self.push({\n            data : data,\n            meta : self.meta\n        });\n    };\n};\n\nexports.compressWorker = function (compressionOptions) {\n    return new FlateWorker(\"Deflate\", compressionOptions);\n};\nexports.uncompressWorker = function () {\n    return new FlateWorker(\"Inflate\", {});\n};\n","'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('../stream/GenericWorker');\nvar utf8 = require('../utf8');\nvar crc32 = require('../crc32');\nvar signature = require('../signature');\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\", i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with information about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */\nvar generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n    var file = streamInfo['file'],\n    compression = streamInfo['compression'],\n    useCustomEncoding = encodeFileName !== utf8.utf8encode,\n    encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n    utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n    comment = file.comment,\n    encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n    utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n    useUTF8ForComment = utfEncodedComment.length !== comment.length,\n    dosTime,\n    dosDate,\n    extraFields = \"\",\n    unicodePathExtraField = \"\",\n    unicodeCommentExtraField = \"\",\n    dir = file.dir,\n    date = file.date;\n\n\n    var dataInfo = {\n        crc32 : 0,\n        compressedSize : 0,\n        uncompressedSize : 0\n    };\n\n    // if the content is streamed, the sizes/crc32 are only available AFTER\n    // the end of the stream.\n    if (!streamedContent || streamingEnded) {\n        dataInfo.crc32 = streamInfo['crc32'];\n        dataInfo.compressedSize = streamInfo['compressedSize'];\n        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n    }\n\n    var bitflag = 0;\n    if (streamedContent) {\n        // Bit 3: the sizes/crc32 are set to zero in the local header.\n        // The correct values are put in the data descriptor immediately\n        // following the compressed data.\n        bitflag |= 0x0008;\n    }\n    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n        // Bit 11: Language encoding flag (EFS).\n        bitflag |= 0x0800;\n    }\n\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getUTCHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getUTCMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getUTCSeconds() / 2;\n\n    dosDate = date.getUTCFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getUTCMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getUTCDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(encodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(crc32(encodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    header += decToHex(bitflag, 2);\n    // compression method\n    header += compression.magic;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(dataInfo.crc32, 4);\n    // compressed size\n    header += decToHex(dataInfo.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(dataInfo.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n        // version made by (00: DOS)\n        decToHex(versionMadeBy, 2) +\n        // file header (common to file and central directory)\n        header +\n        // file comment length\n        decToHex(encodedComment.length, 2) +\n        // disk number start\n        \"\\x00\\x00\" +\n        // internal file attributes TODO\n        \"\\x00\\x00\" +\n        // external file attributes\n        decToHex(extFileAttr, 4) +\n        // relative offset of local header\n        decToHex(offset, 4) +\n        // file name\n        encodedFileName +\n        // extra field\n        extraFields +\n        // file comment\n        encodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord\n    };\n};\n\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */\nvar generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n    var dirEnd = \"\";\n    var encodedComment = utils.transformTo(\"string\", encodeFileName(comment));\n\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(entriesCount, 2) +\n        // total number of entries in the central directory\n        decToHex(entriesCount, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(encodedComment.length, 2) +\n        // .ZIP file comment\n        encodedComment;\n\n    return dirEnd;\n};\n\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing information\n * on the file entry.\n * @return {String} the data descriptors.\n */\nvar generateDataDescriptors = function (streamInfo) {\n    var descriptor = \"\";\n    descriptor = signature.DATA_DESCRIPTOR +\n        // crc-32                          4 bytes\n        decToHex(streamInfo['crc32'], 4) +\n        // compressed size                 4 bytes\n        decToHex(streamInfo['compressedSize'], 4) +\n        // uncompressed size               4 bytes\n        decToHex(streamInfo['uncompressedSize'], 4);\n\n    return descriptor;\n};\n\n\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */\nfunction ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n    GenericWorker.call(this, \"ZipFileWorker\");\n    // The number of bytes written so far. This doesn't count accumulated chunks.\n    this.bytesWritten = 0;\n    // The comment of the zip file\n    this.zipComment = comment;\n    // The platform \"generating\" the zip file.\n    this.zipPlatform = platform;\n    // the function to encode file names and comments.\n    this.encodeFileName = encodeFileName;\n    // Should we stream the content of the files ?\n    this.streamFiles = streamFiles;\n    // If `streamFiles` is false, we will need to accumulate the content of the\n    // files to calculate sizes / crc32 (and write them *before* the content).\n    // This boolean indicates if we are accumulating chunks (it will change a lot\n    // during the lifetime of this worker).\n    this.accumulate = false;\n    // The buffer receiving chunks when accumulating content.\n    this.contentBuffer = [];\n    // The list of generated directory records.\n    this.dirRecords = [];\n    // The offset (in bytes) from the beginning of the zip file for the current source.\n    this.currentSourceOffset = 0;\n    // The total number of entries in this zip file.\n    this.entriesCount = 0;\n    // the name of the file currently being added, null when handling the end of the zip file.\n    // Used for the emitted metadata.\n    this.currentFile = null;\n\n\n\n    this._sources = [];\n}\nutils.inherits(ZipFileWorker, GenericWorker);\n\n/**\n * @see GenericWorker.push\n */\nZipFileWorker.prototype.push = function (chunk) {\n\n    var currentFilePercent = chunk.meta.percent || 0;\n    var entriesCount = this.entriesCount;\n    var remainingFiles = this._sources.length;\n\n    if(this.accumulate) {\n        this.contentBuffer.push(chunk);\n    } else {\n        this.bytesWritten += chunk.data.length;\n\n        GenericWorker.prototype.push.call(this, {\n            data : chunk.data,\n            meta : {\n                currentFile : this.currentFile,\n                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n            }\n        });\n    }\n};\n\n/**\n * The worker started a new source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the new source.\n */\nZipFileWorker.prototype.openedSource = function (streamInfo) {\n    this.currentSourceOffset = this.bytesWritten;\n    this.currentFile = streamInfo['file'].name;\n\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n\n    // don't stream folders (because they don't have any content)\n    if(streamedContent) {\n        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n    } else {\n        // we need to wait for the whole file before pushing anything\n        this.accumulate = true;\n    }\n};\n\n/**\n * The worker finished a source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the finished source.\n */\nZipFileWorker.prototype.closedSource = function (streamInfo) {\n    this.accumulate = false;\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n\n    this.dirRecords.push(record.dirRecord);\n    if(streamedContent) {\n        // after the streamed file, we put data descriptors\n        this.push({\n            data : generateDataDescriptors(streamInfo),\n            meta : {percent:100}\n        });\n    } else {\n        // the content wasn't streamed, we need to push everything now\n        // first the file record, then the content\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n        while(this.contentBuffer.length) {\n            this.push(this.contentBuffer.shift());\n        }\n    }\n    this.currentFile = null;\n};\n\n/**\n * @see GenericWorker.flush\n */\nZipFileWorker.prototype.flush = function () {\n\n    var localDirLength = this.bytesWritten;\n    for(var i = 0; i < this.dirRecords.length; i++) {\n        this.push({\n            data : this.dirRecords[i],\n            meta : {percent:100}\n        });\n    }\n    var centralDirLength = this.bytesWritten - localDirLength;\n\n    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n\n    this.push({\n        data : dirEnd,\n        meta : {percent:100}\n    });\n};\n\n/**\n * Prepare the next source to be read.\n */\nZipFileWorker.prototype.prepareNextSource = function () {\n    this.previous = this._sources.shift();\n    this.openedSource(this.previous.streamInfo);\n    if (this.isPaused) {\n        this.previous.pause();\n    } else {\n        this.previous.resume();\n    }\n};\n\n/**\n * @see GenericWorker.registerPrevious\n */\nZipFileWorker.prototype.registerPrevious = function (previous) {\n    this._sources.push(previous);\n    var self = this;\n\n    previous.on('data', function (chunk) {\n        self.processChunk(chunk);\n    });\n    previous.on('end', function () {\n        self.closedSource(self.previous.streamInfo);\n        if(self._sources.length) {\n            self.prepareNextSource();\n        } else {\n            self.end();\n        }\n    });\n    previous.on('error', function (e) {\n        self.error(e);\n    });\n    return this;\n};\n\n/**\n * @see GenericWorker.resume\n */\nZipFileWorker.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if (!this.previous && this._sources.length) {\n        this.prepareNextSource();\n        return true;\n    }\n    if (!this.previous && !this._sources.length && !this.generatedError) {\n        this.end();\n        return true;\n    }\n};\n\n/**\n * @see GenericWorker.error\n */\nZipFileWorker.prototype.error = function (e) {\n    var sources = this._sources;\n    if(!GenericWorker.prototype.error.call(this, e)) {\n        return false;\n    }\n    for(var i = 0; i < sources.length; i++) {\n        try {\n            sources[i].error(e);\n        } catch(e) {\n            // the `error` exploded, nothing to do\n        }\n    }\n    return true;\n};\n\n/**\n * @see GenericWorker.lock\n */\nZipFileWorker.prototype.lock = function () {\n    GenericWorker.prototype.lock.call(this);\n    var sources = this._sources;\n    for(var i = 0; i < sources.length; i++) {\n        sources[i].lock();\n    }\n};\n\nmodule.exports = ZipFileWorker;\n","'use strict';\n\nvar compressions = require('../compressions');\nvar ZipFileWorker = require('./ZipFileWorker');\n\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */\nvar getCompression = function (fileCompression, zipCompression) {\n\n    var compressionName = fileCompression || zipCompression;\n    var compression = compressions[compressionName];\n    if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n    }\n    return compression;\n};\n\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */\nexports.generateWorker = function (zip, options, comment) {\n\n    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n    var entriesCount = 0;\n    try {\n\n        zip.forEach(function (relativePath, file) {\n            entriesCount++;\n            var compression = getCompression(file.options.compression, options.compression);\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n            var dir = file.dir, date = file.date;\n\n            file._compressWorker(compression, compressionOptions)\n            .withStreamInfo(\"file\", {\n                name : relativePath,\n                dir : dir,\n                date : date,\n                comment : file.comment || \"\",\n                unixPermissions : file.unixPermissions,\n                dosPermissions : file.dosPermissions\n            })\n            .pipe(zipFileWorker);\n        });\n        zipFileWorker.entriesCount = entriesCount;\n    } catch (e) {\n        zipFileWorker.error(e);\n    }\n\n    return zipFileWorker;\n};\n","'use strict';\n\n/**\n * Representation a of zip file in js\n * @constructor\n */\nfunction JSZip() {\n    // if this constructor is used without `new`, it adds `new` before itself:\n    if(!(this instanceof JSZip)) {\n        return new JSZip();\n    }\n\n    if(arguments.length) {\n        throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n    }\n\n    // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    this.files = {};\n\n    this.comment = null;\n\n    // Where we are in the hierarchy\n    this.root = \"\";\n    this.clone = function() {\n        var newObj = new JSZip();\n        for (var i in this) {\n            if (typeof this[i] !== \"function\") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = require('./object');\nJSZip.prototype.loadAsync = require('./load');\nJSZip.support = require('./support');\nJSZip.defaults = require('./defaults');\n\n// TODO find a better way to handle this version,\n// a require('package.json').version doesn't work with webpack, see #327\nJSZip.version = \"3.5.0\";\n\nJSZip.loadAsync = function (content, options) {\n    return new JSZip().loadAsync(content, options);\n};\n\nJSZip.external = require(\"./external\");\nmodule.exports = JSZip;\n","'use strict';\nvar utils = require('./utils');\nvar external = require(\"./external\");\nvar utf8 = require('./utf8');\nvar utils = require('./utils');\nvar ZipEntries = require('./zipEntries');\nvar Crc32Probe = require('./stream/Crc32Probe');\nvar nodejsUtils = require(\"./nodejsUtils\");\n\n/**\n * Check the CRC32 of an entry.\n * @param {ZipEntry} zipEntry the zip entry to check.\n * @return {Promise} the result.\n */\nfunction checkEntryCRC32(zipEntry) {\n    return new external.Promise(function (resolve, reject) {\n        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n        worker.on(\"error\", function (e) {\n            reject(e);\n        })\n        .on(\"end\", function () {\n            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                reject(new Error(\"Corrupted zip : CRC32 mismatch\"));\n            } else {\n                resolve();\n            }\n        })\n        .resume();\n    });\n}\n\nmodule.exports = function(data, options) {\n    var zip = this;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString: false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n\n    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n    }\n\n    return utils.prepareContent(\"the loaded zip file\", data, true, options.optimizedBinaryString, options.base64)\n    .then(function(data) {\n        var zipEntries = new ZipEntries(options);\n        zipEntries.load(data);\n        return zipEntries;\n    }).then(function checkCRC32(zipEntries) {\n        var promises = [external.Promise.resolve(zipEntries)];\n        var files = zipEntries.files;\n        if (options.checkCRC32) {\n            for (var i = 0; i < files.length; i++) {\n                promises.push(checkEntryCRC32(files[i]));\n            }\n        }\n        return external.Promise.all(promises);\n    }).then(function addFiles(results) {\n        var zipEntries = results.shift();\n        var files = zipEntries.files;\n        for (var i = 0; i < files.length; i++) {\n            var input = files[i];\n            zip.file(input.fileNameStr, input.decompressed, {\n                binary: true,\n                optimizedBinaryString: true,\n                date: input.date,\n                dir: input.dir,\n                comment : input.fileCommentStr.length ? input.fileCommentStr : null,\n                unixPermissions : input.unixPermissions,\n                dosPermissions : input.dosPermissions,\n                createFolders: options.createFolders\n            });\n        }\n        if (zipEntries.zipComment.length) {\n            zip.comment = zipEntries.zipComment;\n        }\n\n        return zip;\n    });\n};\n","\"use strict\";\n\nvar utils = require('../utils');\nvar GenericWorker = require('../stream/GenericWorker');\n\n/**\n * A worker that use a nodejs stream as source.\n * @constructor\n * @param {String} filename the name of the file entry for this stream.\n * @param {Readable} stream the nodejs stream.\n */\nfunction NodejsStreamInputAdapter(filename, stream) {\n    GenericWorker.call(this, \"Nodejs stream input adapter for \" + filename);\n    this._upstreamEnded = false;\n    this._bindStream(stream);\n}\n\nutils.inherits(NodejsStreamInputAdapter, GenericWorker);\n\n/**\n * Prepare the stream and bind the callbacks on it.\n * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.\n * @param {Stream} stream the nodejs stream to use.\n */\nNodejsStreamInputAdapter.prototype._bindStream = function (stream) {\n    var self = this;\n    this._stream = stream;\n    stream.pause();\n    stream\n    .on(\"data\", function (chunk) {\n        self.push({\n            data: chunk,\n            meta : {\n                percent : 0\n            }\n        });\n    })\n    .on(\"error\", function (e) {\n        if(self.isPaused) {\n            this.generatedError = e;\n        } else {\n            self.error(e);\n        }\n    })\n    .on(\"end\", function () {\n        if(self.isPaused) {\n            self._upstreamEnded = true;\n        } else {\n            self.end();\n        }\n    });\n};\nNodejsStreamInputAdapter.prototype.pause = function () {\n    if(!GenericWorker.prototype.pause.call(this)) {\n        return false;\n    }\n    this._stream.pause();\n    return true;\n};\nNodejsStreamInputAdapter.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if(this._upstreamEnded) {\n        this.end();\n    } else {\n        this._stream.resume();\n    }\n\n    return true;\n};\n\nmodule.exports = NodejsStreamInputAdapter;\n","'use strict';\n\nvar Readable = require('readable-stream').Readable;\n\nvar utils = require('../utils');\nutils.inherits(NodejsStreamOutputAdapter, Readable);\n\n/**\n* A nodejs stream using a worker as source.\n* @see the SourceWrapper in http://nodejs.org/api/stream.html\n* @constructor\n* @param {StreamHelper} helper the helper wrapping the worker\n* @param {Object} options the nodejs stream options\n* @param {Function} updateCb the update callback.\n*/\nfunction NodejsStreamOutputAdapter(helper, options, updateCb) {\n    Readable.call(this, options);\n    this._helper = helper;\n\n    var self = this;\n    helper.on(\"data\", function (data, meta) {\n        if (!self.push(data)) {\n            self._helper.pause();\n        }\n        if(updateCb) {\n            updateCb(meta);\n        }\n    })\n    .on(\"error\", function(e) {\n        self.emit('error', e);\n    })\n    .on(\"end\", function () {\n        self.push(null);\n    });\n}\n\n\nNodejsStreamOutputAdapter.prototype._read = function() {\n    this._helper.resume();\n};\n\nmodule.exports = NodejsStreamOutputAdapter;\n","'use strict';\n\nmodule.exports = {\n    /**\n     * True if this is running in Nodejs, will be undefined in a browser.\n     * In a browser, browserify won't include this file and the whole module\n     * will be resolved an empty object.\n     */\n    isNode : typeof Buffer !== \"undefined\",\n    /**\n     * Create a new nodejs Buffer from an existing content.\n     * @param {Object} data the data to pass to the constructor.\n     * @param {String} encoding the encoding to use.\n     * @return {Buffer} a new Buffer.\n     */\n    newBufferFrom: function(data, encoding) {\n        if (Buffer.from && Buffer.from !== Uint8Array.from) {\n            return Buffer.from(data, encoding);\n        } else {\n            if (typeof data === \"number\") {\n                // Safeguard for old Node.js versions. On newer versions,\n                // Buffer.from(number) / Buffer(number, encoding) already throw.\n                throw new Error(\"The \\\"data\\\" argument must not be a number\");\n            }\n            return new Buffer(data, encoding);\n        }\n    },\n    /**\n     * Create a new nodejs Buffer with the specified size.\n     * @param {Integer} size the size of the buffer.\n     * @return {Buffer} a new Buffer.\n     */\n    allocBuffer: function (size) {\n        if (Buffer.alloc) {\n            return Buffer.alloc(size);\n        } else {\n            var buf = new Buffer(size);\n            buf.fill(0);\n            return buf;\n        }\n    },\n    /**\n     * Find out if an object is a Buffer.\n     * @param {Object} b the object to test.\n     * @return {Boolean} true if the object is a Buffer, false otherwise.\n     */\n    isBuffer : function(b){\n        return Buffer.isBuffer(b);\n    },\n\n    isStream : function (obj) {\n        return obj &&\n            typeof obj.on === \"function\" &&\n            typeof obj.pause === \"function\" &&\n            typeof obj.resume === \"function\";\n    }\n};\n","'use strict';\nvar utf8 = require('./utf8');\nvar utils = require('./utils');\nvar GenericWorker = require('./stream/GenericWorker');\nvar StreamHelper = require('./stream/StreamHelper');\nvar defaults = require('./defaults');\nvar CompressedObject = require('./compressedObject');\nvar ZipObject = require('./zipObject');\nvar generate = require(\"./generate\");\nvar nodejsUtils = require(\"./nodejsUtils\");\nvar NodejsStreamInputAdapter = require(\"./nodejs/NodejsStreamInputAdapter\");\n\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} originalOptions the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, originalOptions) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n\n    /*\n     * Correct options.\n     */\n\n    var o = utils.extend(originalOptions || {}, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) {\n        o.compression = o.compression.toUpperCase();\n    }\n\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n        o.dir = true;\n    }\n\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    var isUnicodeString = dataType === \"string\" && o.binary === false && o.base64 === false;\n    if (!originalOptions || typeof originalOptions.binary === \"undefined\") {\n        o.binary = !isUnicodeString;\n    }\n\n\n    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;\n\n    if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n        o.base64 = false;\n        o.binary = true;\n        data = \"\";\n        o.compression = \"STORE\";\n        dataType = \"string\";\n    }\n\n    /*\n     * Convert content to fit.\n     */\n\n    var zipObjectContent = null;\n    if (data instanceof CompressedObject || data instanceof GenericWorker) {\n        zipObjectContent = data;\n    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        zipObjectContent = new NodejsStreamInputAdapter(name, data);\n    } else {\n        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n    }\n\n    var object = new ZipObject(name, zipObjectContent, o);\n    this.files[name] = object;\n    /*\n    TODO: we can't throw an exception because we have async promises\n    (we can have a promise of a Date() for example) but returning a\n    promise is useless because file(name, data) returns the JSZip\n    object for chaining. Should we break that to allow the user\n    to catch the error ?\n\n    return external.Promise.resolve(zipObjectContent)\n    .then(function () {\n        return object;\n    });\n    */\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) === '/') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf('/');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n};\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) !== \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;\n\n    name = forceTrailingSlash(name);\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nfunction isRegExp(object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n}\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * @see loadAsync\n     */\n    load: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n\n\n    /**\n     * Call a callback function for each entry at this folder level.\n     * @param {Function} cb the callback function:\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     */\n    forEach: function(cb) {\n        var filename, relativePath, file;\n        for (filename in this.files) {\n            if (!this.files.hasOwnProperty(filename)) {\n                continue;\n            }\n            file = this.files[filename];\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root\n                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...\n            }\n        }\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [];\n        this.forEach(function (relativePath, entry) {\n            if (search(relativePath, entry)) { // the file matches the function\n                result.push(entry);\n            }\n\n        });\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                var obj = this.files[this.root + name];\n                if (obj && !obj.dir) {\n                    return obj;\n                } else {\n                    return null;\n                }\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) !== \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n\n    /**\n     * Generate the complete zip file as an internal stream.\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {StreamHelper} the streamed zip file.\n     */\n    generateInternalStream: function(options) {\n      var worker, opts = {};\n      try {\n          opts = utils.extend(options || {}, {\n              streamFiles: false,\n              compression: \"STORE\",\n              compressionOptions : null,\n              type: \"\",\n              platform: \"DOS\",\n              comment: null,\n              mimeType: 'application/zip',\n              encodeFileName: utf8.utf8encode\n          });\n\n          opts.type = opts.type.toLowerCase();\n          opts.compression = opts.compression.toUpperCase();\n\n          // \"binarystring\" is preferred but the internals use \"string\".\n          if(opts.type === \"binarystring\") {\n            opts.type = \"string\";\n          }\n\n          if (!opts.type) {\n            throw new Error(\"No output type specified.\");\n          }\n\n          utils.checkSupport(opts.type);\n\n          // accept nodejs `process.platform`\n          if(\n              opts.platform === 'darwin' ||\n              opts.platform === 'freebsd' ||\n              opts.platform === 'linux' ||\n              opts.platform === 'sunos'\n          ) {\n              opts.platform = \"UNIX\";\n          }\n          if (opts.platform === 'win32') {\n              opts.platform = \"DOS\";\n          }\n\n          var comment = opts.comment || this.comment || \"\";\n          worker = generate.generateWorker(this, opts, comment);\n      } catch (e) {\n        worker = new GenericWorker(\"error\");\n        worker.error(e);\n      }\n      return new StreamHelper(worker, opts.type || \"string\", opts.mimeType);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */\n    generateAsync: function(options, onUpdate) {\n        return this.generateInternalStream(options).accumulate(onUpdate);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */\n    generateNodeStream: function(options, onUpdate) {\n        options = options || {};\n        if (!options.type) {\n            options.type = \"nodebuffer\";\n        }\n        return this.generateInternalStream(options).toNodejsStream(onUpdate);\n    }\n};\nmodule.exports = out;\n","/*\n * This file is used by module bundlers (browserify/webpack/etc) when\n * including a stream implementation. We use \"readable-stream\" to get a\n * consistent behavior between nodejs versions but bundlers often have a shim\n * for \"stream\". Using this shim greatly improve the compatibility and greatly\n * reduce the final size of the bundle (only one stream implementation, not\n * two).\n */\nmodule.exports = require(\"stream\");\n","'use strict';\nvar DataReader = require('./DataReader');\nvar utils = require('../utils');\n\nfunction ArrayReader(data) {\n    DataReader.call(this, data);\n\tfor(var i = 0; i < this.data.length; i++) {\n\t\tdata[i] = data[i] & 0xFF;\n\t}\n}\nutils.inherits(ArrayReader, DataReader);\n/**\n * @see DataReader.byteAt\n */\nArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3);\n    for (var i = this.length - 4; i >= 0; --i) {\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n\n    return -1;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */\nArrayReader.prototype.readAndCheckSignature = function (sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3),\n        data = this.readData(4);\n    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n};\n/**\n * @see DataReader.readData\n */\nArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n","'use strict';\nvar utils = require('../utils');\n\nfunction DataReader(data) {\n    this.data = data; // type : see implementation\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specified index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurrence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurrence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Read the signature (4 bytes) at the current position and compare it with sig.\n     * @param {string} sig the expected signature\n     * @return {boolean} true if the signature matches, false otherwise.\n     */\n    readAndCheckSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(Date.UTC(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1)); // second\n    }\n};\nmodule.exports = DataReader;\n","'use strict';\nvar Uint8ArrayReader = require('./Uint8ArrayReader');\nvar utils = require('../utils');\n\nfunction NodeBufferReader(data) {\n    Uint8ArrayReader.call(this, data);\n}\nutils.inherits(NodeBufferReader, Uint8ArrayReader);\n\n/**\n * @see DataReader.readData\n */\nNodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n","'use strict';\nvar DataReader = require('./DataReader');\nvar utils = require('../utils');\n\nfunction StringReader(data) {\n    DataReader.call(this, data);\n}\nutils.inherits(StringReader, DataReader);\n/**\n * @see DataReader.byteAt\n */\nStringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nStringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */\nStringReader.prototype.readAndCheckSignature = function (sig) {\n    var data = this.readData(4);\n    return sig === data;\n};\n/**\n * @see DataReader.readData\n */\nStringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the \"& 0xff\" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n","'use strict';\nvar ArrayReader = require('./ArrayReader');\nvar utils = require('../utils');\n\nfunction Uint8ArrayReader(data) {\n    ArrayReader.call(this, data);\n}\nutils.inherits(Uint8ArrayReader, ArrayReader);\n/**\n * @see DataReader.readData\n */\nUint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n","'use strict';\n\nvar utils = require('../utils');\nvar support = require('../support');\nvar ArrayReader = require('./ArrayReader');\nvar StringReader = require('./StringReader');\nvar NodeBufferReader = require('./NodeBufferReader');\nvar Uint8ArrayReader = require('./Uint8ArrayReader');\n\n/**\n * Create a reader adapted to the data.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.\n * @return {DataReader} the data reader.\n */\nmodule.exports = function (data) {\n    var type = utils.getTypeOf(data);\n    utils.checkSupport(type);\n    if (type === \"string\" && !support.uint8array) {\n        return new StringReader(data);\n    }\n    if (type === \"nodebuffer\") {\n        return new NodeBufferReader(data);\n    }\n    if (support.uint8array) {\n        return new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n    }\n    return new ArrayReader(utils.transformTo(\"array\", data));\n};\n","'use strict';\nexports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nexports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nexports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nexports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nexports.DATA_DESCRIPTOR = \"PK\\x07\\x08\";\n","'use strict';\n\nvar GenericWorker = require('./GenericWorker');\nvar utils = require('../utils');\n\n/**\n * A worker which convert chunks to a specified type.\n * @constructor\n * @param {String} destType the destination type.\n */\nfunction ConvertWorker(destType) {\n    GenericWorker.call(this, \"ConvertWorker to \" + destType);\n    this.destType = destType;\n}\nutils.inherits(ConvertWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nConvertWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : utils.transformTo(this.destType, chunk.data),\n        meta : chunk.meta\n    });\n};\nmodule.exports = ConvertWorker;\n","'use strict';\n\nvar GenericWorker = require('./GenericWorker');\nvar crc32 = require('../crc32');\nvar utils = require('../utils');\n\n/**\n * A worker which calculate the crc32 of the data flowing through.\n * @constructor\n */\nfunction Crc32Probe() {\n    GenericWorker.call(this, \"Crc32Probe\");\n    this.withStreamInfo(\"crc32\", 0);\n}\nutils.inherits(Crc32Probe, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nCrc32Probe.prototype.processChunk = function (chunk) {\n    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n    this.push(chunk);\n};\nmodule.exports = Crc32Probe;\n","'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('./GenericWorker');\n\n/**\n * A worker which calculate the total length of the data flowing through.\n * @constructor\n * @param {String} propName the name used to expose the length\n */\nfunction DataLengthProbe(propName) {\n    GenericWorker.call(this, \"DataLengthProbe for \" + propName);\n    this.propName = propName;\n    this.withStreamInfo(propName, 0);\n}\nutils.inherits(DataLengthProbe, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nDataLengthProbe.prototype.processChunk = function (chunk) {\n    if(chunk) {\n        var length = this.streamInfo[this.propName] || 0;\n        this.streamInfo[this.propName] = length + chunk.data.length;\n    }\n    GenericWorker.prototype.processChunk.call(this, chunk);\n};\nmodule.exports = DataLengthProbe;\n\n","'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('./GenericWorker');\n\n// the size of the generated chunks\n// TODO expose this as a public variable\nvar DEFAULT_BLOCK_SIZE = 16 * 1024;\n\n/**\n * A worker that reads a content and emits chunks.\n * @constructor\n * @param {Promise} dataP the promise of the data to split\n */\nfunction DataWorker(dataP) {\n    GenericWorker.call(this, \"DataWorker\");\n    var self = this;\n    this.dataIsReady = false;\n    this.index = 0;\n    this.max = 0;\n    this.data = null;\n    this.type = \"\";\n\n    this._tickScheduled = false;\n\n    dataP.then(function (data) {\n        self.dataIsReady = true;\n        self.data = data;\n        self.max = data && data.length || 0;\n        self.type = utils.getTypeOf(data);\n        if(!self.isPaused) {\n            self._tickAndRepeat();\n        }\n    }, function (e) {\n        self.error(e);\n    });\n}\n\nutils.inherits(DataWorker, GenericWorker);\n\n/**\n * @see GenericWorker.cleanUp\n */\nDataWorker.prototype.cleanUp = function () {\n    GenericWorker.prototype.cleanUp.call(this);\n    this.data = null;\n};\n\n/**\n * @see GenericWorker.resume\n */\nDataWorker.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if (!this._tickScheduled && this.dataIsReady) {\n        this._tickScheduled = true;\n        utils.delay(this._tickAndRepeat, [], this);\n    }\n    return true;\n};\n\n/**\n * Trigger a tick a schedule an other call to this function.\n */\nDataWorker.prototype._tickAndRepeat = function() {\n    this._tickScheduled = false;\n    if(this.isPaused || this.isFinished) {\n        return;\n    }\n    this._tick();\n    if(!this.isFinished) {\n        utils.delay(this._tickAndRepeat, [], this);\n        this._tickScheduled = true;\n    }\n};\n\n/**\n * Read and push a chunk.\n */\nDataWorker.prototype._tick = function() {\n\n    if(this.isPaused || this.isFinished) {\n        return false;\n    }\n\n    var size = DEFAULT_BLOCK_SIZE;\n    var data = null, nextIndex = Math.min(this.max, this.index + size);\n    if (this.index >= this.max) {\n        // EOF\n        return this.end();\n    } else {\n        switch(this.type) {\n            case \"string\":\n                data = this.data.substring(this.index, nextIndex);\n            break;\n            case \"uint8array\":\n                data = this.data.subarray(this.index, nextIndex);\n            break;\n            case \"array\":\n            case \"nodebuffer\":\n                data = this.data.slice(this.index, nextIndex);\n            break;\n        }\n        this.index = nextIndex;\n        return this.push({\n            data : data,\n            meta : {\n                percent : this.max ? this.index / this.max * 100 : 0\n            }\n        });\n    }\n};\n\nmodule.exports = DataWorker;\n","'use strict';\n\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */\nfunction GenericWorker(name) {\n    // the name of the worker\n    this.name = name || \"default\";\n    // an object containing metadata about the workers chain\n    this.streamInfo = {};\n    // an error which happened when the worker was paused\n    this.generatedError = null;\n    // an object containing metadata to be merged by this worker into the general metadata\n    this.extraStreamInfo = {};\n    // true if the stream is paused (and should not do anything), false otherwise\n    this.isPaused = true;\n    // true if the stream is finished (and should not do anything), false otherwise\n    this.isFinished = false;\n    // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n    this.isLocked = false;\n    // the event listeners\n    this._listeners = {\n        'data':[],\n        'end':[],\n        'error':[]\n    };\n    // the previous worker, if any\n    this.previous = null;\n}\n\nGenericWorker.prototype = {\n    /**\n     * Push a chunk to the next workers.\n     * @param {Object} chunk the chunk to push\n     */\n    push : function (chunk) {\n        this.emit(\"data\", chunk);\n    },\n    /**\n     * End the stream.\n     * @return {Boolean} true if this call ended the worker, false otherwise.\n     */\n    end : function () {\n        if (this.isFinished) {\n            return false;\n        }\n\n        this.flush();\n        try {\n            this.emit(\"end\");\n            this.cleanUp();\n            this.isFinished = true;\n        } catch (e) {\n            this.emit(\"error\", e);\n        }\n        return true;\n    },\n    /**\n     * End the stream with an error.\n     * @param {Error} e the error which caused the premature end.\n     * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n     */\n    error : function (e) {\n        if (this.isFinished) {\n            return false;\n        }\n\n        if(this.isPaused) {\n            this.generatedError = e;\n        } else {\n            this.isFinished = true;\n\n            this.emit(\"error\", e);\n\n            // in the workers chain exploded in the middle of the chain,\n            // the error event will go downward but we also need to notify\n            // workers upward that there has been an error.\n            if(this.previous) {\n                this.previous.error(e);\n            }\n\n            this.cleanUp();\n        }\n        return true;\n    },\n    /**\n     * Add a callback on an event.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Function} listener the function to call when the event is triggered\n     * @return {GenericWorker} the current object for chainability\n     */\n    on : function (name, listener) {\n        this._listeners[name].push(listener);\n        return this;\n    },\n    /**\n     * Clean any references when a worker is ending.\n     */\n    cleanUp : function () {\n        this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n        this._listeners = [];\n    },\n    /**\n     * Trigger an event. This will call registered callback with the provided arg.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Object} arg the argument to call the callback with.\n     */\n    emit : function (name, arg) {\n        if (this._listeners[name]) {\n            for(var i = 0; i < this._listeners[name].length; i++) {\n                this._listeners[name][i].call(this, arg);\n            }\n        }\n    },\n    /**\n     * Chain a worker with an other.\n     * @param {Worker} next the worker receiving events from the current one.\n     * @return {worker} the next worker for chainability\n     */\n    pipe : function (next) {\n        return next.registerPrevious(this);\n    },\n    /**\n     * Same as `pipe` in the other direction.\n     * Using an API with `pipe(next)` is very easy.\n     * Implementing the API with the point of view of the next one registering\n     * a source is easier, see the ZipFileWorker.\n     * @param {Worker} previous the previous worker, sending events to this one\n     * @return {Worker} the current worker for chainability\n     */\n    registerPrevious : function (previous) {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n\n        // sharing the streamInfo...\n        this.streamInfo = previous.streamInfo;\n        // ... and adding our own bits\n        this.mergeStreamInfo();\n        this.previous =  previous;\n        var self = this;\n        previous.on('data', function (chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on('end', function () {\n            self.end();\n        });\n        previous.on('error', function (e) {\n            self.error(e);\n        });\n        return this;\n    },\n    /**\n     * Pause the stream so it doesn't send events anymore.\n     * @return {Boolean} true if this call paused the worker, false otherwise.\n     */\n    pause : function () {\n        if(this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = true;\n\n        if(this.previous) {\n            this.previous.pause();\n        }\n        return true;\n    },\n    /**\n     * Resume a paused stream.\n     * @return {Boolean} true if this call resumed the worker, false otherwise.\n     */\n    resume : function () {\n        if(!this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = false;\n\n        // if true, the worker tried to resume but failed\n        var withError = false;\n        if(this.generatedError) {\n            this.error(this.generatedError);\n            withError = true;\n        }\n        if(this.previous) {\n            this.previous.resume();\n        }\n\n        return !withError;\n    },\n    /**\n     * Flush any remaining bytes as the stream is ending.\n     */\n    flush : function () {},\n    /**\n     * Process a chunk. This is usually the method overridden.\n     * @param {Object} chunk the chunk to process.\n     */\n    processChunk : function(chunk) {\n        this.push(chunk);\n    },\n    /**\n     * Add a key/value to be added in the workers chain streamInfo once activated.\n     * @param {String} key the key to use\n     * @param {Object} value the associated value\n     * @return {Worker} the current worker for chainability\n     */\n    withStreamInfo : function (key, value) {\n        this.extraStreamInfo[key] = value;\n        this.mergeStreamInfo();\n        return this;\n    },\n    /**\n     * Merge this worker's streamInfo into the chain's streamInfo.\n     */\n    mergeStreamInfo : function () {\n        for(var key in this.extraStreamInfo) {\n            if (!this.extraStreamInfo.hasOwnProperty(key)) {\n                continue;\n            }\n            this.streamInfo[key] = this.extraStreamInfo[key];\n        }\n    },\n\n    /**\n     * Lock the stream to prevent further updates on the workers chain.\n     * After calling this method, all calls to pipe will fail.\n     */\n    lock: function () {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        this.isLocked = true;\n        if (this.previous) {\n            this.previous.lock();\n        }\n    },\n\n    /**\n     *\n     * Pretty print the workers chain.\n     */\n    toString : function () {\n        var me = \"Worker \" + this.name;\n        if (this.previous) {\n            return this.previous + \" -> \" + me;\n        } else {\n            return me;\n        }\n    }\n};\n\nmodule.exports = GenericWorker;\n","'use strict';\n\nvar utils = require('../utils');\nvar ConvertWorker = require('./ConvertWorker');\nvar GenericWorker = require('./GenericWorker');\nvar base64 = require('../base64');\nvar support = require(\"../support\");\nvar external = require(\"../external\");\n\nvar NodejsStreamOutputAdapter = null;\nif (support.nodestream) {\n    try {\n        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');\n    } catch(e) {}\n}\n\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */\nfunction transformZipOutput(type, content, mimeType) {\n    switch(type) {\n        case \"blob\" :\n            return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n        case \"base64\" :\n            return base64.encode(content);\n        default :\n            return utils.transformTo(type, content);\n    }\n}\n\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */\nfunction concat (type, dataArray) {\n    var i, index = 0, res = null, totalLength = 0;\n    for(i = 0; i < dataArray.length; i++) {\n        totalLength += dataArray[i].length;\n    }\n    switch(type) {\n        case \"string\":\n            return dataArray.join(\"\");\n          case \"array\":\n            return Array.prototype.concat.apply([], dataArray);\n        case \"uint8array\":\n            res = new Uint8Array(totalLength);\n            for(i = 0; i < dataArray.length; i++) {\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case \"nodebuffer\":\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\"  + type + \"'\");\n    }\n}\n\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */\nfunction accumulate(helper, updateCallback) {\n    return new external.Promise(function (resolve, reject){\n        var dataArray = [];\n        var chunkType = helper._internalType,\n            resultType = helper._outputType,\n            mimeType = helper._mimeType;\n        helper\n        .on('data', function (data, meta) {\n            dataArray.push(data);\n            if(updateCallback) {\n                updateCallback(meta);\n            }\n        })\n        .on('error', function(err) {\n            dataArray = [];\n            reject(err);\n        })\n        .on('end', function (){\n            try {\n                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n            dataArray = [];\n        })\n        .resume();\n    });\n}\n\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */\nfunction StreamHelper(worker, outputType, mimeType) {\n    var internalType = outputType;\n    switch(outputType) {\n        case \"blob\":\n        case \"arraybuffer\":\n            internalType = \"uint8array\";\n        break;\n        case \"base64\":\n            internalType = \"string\";\n        break;\n    }\n\n    try {\n        // the type used internally\n        this._internalType = internalType;\n        // the type used to output results\n        this._outputType = outputType;\n        // the mime type\n        this._mimeType = mimeType;\n        utils.checkSupport(internalType);\n        this._worker = worker.pipe(new ConvertWorker(internalType));\n        // the last workers can be rewired without issues but we need to\n        // prevent any updates on previous workers.\n        worker.lock();\n    } catch(e) {\n        this._worker = new GenericWorker(\"error\");\n        this._worker.error(e);\n    }\n}\n\nStreamHelper.prototype = {\n    /**\n     * Listen a StreamHelper, accumulate its content and concatenate it into a\n     * complete block.\n     * @param {Function} updateCb the update callback.\n     * @return Promise the promise for the accumulation.\n     */\n    accumulate : function (updateCb) {\n        return accumulate(this, updateCb);\n    },\n    /**\n     * Add a listener on an event triggered on a stream.\n     * @param {String} evt the name of the event\n     * @param {Function} fn the listener\n     * @return {StreamHelper} the current helper.\n     */\n    on : function (evt, fn) {\n        var self = this;\n\n        if(evt === \"data\") {\n            this._worker.on(evt, function (chunk) {\n                fn.call(self, chunk.data, chunk.meta);\n            });\n        } else {\n            this._worker.on(evt, function () {\n                utils.delay(fn, arguments, self);\n            });\n        }\n        return this;\n    },\n    /**\n     * Resume the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    resume : function () {\n        utils.delay(this._worker.resume, [], this._worker);\n        return this;\n    },\n    /**\n     * Pause the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    pause : function () {\n        this._worker.pause();\n        return this;\n    },\n    /**\n     * Return a nodejs stream for this helper.\n     * @param {Function} updateCb the update callback.\n     * @return {NodejsStreamOutputAdapter} the nodejs stream.\n     */\n    toNodejsStream : function (updateCb) {\n        utils.checkSupport(\"nodestream\");\n        if (this._outputType !== \"nodebuffer\") {\n            // an object stream containing blob/arraybuffer/uint8array/string\n            // is strange and I don't know if it would be useful.\n            // I you find this comment and have a good usecase, please open a\n            // bug report !\n            throw new Error(this._outputType + \" is not supported by this method\");\n        }\n\n        return new NodejsStreamOutputAdapter(this, {\n            objectMode : this._outputType !== \"nodebuffer\"\n        }, updateCb);\n    }\n};\n\n\nmodule.exports = StreamHelper;\n","'use strict';\n\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\nexports.nodebuffer = typeof Buffer !== \"undefined\";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== \"undefined\";\n\nif (typeof ArrayBuffer === \"undefined\") {\n    exports.blob = false;\n}\nelse {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([buffer], {\n            type: \"application/zip\"\n        }).size === 0;\n    }\n    catch (e) {\n        try {\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob('application/zip').size === 0;\n        }\n        catch (e) {\n            exports.blob = false;\n        }\n    }\n}\n\ntry {\n    exports.nodestream = !!require('readable-stream').Readable;\n} catch(e) {\n    exports.nodestream = false;\n}\n","'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodejsUtils = require('./nodejsUtils');\nvar GenericWorker = require('./stream/GenericWorker');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    return buf2string(buf);\n};\n\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */\nfunction Utf8DecodeWorker() {\n    GenericWorker.call(this, \"utf-8 decode\");\n    // the last bytes if a chunk didn't end with a complete codepoint.\n    this.leftOver = null;\n}\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8DecodeWorker.prototype.processChunk = function (chunk) {\n\n    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n\n    // 1st step, re-use what's left of the previous chunk\n    if (this.leftOver && this.leftOver.length) {\n        if(support.uint8array) {\n            var previousData = data;\n            data = new Uint8Array(previousData.length + this.leftOver.length);\n            data.set(this.leftOver, 0);\n            data.set(previousData, this.leftOver.length);\n        } else {\n            data = this.leftOver.concat(data);\n        }\n        this.leftOver = null;\n    }\n\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n    if (nextBoundary !== data.length) {\n        if (support.uint8array) {\n            usableData = data.subarray(0, nextBoundary);\n            this.leftOver = data.subarray(nextBoundary, data.length);\n        } else {\n            usableData = data.slice(0, nextBoundary);\n            this.leftOver = data.slice(nextBoundary, data.length);\n        }\n    }\n\n    this.push({\n        data : exports.utf8decode(usableData),\n        meta : chunk.meta\n    });\n};\n\n/**\n * @see GenericWorker.flush\n */\nUtf8DecodeWorker.prototype.flush = function () {\n    if(this.leftOver && this.leftOver.length) {\n        this.push({\n            data : exports.utf8decode(this.leftOver),\n            meta : {}\n        });\n        this.leftOver = null;\n    }\n};\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */\nfunction Utf8EncodeWorker() {\n    GenericWorker.call(this, \"utf-8 encode\");\n}\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8EncodeWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : exports.utf8encode(chunk.data),\n        meta : chunk.meta\n    });\n};\nexports.Utf8EncodeWorker = Utf8EncodeWorker;\n","'use strict';\n\nvar support = require('./support');\nvar base64 = require('./base64');\nvar nodejsUtils = require('./nodejsUtils');\nvar setImmediate = require('set-immediate-shim');\nvar external = require(\"./external\");\n\n\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */\nfunction string2binary(str) {\n    var result = null;\n    if (support.uint8array) {\n      result = new Uint8Array(str.length);\n    } else {\n      result = new Array(str.length);\n    }\n    return stringToArrayLike(str, result);\n}\n\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */\nexports.newBlob = function(part, type) {\n    exports.checkSupport(\"blob\");\n\n    try {\n        // Blob constructor\n        return new Blob([part], {\n            type: type\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(part);\n            return builder.getBlob(type);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * An helper for the function arrayLikeToString.\n * This contains static information and functions that\n * can be optimized by the browser JIT compiler.\n */\nvar arrayToStringHelper = {\n    /**\n     * Transform an array of int into a string, chunk by chunk.\n     * See the performances notes on arrayLikeToString.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @param {String} type the type of the array.\n     * @param {Integer} chunk the chunk size.\n     * @return {String} the resulting string.\n     * @throws Error if the chunk is too big for the stack.\n     */\n    stringifyByChunk: function(array, type, chunk) {\n        var result = [], k = 0, len = array.length;\n        // shortcut\n        if (len <= chunk) {\n            return String.fromCharCode.apply(null, array);\n        }\n        while (k < len) {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        return result.join(\"\");\n    },\n    /**\n     * Call String.fromCharCode on every item in the array.\n     * This is the naive implementation, which generate A LOT of intermediate string.\n     * This should be used when everything else fail.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @return {String} the result.\n     */\n    stringifyByChar: function(array){\n        var resultStr = \"\";\n        for(var i = 0; i < array.length; i++) {\n            resultStr += String.fromCharCode(array[i]);\n        }\n        return resultStr;\n    },\n    applyCanBeUsed : {\n        /**\n         * true if the browser accepts to use String.fromCharCode on Uint8Array\n         */\n        uint8array : (function () {\n            try {\n                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })(),\n        /**\n         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n         */\n        nodebuffer : (function () {\n            try {\n                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })()\n    }\n};\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    // TODO : we now have workers that split the work. Do we still need that ?\n    var chunk = 65536,\n        type = exports.getTypeOf(array),\n        canUseApply = true;\n    if (type === \"uint8array\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n    } else if (type === \"nodebuffer\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n    }\n\n    if (canUseApply) {\n        while (chunk > 1) {\n            try {\n                return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n            } catch (e) {\n                chunk = Math.floor(chunk / 2);\n            }\n        }\n    }\n\n    // no apply or chunk error : slow and painful algorithm\n    // default browser on android 4.*\n    return arrayToStringHelper.stringifyByChar(array);\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this platform\");\n    }\n};\n\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */\nexports.delay = function(callback, args, self) {\n    setImmediate(function () {\n        callback.apply(self || null, args || []);\n    });\n};\n\n/**\n * Extends a prototype with an other, without calling a constructor with\n * side effects. Inspired by nodejs' `utils.inherits`\n * @param {Function} ctor the constructor to augment\n * @param {Function} superCtor the parent constructor to use\n */\nexports.inherits = function (ctor, superCtor) {\n    var Obj = function() {};\n    Obj.prototype = superCtor.prototype;\n    ctor.prototype = new Obj();\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */\nexports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n\n    // if inputData is already a promise, this flatten it.\n    var promise = external.Promise.resolve(inputData).then(function(data) {\n        \n        \n        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);\n\n        if (isBlob && typeof FileReader !== \"undefined\") {\n            return new external.Promise(function (resolve, reject) {\n                var reader = new FileReader();\n\n                reader.onload = function(e) {\n                    resolve(e.target.result);\n                };\n                reader.onerror = function(e) {\n                    reject(e.target.error);\n                };\n                reader.readAsArrayBuffer(data);\n            });\n        } else {\n            return data;\n        }\n    });\n\n    return promise.then(function(data) {\n        var dataType = exports.getTypeOf(data);\n\n        if (!dataType) {\n            return external.Promise.reject(\n                new Error(\"Can't read the data of '\" + name + \"'. Is it \" +\n                          \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\")\n            );\n        }\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = exports.transformTo(\"uint8array\", data);\n        } else if (dataType === \"string\") {\n            if (isBase64) {\n                data = base64.decode(data);\n            }\n            else if (isBinary) {\n                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n                if (isOptimizedBinaryString !== true) {\n                    // this is a string, not in a base64 format.\n                    // Be sure that this is a correct \"binary string\"\n                    data = string2binary(data);\n                }\n            }\n        }\n        return data;\n    });\n};\n","'use strict';\nvar readerFor = require('./reader/readerFor');\nvar utils = require('./utils');\nvar sig = require('./signature');\nvar ZipEntry = require('./zipEntry');\nvar utf8 = require('./utf8');\nvar support = require('./support');\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntries(loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the specified signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */\n    checkSignature: function(expectedSignature) {\n        if (!this.reader.readAndCheckSignature(expectedSignature)) {\n            this.reader.index -= 4;\n            var signature = this.reader.readString(4);\n            throw new Error(\"Corrupted zip or bug: unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */\n    isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */\n    readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don't want to read the wrong number of bytes !\n     */\n    readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.reader.skip(4);\n        // this.versionMadeBy = this.reader.readString(2);\n        // this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44,\n            index = 0,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n        while (index < extraDataSize) {\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readData(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */\n    readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error(\"Multi-volumes zip are not supported\");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */\n    readLocalFiles: function() {\n        var i, file;\n        for (i = 0; i < this.files.length; i++) {\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */\n    readCentralDir: function() {\n        var file;\n\n        this.reader.setIndex(this.centralDirOffset);\n        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn't find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n            } else {\n                // We found some records but not all.\n                // Something is wrong but we got something for the user: no error here.\n                // console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */\n    readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n\n            if (isGarbage) {\n                throw new Error(\"Can't find end of central directory : is this a zip file ? \" +\n                                \"If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n            } else {\n                throw new Error(\"Corrupted zip: can't find end of central directory\");\n            }\n\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n\n\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */\n        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */\n\n            // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn(\"ZIP64 end of central directory not where expected.\");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;\n        }\n\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n                // The offsets seem wrong, but we have something at the specified offset.\n                // So… we keep it.\n            } else {\n                // the offset is wrong, update the \"zero\" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n        }\n    },\n    prepareReader: function(data) {\n        this.reader = readerFor(data);\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */\n    load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n","'use strict';\nvar readerFor = require('./reader/readerFor');\nvar utils = require('./utils');\nvar CompressedObject = require('./compressedObject');\nvar crc32fn = require('./crc32');\nvar utf8 = require('./utf8');\nvar compressions = require('./compressions');\nvar support = require('./support');\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nvar findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */\n    isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */\n    useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n\n        if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n        }\n\n        compression = findCompression(this.compressionMethod);\n        if (compression === null) { // no compression found\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n    },\n\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        reader.skip(2);\n        // this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        var fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n\n        // will be read in the local part, see the comments there\n        reader.skip(fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */\n    processAttributes: function () {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n        if(madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n\n        if(madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;\n            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n            this.dir = true;\n        }\n    },\n\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */\n    parseZIP64ExtraField: function(reader) {\n\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n\n        // should be something, preparing the extra reader\n        var extraReader = readerFor(this.extraFields[0x0001].value);\n\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readExtraFields: function(reader) {\n        var end = reader.index + this.extraFieldsLength,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n\n        if (!this.extraFields) {\n            this.extraFields = {};\n        }\n\n        while (reader.index + 4 < end) {\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readData(extraFieldLength);\n\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n\n        reader.setIndex(end);\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */\n    handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = utf8.utf8decode(this.fileName);\n            this.fileCommentStr = utf8.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                // ASCII text or unsupported code page\n                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                // ASCII text or unsupported code page\n                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */\n    findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = readerFor(upathField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the filename changed, this field is out of date.\n            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n        }\n        return null;\n    },\n\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */\n    findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = readerFor(ucommentField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the comment changed, this field is out of date.\n            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n","'use strict';\n\nvar StreamHelper = require('./stream/StreamHelper');\nvar DataWorker = require('./stream/DataWorker');\nvar utf8 = require('./utf8');\nvar CompressedObject = require('./compressedObject');\nvar GenericWorker = require('./stream/GenericWorker');\n\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this._dataBinary = options.binary;\n    // keep only the compression\n    this.options = {\n        compression : options.compression,\n        compressionOptions : options.compressionOptions\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Create an internal stream for the content of this object.\n     * @param {String} type the type of each chunk.\n     * @return StreamHelper the stream.\n     */\n    internalStream: function (type) {\n        var result = null, outputType = \"string\";\n        try {\n            if (!type) {\n                throw new Error(\"No output type specified.\");\n            }\n            outputType = type.toLowerCase();\n            var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n            if (outputType === \"binarystring\" || outputType === \"text\") {\n                outputType = \"string\";\n            }\n            result = this._decompressWorker();\n\n            var isUnicodeString = !this._dataBinary;\n\n            if (isUnicodeString && !askUnicodeString) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            if (!isUnicodeString && askUnicodeString) {\n                result = result.pipe(new utf8.Utf8DecodeWorker());\n            }\n        } catch (e) {\n            result = new GenericWorker(\"error\");\n            result.error(e);\n        }\n\n        return new StreamHelper(result, outputType, \"\");\n    },\n\n    /**\n     * Prepare the content in the asked type.\n     * @param {String} type the type of the result.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Promise the promise of the result.\n     */\n    async: function (type, onUpdate) {\n        return this.internalStream(type).accumulate(onUpdate);\n    },\n\n    /**\n     * Prepare the content as a nodejs stream.\n     * @param {String} type the type of each chunk.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Stream the stream.\n     */\n    nodeStream: function (type, onUpdate) {\n        return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n    },\n\n    /**\n     * Return a worker for the compressed content.\n     * @private\n     * @param {Object} compression the compression object to use.\n     * @param {Object} compressionOptions the options to use when compressing.\n     * @return Worker the worker.\n     */\n    _compressWorker: function (compression, compressionOptions) {\n        if (\n            this._data instanceof CompressedObject &&\n            this._data.compression.magic === compression.magic\n        ) {\n            return this._data.getCompressedWorker();\n        } else {\n            var result = this._decompressWorker();\n            if(!this._dataBinary) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n        }\n    },\n    /**\n     * Return a worker for the decompressed content.\n     * @private\n     * @return Worker the worker.\n     */\n    _decompressWorker : function () {\n        if (this._data instanceof CompressedObject) {\n            return this._data.getContentWorker();\n        } else if (this._data instanceof GenericWorker) {\n            return this._data;\n        } else {\n            return new DataWorker(this._data);\n        }\n    }\n};\n\nvar removedMethods = [\"asText\", \"asBinary\", \"asNodeBuffer\", \"asUint8Array\", \"asArrayBuffer\"];\nvar removedFn = function () {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n};\n\nfor(var i = 0; i < removedMethods.length; i++) {\n    ZipObject.prototype[removedMethods[i]] = removedFn;\n}\nmodule.exports = ZipObject;\n","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"finally\"] = function (callback) {\n  if (typeof callback !== 'function') {\n    return this;\n  }\n  var p = this.constructor;\n  return this.then(resolve, reject);\n\n  function resolve(value) {\n    function yes () {\n      return value;\n    }\n    return p.resolve(callback()).then(yes);\n  }\n  function reject(reason) {\n    function no () {\n      throw reason;\n    }\n    return p.resolve(callback()).then(no);\n  }\n};\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n","// Top level file is just a mixin of submodules & constants\n'use strict';\n\nvar assign    = require('./lib/utils/common').assign;\n\nvar deflate   = require('./lib/deflate');\nvar inflate   = require('./lib/inflate');\nvar constants = require('./lib/zlib/constants');\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = require('./lib/_stream_duplex.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('events').EventEmitter;\n","module.exports = require('./readable').PassThrough\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","module.exports = require('./readable').Transform\n","module.exports = require('./lib/_stream_writable.js');\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict';\nmodule.exports = typeof setImmediate === 'function' ? setImmediate :\n\tfunction setImmediate() {\n\t\tvar args = [].slice.apply(arguments);\n\t\targs.splice(1, 0, 0);\n\t\tsetTimeout.apply(null, args);\n\t};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","import JSZip from \"jszip\";\nimport {IuploadfileList} from \"./ICommon\";\nimport {getBinaryContent} from \"./common/method\"\n\n\nexport class HandleZip{\n    uploadFile:File; \n    workBook:JSZip; \n    \n    constructor(file:File | void){\n        if(file instanceof File){\n            this.uploadFile = file;\n        }\n    }\n\n    unzipFile(successFunc:(file:IuploadfileList)=>void, errorFunc:(err:Error)=>void):void { \n        // var new_zip:JSZip = new JSZip();\n        JSZip.loadAsync(this.uploadFile)                                   // 1) read the Blob\n        .then(function(zip:any) {\n            let fileList:IuploadfileList = <IuploadfileList>{}, lastIndex:number = Object.keys(zip.files).length, index:number=0;\n            zip.forEach(function (relativePath:any, zipEntry:any) {  // 2) print entries\n                let fileName = zipEntry.name;\n                let fileNameArr = fileName.split(\".\");\n                let suffix = fileNameArr[fileNameArr.length-1].toLowerCase();\n                let fileType = \"string\";\n                if(suffix in {\"png\":1, \"jpeg\":1, \"jpg\":1, \"gif\":1,\"bmp\":1,\"tif\":1,\"webp\":1,}){\n                    fileType = \"base64\";\n                }\n                else if(suffix==\"emf\"){\n                    fileType = \"arraybuffer\";\n                }\n                zipEntry.async(fileType).then(function (data:string) {\n                    if(fileType==\"base64\"){\n                        data = \"data:image/\"+ suffix +\";base64,\" + data;\n                    }\n                    fileList[zipEntry.name] = data;\n                    // console.log(lastIndex, index);\n                    if(lastIndex==index+1){\n                        successFunc(fileList);\n                    }\n                    index++;\n                });\n            });\n            \n        }, function (e:Error) {\n            errorFunc(e);\n        });\n    }\n\n    unzipFileByUrl(url:string,successFunc:(file:IuploadfileList)=>void, errorFunc:(err:Error)=>void):void { \n        var new_zip:JSZip = new JSZip();\n        getBinaryContent(url, function(err:any, data:any) {\n            if(err) {\n                throw err; // or handle err\n            }\n        \n            JSZip.loadAsync(data).then(function(zip:any) {\n                let fileList:IuploadfileList = <IuploadfileList>{}, lastIndex:number = Object.keys(zip.files).length, index:number=0;\n                zip.forEach(function (relativePath:any, zipEntry:any) {  // 2) print entries\n                    let fileName = zipEntry.name;\n                    let fileNameArr = fileName.split(\".\");\n                    let suffix = fileNameArr[fileNameArr.length-1].toLowerCase();\n                    let fileType = \"string\";\n                    if(suffix in {\"png\":1, \"jpeg\":1, \"jpg\":1, \"gif\":1,\"bmp\":1,\"tif\":1,\"webp\":1,}){\n                        fileType = \"base64\";\n                    }\n                    else if(suffix==\"emf\"){\n                        fileType = \"arraybuffer\";\n                    }\n                    zipEntry.async(fileType).then(function (data:any) {\n                        if(fileType==\"base64\"){\n                            data = \"data:image/\"+ suffix +\";base64,\" + data;\n                        }\n                        fileList[zipEntry.name] = data;\n                        // console.log(lastIndex, index);\n                        if(lastIndex==index+1){\n                            successFunc(fileList);\n                        }\n                        index++;\n                    });\n                });\n                \n            }, function (e:Error) {\n                errorFunc(e);\n            });\n        });\n        \n    }\n\n    newZipFile():void { \n        var zip = new JSZip();\n        this.workBook =  zip;\n    }\n\n    //title:\"nested/hello.txt\", content:\"Hello Worldasdfasfasdfasfasfasfasfasdfas\"\n    addToZipFile(title:string,content:string):void { \n        if(this.workBook==null){\n            var zip = new JSZip();\n            this.workBook =  zip;\n        }\n        this.workBook.file(title, content);\n    }\n}","import { ILuckyFile, ILuckyFileInfo,IluckySheet,IluckySheetCelldata,IluckySheetConfig,IluckySheetCelldataValue,IluckySheetCelldataValueMerge,ILuckySheetCellFormat,IluckySheetConfigMerges,IluckySheetConfigMerge,IMapluckySheetborderInfoCellForImp,IluckySheetborderInfoCellValue,IluckySheetborderInfoCellValueStyle,IluckySheetborderInfoCellForImp,IluckySheetRowAndColumnLen,IluckySheetRowAndColumnHidden,IluckySheetSelection,IluckysheetFrozen,IluckySheetChart,IluckySheetPivotTable,IluckysheetConditionFormat,IluckysheetCalcChain,ILuckyInlineString,IluckyImage,IluckyImageBorder,IluckyImageCrop,IluckyImageDefault,IluckyImages} from \"./ILuck\";\n\n\n\nexport class LuckyFileBase implements ILuckyFile {\n    info:ILuckyFileInfo\n    sheets:IluckySheet[]\n}\n\nexport class LuckySheetBase implements IluckySheet{\n    name:string\n    color:string\n    config:IluckySheetConfig\n    index:string\n    status:string\n    order:string\n    row:number\n    column:number\n    luckysheet_select_save:IluckySheetSelection[]\n    scrollLeft:number\n    scrollTop:number\n    zoomRatio:number\n    showGridLines:string\n    defaultColWidth:number\n    defaultRowHeight:number\n\n    celldata:IluckySheetCelldata[]\n    chart:IluckySheetChart[]\n\n    isPivotTable:boolean\n    pivotTable:IluckySheetPivotTable\n\n    luckysheet_conditionformat_save:IluckysheetConditionFormat[]\n    freezen:IluckysheetFrozen\n\n    calcChain:IluckysheetCalcChain[]\n\n    images:IluckyImages\n}\n\nexport class LuckyFileInfo implements ILuckyFileInfo{\n    name:string\n    creator:string\n    lastmodifiedby:string\n    createdTime:string\n    modifiedTime:string\n    company:string\n    appversion:string\n}\n\nexport class LuckySheetCelldataBase implements IluckySheetCelldata{\n    r:number\n    c:number\n    v:IluckySheetCelldataValue | string | null\n}\n\nexport class LuckySheetCelldataValue implements IluckySheetCelldataValue{\n    ct: LuckySheetCellFormat | undefined //celltype,Cell value format: text, time, etc. numfmts\n    bg: string | undefined//background,#fff000,\tfill\n    ff: string | undefined//fontfamily, fonts\n    fc: string | undefined//fontcolor fonts\n    bl: number | undefined//Bold, fonts\n    it: number | undefined//italic, fonts\n    fs: number | undefined//font size, fonts\n    cl: number | undefined//strike, 0 Regular, 1 strikes, fonts\n    un: number | undefined//underline, 0 Regular, 1 underlines, fonts\n    vt: number | undefined//Vertical alignment, 0 middle, 1 up, 2 down, alignment\n    ht: number | undefined//Horizontal alignment,0 center, 1 left, 2 right, alignment\n    mc: IluckySheetCelldataValueMerge | undefined //Merge Cells, mergeCells\n    tr: number | undefined //Text rotation,0: 0、3 Vertical text alignment\n    tb: number | undefined //Text wrap,0 truncation, 1 overflow, 2 word wrap, alignment\n    v: string | undefined //Original value, v\n    m: string | undefined //Display value, v\n    f: string | undefined //formula, f\n    rt:number | undefined //text rotation angle 0-180 alignment\n    qp:number | undefined //quotePrefix, show number as string\n}\n\n\nexport class LuckySheetCellFormat implements ILuckySheetCellFormat {\n    fa:string\n    t:string\n    s:LuckyInlineString[] | undefined\n}\n\nexport class LuckyInlineString implements ILuckyInlineString {\n    ff:string | undefined //font family\n    fc:string | undefined//font color\n    fs:number | undefined//font size\n    cl:number | undefined//strike\n    un:number | undefined//underline\n    bl:number | undefined//blod\n    it:number | undefined//italic\n    va:number | undefined//1sub and 2super and 0none\n    v:string | undefined\n}\n\nexport class LuckyConfig implements IluckySheetConfig{\n    merge:IluckySheetConfigMerges\n    borderInfo:IluckySheetborderInfoCellForImp[]\n    // _borderInfo: IMapluckySheetborderInfoCellForImp\n    rowlen:IluckySheetRowAndColumnLen\n    columnlen:IluckySheetRowAndColumnLen\n    rowhidden:IluckySheetRowAndColumnHidden\n    colhidden:IluckySheetRowAndColumnHidden\n\n    customHeight:IluckySheetRowAndColumnHidden\n    customWidth:IluckySheetRowAndColumnHidden\n}\n\nexport class LuckySheetborderInfoCellForImp implements IluckySheetborderInfoCellForImp{\n    rangeType:string\n    // cells:string[]\n    value:IluckySheetborderInfoCellValue\n}\n\nexport class LuckySheetborderInfoCellValue implements IluckySheetborderInfoCellValue{\n    row_index: number\n    col_index: number\n    l: IluckySheetborderInfoCellValueStyle\n    r: IluckySheetborderInfoCellValueStyle\n    t: IluckySheetborderInfoCellValueStyle\n    b: IluckySheetborderInfoCellValueStyle\n}\n\nexport class LuckySheetborderInfoCellValueStyle implements IluckySheetborderInfoCellValueStyle{\n    \"style\": number\n    \"color\": string\n}\n\nexport class LuckySheetConfigMerge implements IluckySheetConfigMerge{\n    r: number\n    c: number\n    rs: number\n    cs: number\n}\n\nexport class LuckysheetCalcChain implements IluckysheetCalcChain{\n    r:number\n    c:number\n    index:string | undefined\n}\n\n\nexport class LuckyImageBase implements IluckyImage{\n    border: IluckyImageBorder\n    crop: IluckyImageCrop\n    default: IluckyImageDefault\n\n    fixedLeft: number\n    fixedTop: number\n    isFixedPos: Boolean\n    originHeight: number\n    originWidth: number\n    src: string\n    type: string\n}","import { IluckySheetborderInfoCellForImp,IluckySheetCelldataValue,IluckySheetCelldataValueMerge,ILuckySheetCellFormat } from \"./ILuck\";\nimport { ReadXml, Element, IStyleCollections,getColor,getlineStringAttr } from \"./ReadXml\";\nimport {getXmlAttibute, getColumnWidthPixel, getRowHeightPixel,getcellrange, escapeCharacter, isChinese, isJapanese, isKoera,isContainMultiType} from \"../common/method\";\nimport { ST_CellType, indexedColors, OEM_CHARSET,borderTypes,fontFamilys } from \"../common/constant\"\nimport { IattributeList, stringToNum } from \"../ICommon\";\nimport { LuckySheetborderInfoCellValueStyle,LuckySheetborderInfoCellForImp,LuckySheetborderInfoCellValue,LuckySheetCelldataBase,LuckySheetCelldataValue,LuckySheetCellFormat,LuckyInlineString } from \"./LuckyBase\";\n\nexport class LuckySheetCelldata extends LuckySheetCelldataBase{\n    _borderObject:IluckySheetborderInfoCellForImp\n    _fomulaRef:string\n    _formulaSi:string\n    _formulaType:string\n\n    private sheetFile:string\n    private readXml:ReadXml\n    private cell:Element\n    private styles:IStyleCollections\n    private sharedStrings:Element[]\n    private mergeCells:Element[]\n\n    constructor(cell:Element, styles:IStyleCollections, sharedStrings:Element[], mergeCells:Element[], sheetFile:string, ReadXml:ReadXml){\n        //Private\n        super();\n        this.cell = cell;\n        this.sheetFile = sheetFile;\n        this.styles = styles;\n        this.sharedStrings = sharedStrings;\n        this.readXml = ReadXml;\n        this.mergeCells = mergeCells;\n\n        let attrList = cell.attributeList;\n        let r = attrList.r, s = attrList.s, t = attrList.t;\n        let range = getcellrange(r);\n\n        this.r = range.row[0];\n        this.c = range.column[0];\n        this.v = this.generateValue(s, t);\n\n    }\n\n    /**\n    * @param s Style index ,start 1\n    * @param t Cell type, Optional value is ST_CellType, it's found at constat.ts\n    */\n    private generateValue(s:string, t:string){\n        let v = this.cell.getInnerElements(\"v\");\n        let f = this.cell.getInnerElements(\"f\");\n\n        if(v==null){\n            v = this.cell.getInnerElements(\"t\");\n        }\n\n        let cellXfs = this.styles[\"cellXfs\"] as Element[];\n        let cellStyleXfs = this.styles[\"cellStyleXfs\"] as Element[];\n        let cellStyles = this.styles[\"cellStyles\"] as Element[];\n        let fonts = this.styles[\"fonts\"] as Element[];\n        let fills = this.styles[\"fills\"] as Element[];\n        let borders = this.styles[\"borders\"] as Element[];\n        let numfmts = this.styles[\"numfmts\"] as IattributeList;\n        let clrScheme = this.styles[\"clrScheme\"] as Element[];\n\n        let sharedStrings = this.sharedStrings;\n        let cellValue = new LuckySheetCelldataValue();\n\n        if(f!=null){\n            let formula = f[0], attrList = formula.attributeList;\n            let t = attrList.t, ref = attrList.ref, si = attrList.si;\n            let formulaValue =f[0].value;\n            if(t==\"shared\"){\n                this._fomulaRef = ref;\n                this._formulaType = t;\n                this._formulaSi = si;\n            }\n            // console.log(ref, t, si);\n            if(ref!=null || (formulaValue!=null && formulaValue.length>0)){\n                formulaValue = escapeCharacter(formulaValue);\n                cellValue.f = \"=\" + formulaValue;\n            }\n\n        }\n\n        let familyFont = null;\n        let quotePrefix;\n        if(s!=null){\n            let sNum = parseInt(s);\n            let cellXf = cellXfs[sNum];\n            let xfId = cellXf.attributeList.xfId;\n\n            let numFmtId,fontId,fillId,borderId;\n            let horizontal,vertical, wrapText, textRotation, shrinkToFit, indent,applyProtection;\n\n            if(xfId!=null){\n                let cellStyleXf = cellStyleXfs[parseInt(xfId)];\n                let attrList = cellStyleXf.attributeList;\n\n                let applyNumberFormat = attrList.applyNumberFormat;\n                let applyFont = attrList.applyFont;\n                let applyFill = attrList.applyFill;\n                let applyBorder = attrList.applyBorder;\n                let applyAlignment = attrList.applyAlignment;\n                // let applyProtection = attrList.applyProtection;\n\n                applyProtection = attrList.applyProtection;\n                quotePrefix = attrList.quotePrefix;\n\n                if(applyNumberFormat!=\"0\" && attrList.numFmtId!=null){\n                    // if(attrList.numFmtId!=\"0\"){\n                        numFmtId = attrList.numFmtId;\n                    // }\n                }\n                if(applyFont!=\"0\" && attrList.fontId!=null){\n                    fontId = attrList.fontId;\n                }\n                if(applyFill!=\"0\" && attrList.fillId!=null){\n                    fillId = attrList.fillId;\n                }\n                if(applyBorder!=\"0\" && attrList.borderId!=null){\n                    borderId = attrList.borderId;\n                }\n                if(applyAlignment!=null && applyAlignment!=\"0\"){\n                    let alignment = cellStyleXf.getInnerElements(\"alignment\");\n                    if(alignment!=null){\n                        let attrList = alignment[0].attributeList;\n                        if(attrList.horizontal!=null){\n                            horizontal = attrList.horizontal;\n                        }\n                        if(attrList.vertical!=null){\n                            vertical = attrList.vertical;\n                        }\n                        if(attrList.wrapText!=null){\n                            wrapText = attrList.wrapText;\n                        }\n                        if(attrList.textRotation!=null){\n                            textRotation = attrList.textRotation;\n                        }\n                        if(attrList.shrinkToFit!=null){\n                            shrinkToFit = attrList.shrinkToFit;\n                        }\n                        if(attrList.indent!=null){\n                            indent = attrList.indent;\n                        }\n                    }\n                }\n            }\n\n            let applyNumberFormat = cellXf.attributeList.applyNumberFormat;\n            let applyFont = cellXf.attributeList.applyFont;\n            let applyFill = cellXf.attributeList.applyFill;\n            let applyBorder = cellXf.attributeList.applyBorder;\n            let applyAlignment = cellXf.attributeList.applyAlignment;\n            \n            if(cellXf.attributeList.applyProtection!=null){\n                applyProtection = cellXf.attributeList.applyProtection;\n            }\n            \n            if(cellXf.attributeList.quotePrefix!=null){\n                quotePrefix = cellXf.attributeList.quotePrefix;\n            }\n\n            if(applyNumberFormat!=\"0\" && cellXf.attributeList.numFmtId!=null){\n                numFmtId = cellXf.attributeList.numFmtId;\n            }\n            if(applyFont!=\"0\"){\n                fontId = cellXf.attributeList.fontId;\n            }\n            if(applyFill!=\"0\"){\n                fillId = cellXf.attributeList.fillId;\n            }\n            if(applyBorder!=\"0\"){\n                borderId =cellXf.attributeList.borderId;\n            }\n            if(applyAlignment!=\"0\"){\n                let alignment = cellXf.getInnerElements(\"alignment\");\n                if(alignment!=null && alignment.length>0){\n                    let attrList = alignment[0].attributeList;\n                    if(attrList.horizontal!=null){\n                        horizontal = attrList.horizontal;\n                    }\n                    if(attrList.vertical!=null){\n                        vertical = attrList.vertical;\n                    }\n                    if(attrList.wrapText!=null){\n                        wrapText = attrList.wrapText;\n                    }\n                    if(attrList.textRotation!=null){\n                        textRotation = attrList.textRotation;\n                    }\n                    if(attrList.shrinkToFit!=null){\n                        shrinkToFit = attrList.shrinkToFit;\n                    }\n                    if(attrList.indent!=null){\n                        indent = attrList.indent;\n                    }\n                }\n            }\n\n            \n\n            if(numFmtId!=undefined){\n                let numf = numfmts[parseInt(numFmtId)];\n                let cellFormat = new LuckySheetCellFormat();\n                cellFormat.fa = escapeCharacter(numf);\n                // console.log(numf, numFmtId, this.v);\n                cellFormat.t = t;\n                cellValue.ct = cellFormat;\n            }\n\n            if(fillId!=undefined){\n                let fillIdNum = parseInt(fillId);\n                let fill  = fills[fillIdNum];\n                // console.log(cellValue.v);\n                let bg = this.getBackgroundByFill(fill, clrScheme);\n                if(bg!=null){\n                    cellValue.bg = bg;\n                }\n            }\n\n            \n            if(fontId!=undefined){\n                let fontIdNum = parseInt(fontId);\n                let font = fonts[fontIdNum];\n                if(font!=null){\n                    let sz = font.getInnerElements(\"sz\");//font size\n                    let colors = font.getInnerElements(\"color\");//font color\n                    let family = font.getInnerElements(\"name\");//font family\n                    let familyOverrides = font.getInnerElements(\"family\");//font family will be overrided by name\n                    let charset = font.getInnerElements(\"charset\");//font charset\n                    let bolds = font.getInnerElements(\"b\");//font bold\n                    let italics = font.getInnerElements(\"i\");//font italic\n                    let strikes = font.getInnerElements(\"strike\");//font italic\n                    let underlines = font.getInnerElements(\"u\");//font italic\n\n                    if(sz!=null && sz.length>0){\n                        let fs = sz[0].attributeList.val;\n                        if(fs!=null){\n                            cellValue.fs = parseInt(fs);\n                        }\n                       \n                    }\n\n                    if(colors!=null && colors.length>0){\n                        let color = colors[0];\n                        let fc = getColor(color, this.styles, \"t\");\n                        if(fc!=null){\n                            cellValue.fc = fc;\n                        }\n                    }\n\n                    \n                    if(familyOverrides!=null && familyOverrides.length>0){\n                        let val = familyOverrides[0].attributeList.val;\n                        if(val!=null){\n                            familyFont = fontFamilys[val];\n                        }\n                    }\n\n                    if(family!=null && family.length>0){\n                        let val = family[0].attributeList.val;\n                        if(val!=null){\n                            cellValue.ff = val;\n                        }\n                    }\n                \n\n                    if(bolds!=null && bolds.length>0){\n                        let bold = bolds[0].attributeList.val;\n                        if(bold==\"0\"){\n                            cellValue.bl =  0;\n                        }\n                        else{\n                            cellValue.bl =  1;\n                        }\n                    }\n\n                    if(italics!=null && italics.length>0){\n                        let italic = italics[0].attributeList.val;\n                        if(italic==\"0\"){\n                            cellValue.it =  0;\n                        }\n                        else{\n                            cellValue.it =  1;\n                        }\n                    }\n\n                    if(strikes!=null && strikes.length>0){\n                        let strike = strikes[0].attributeList.val;\n                        if(strike==\"0\"){\n                            cellValue.cl =  0;\n                        }\n                        else{\n                            cellValue.cl =  1;\n                        }\n                    }\n\n                    if(underlines!=null && underlines.length>0){\n                        let underline = underlines[0].attributeList.val;\n                        if(underline==\"single\"){\n                            cellValue.un =  1;\n                        }\n                        else if(underline==\"double\"){\n                            cellValue.un =  2;\n                        }\n                        else if(underline==\"singleAccounting\"){\n                            cellValue.un =  3;\n                        }\n                        else if(underline==\"doubleAccounting\"){\n                            cellValue.un =  4;\n                        }\n                        else{\n                            cellValue.un =  0;\n                        }\n                    }\n                }\n            }\n\n            // vt: number | undefined//Vertical alignment, 0 middle, 1 up, 2 down, alignment\n            // ht: number | undefined//Horizontal alignment,0 center, 1 left, 2 right, alignment\n            // tr: number | undefined //Text rotation,0: 0、1: 45 、2: -45、3 Vertical text、4: 90 、5: -90, alignment\n            // tb: number | undefined //Text wrap,0 truncation, 1 overflow, 2 word wrap, alignment\n\n            if(horizontal!=undefined){//Horizontal alignment\n                if(horizontal==\"center\"){\n                    cellValue.ht = 0;\n                }\n                else if(horizontal==\"centerContinuous\"){\n                    cellValue.ht = 0;//luckysheet unsupport\n                }\n                else if(horizontal==\"left\"){\n                    cellValue.ht = 1;\n                }\n                else if(horizontal==\"right\"){\n                    cellValue.ht = 2;\n                }\n                else if(horizontal==\"distributed\"){\n                    cellValue.ht = 0;//luckysheet unsupport\n                }\n                else if(horizontal==\"fill\"){\n                    cellValue.ht = 1;//luckysheet unsupport\n                }\n                else if(horizontal==\"general\"){\n                    cellValue.ht = 1;//luckysheet unsupport\n                }\n                else if(horizontal==\"justify\"){\n                    cellValue.ht = 0;//luckysheet unsupport\n                }\n                else{\n                    cellValue.ht = 1;\n                }\n            }\n\n            if(vertical!=undefined){//Vertical alignment\n                if(vertical==\"bottom\"){\n                    cellValue.vt = 2;\n                }\n                else if(vertical==\"center\"){\n                    cellValue.vt = 0;\n                }\n                else if(vertical==\"distributed\"){\n                    cellValue.vt = 0;//luckysheet unsupport\n                }\n                else if(vertical==\"justify\"){\n                    cellValue.vt = 0;//luckysheet unsupport\n                }\n                else if(vertical==\"top\"){\n                    cellValue.vt = 1;\n                }\n                else{\n                    cellValue.vt = 1;\n                }\n            }\n\n            if(wrapText!=undefined){\n                if(wrapText==\"1\"){\n                    cellValue.tb = 2;\n                }\n                else{\n                    cellValue.tb = 1;\n                }\n            }\n            else{\n                cellValue.tb = 1;\n            }\n\n            if(textRotation!=undefined){\n                // tr: number | undefined //Text rotation,0: 0、1: 45 、2: -45、3 Vertical text、4: 90 、5: -90, alignment\n                if(textRotation==\"255\"){\n                    cellValue.tr = 3;\n                }\n                // else if(textRotation==\"45\"){\n                //     cellValue.tr = 1;\n                // }\n                // else if(textRotation==\"90\"){\n                //     cellValue.tr = 4;\n                // }\n                // else if(textRotation==\"135\"){\n                //     cellValue.tr = 2;\n                // }\n                // else if(textRotation==\"180\"){\n                //     cellValue.tr = 5;\n                // }\n                else{\n                    cellValue.tr = 0;\n                    cellValue.rt =  parseInt(textRotation);\n                }\n\n                \n            }\n\n            if(shrinkToFit!=undefined){//luckysheet unsupport\n                \n            }\n\n            if(indent!=undefined){//luckysheet unsupport\n                \n            }\n\n            if(borderId!=undefined){\n                let borderIdNum = parseInt(borderId);\n                let border = borders[borderIdNum];\n                // this._borderId = borderIdNum;\n\n                let borderObject = new LuckySheetborderInfoCellForImp();\n                borderObject.rangeType = \"cell\";\n                // borderObject.cells = [];\n                let borderCellValue = new LuckySheetborderInfoCellValue();\n\n                borderCellValue.row_index = this.r;\n                borderCellValue.col_index = this.c;\n                \n                let lefts = border.getInnerElements(\"left\");\n                let rights = border.getInnerElements(\"right\");\n                let tops = border.getInnerElements(\"top\");\n                let bottoms = border.getInnerElements(\"bottom\");\n                let diagonals = border.getInnerElements(\"diagonal\");\n\n                let starts = border.getInnerElements(\"start\");\n                let ends = border.getInnerElements(\"end\");\n\n                let left = this.getBorderInfo(lefts);\n                let right = this.getBorderInfo(rights);\n                let top = this.getBorderInfo(tops);\n                let bottom = this.getBorderInfo(bottoms);\n                let diagonal = this.getBorderInfo(diagonals);\n\n                let start = this.getBorderInfo(starts);\n                let end = this.getBorderInfo(ends);\n\n                let isAdd = false;\n\n                if(start!=null && start.color!=null){\n                    borderCellValue.l = start;\n                    isAdd = true;\n                }\n\n                if(end!=null && end.color!=null){\n                    borderCellValue.r = end;\n                    isAdd = true;\n                }\n\n                if(left!=null && left.color!=null){\n                    borderCellValue.l = left;\n                    isAdd = true;\n                }\n\n                if(right!=null && right.color!=null){\n                    borderCellValue.r = right;\n                    isAdd = true;\n                }\n\n                if(top!=null && top.color!=null){\n                    borderCellValue.t = top;\n                    isAdd = true;\n                }\n\n                if(bottom!=null && bottom.color!=null){\n                    borderCellValue.b = bottom;\n                    isAdd = true;\n                }\n\n                if(isAdd){\n                    borderObject.value = borderCellValue;\n                    // this.config._borderInfo[borderId] = borderObject;\n                    this._borderObject = borderObject;\n                }\n            }\n            \n        }\n        else{\n            cellValue.tb = 1;\n        }\n\n        if(v!=null){\n            let value =v[0].value;\n\n            if(/&#\\d+;/.test(value)){\n                value = this.htmlDecode(value);\n            }\n            \n            if(t==ST_CellType[\"SharedString\"]){\n                let siIndex = parseInt(v[0].value);\n                let sharedSI = sharedStrings[siIndex];\n\n                let rFlag = sharedSI.getInnerElements(\"r\");\n                if(rFlag==null){\n                    let tFlag = sharedSI.getInnerElements(\"t\");\n                    if(tFlag!=null){                            \n                        let text = \"\";\n                        tFlag.forEach((t)=>{\n                            text += t.value;\n                        });\n\n                        text = escapeCharacter(text);\n\n                        //isContainMultiType(text) &&\n                        if(familyFont==\"Roman\" && text.length>0){\n                            let textArray = text.split(\"\");\n                            let preWordType:string = null, wordText=\"\", preWholef:string=null;\n                            let wholef = \"Times New Roman\";\n                            if(cellValue.ff!=null){\n                                wholef = cellValue.ff;\n                            }\n\n                            let cellFormat = cellValue.ct;\n                            if(cellFormat==null){\n                                cellFormat = new LuckySheetCellFormat();\n                            }\n\n                            if(cellFormat.s==null){\n                                cellFormat.s = [];\n                            }\n                            \n                            for(let i=0;i<textArray.length;i++){\n                                let w = textArray[i];\n                                let type:string = null, ff=wholef;\n\n                                if(isChinese(w)){\n                                    type = \"c\";\n                                    ff=\"宋体\";\n                                }\n                                else if(isJapanese(w)){\n                                    type = \"j\";\n                                    ff=\"Yu Gothic\";\n                                }\n                                else if(isKoera(w)){\n                                    type = \"k\";\n                                    ff=\"Malgun Gothic\";\n                                }\n                                else{\n                                    type = \"e\";\n                                }\n\n                                if((type!=preWordType && preWordType!=null) || i==textArray.length-1){\n                                    let InlineString = new LuckyInlineString();\n\n                                    InlineString.ff = preWholef;\n        \n                                    if(cellValue.fc!=null){\n                                        InlineString.fc = cellValue.fc;\n                                    }\n                                    \n                                    if(cellValue.fs!=null){\n                                        InlineString.fs = cellValue.fs;\n                                    }\n        \n                                    if(cellValue.cl!=null){\n                                        InlineString.cl = cellValue.cl;\n                                    }\n        \n                                    if(cellValue.un!=null){\n                                        InlineString.un = cellValue.un;\n                                    }\n        \n                                    if(cellValue.bl!=null){\n                                        InlineString.bl = cellValue.bl;\n                                    }\n        \n                                    if(cellValue.it!=null){\n                                        InlineString.it = cellValue.it;\n                                    }\n\n                                    if(i==textArray.length-1){\n                                        if(type==preWordType){\n                                            InlineString.ff = ff;\n                                            InlineString.v = wordText + w;\n                                        }\n                                        else{\n                                            InlineString.ff = preWholef;\n                                            InlineString.v = wordText;\n                                            cellFormat.s.push(InlineString);\n\n                                            let InlineStringLast = new LuckyInlineString();\n                                            InlineStringLast.ff = ff;\n                                            InlineStringLast.v = w;\n                                            if(cellValue.fc!=null){\n                                                InlineStringLast.fc = cellValue.fc;\n                                            }\n                                            \n                                            if(cellValue.fs!=null){\n                                                InlineStringLast.fs = cellValue.fs;\n                                            }\n                \n                                            if(cellValue.cl!=null){\n                                                InlineStringLast.cl = cellValue.cl;\n                                            }\n                \n                                            if(cellValue.un!=null){\n                                                InlineStringLast.un = cellValue.un;\n                                            }\n                \n                                            if(cellValue.bl!=null){\n                                                InlineStringLast.bl = cellValue.bl;\n                                            }\n                \n                                            if(cellValue.it!=null){\n                                                InlineStringLast.it = cellValue.it;\n                                            }\n                                            cellFormat.s.push(InlineStringLast);\n\n                                            break;\n                                        }\n                                    }\n                                    else{\n                                        InlineString.v = wordText;\n                                    }\n                                    \n\n                                    cellFormat.s.push(InlineString);\n\n                                    wordText = w;\n                                }\n                                else{\n                                    wordText += w;\n                                }\n\n\n                                preWordType = type;\n                                preWholef = ff;\n                            }\n\n                            cellFormat.t = \"inlineStr\";\n                            // cellFormat.s = [InlineString];\n                            cellValue.ct = cellFormat;\n                            // console.log(cellValue);\n                        }\n                        else{\n\n    \n                            text = this.replaceSpecialWrap(text);\n    \n                            if(text.indexOf(\"\\r\\n\")>-1 || text.indexOf(\"\\n\")>-1){\n                                let InlineString = new LuckyInlineString();\n                                InlineString.v = text;\n                                let cellFormat = cellValue.ct;\n                                if(cellFormat==null){\n                                    cellFormat = new LuckySheetCellFormat();\n                                }\n    \n                                if(cellValue.ff!=null){\n                                    InlineString.ff = cellValue.ff;\n                                }\n    \n                                if(cellValue.fc!=null){\n                                    InlineString.fc = cellValue.fc;\n                                }\n                                \n                                if(cellValue.fs!=null){\n                                    InlineString.fs = cellValue.fs;\n                                }\n    \n                                if(cellValue.cl!=null){\n                                    InlineString.cl = cellValue.cl;\n                                }\n    \n                                if(cellValue.un!=null){\n                                    InlineString.un = cellValue.un;\n                                }\n    \n                                if(cellValue.bl!=null){\n                                    InlineString.bl = cellValue.bl;\n                                }\n    \n                                if(cellValue.it!=null){\n                                    InlineString.it = cellValue.it;\n                                }\n    \n                                cellFormat.t = \"inlineStr\";\n                                cellFormat.s = [InlineString];\n                                cellValue.ct = cellFormat;\n                            }\n                            else{\n                                cellValue.v = text;\n                                quotePrefix = \"1\";\n                            }\n                        }\n\n                    }\n                }\n                else{\n                    let styles:LuckyInlineString[] = [];\n                    rFlag.forEach((r)=>{\n                        let tFlag = r.getInnerElements(\"t\");\n                        let rPr = r.getInnerElements(\"rPr\");\n                        \n                        let InlineString = new LuckyInlineString();\n\n                        if(tFlag!=null && tFlag.length>0){\n                            let text = tFlag[0].value;\n                            text = this.replaceSpecialWrap(text);\n                            text = escapeCharacter(text);\n                            InlineString.v = text;\n                        }\n\n                        if(rPr!=null && rPr.length>0){\n                            let frpr = rPr[0];\n                            let sz = getlineStringAttr(frpr,\"sz\"), rFont=getlineStringAttr(frpr,\"rFont\"), family=getlineStringAttr(frpr,\"family\"), charset=getlineStringAttr(frpr,\"charset\"), scheme=getlineStringAttr(frpr,\"scheme\"), b=getlineStringAttr(frpr,\"b\"), i=getlineStringAttr(frpr,\"i\"), u=getlineStringAttr(frpr,\"u\"), strike=getlineStringAttr(frpr,\"strike\"), vertAlign=getlineStringAttr(frpr,\"vertAlign\"), color;\n\n\n                            let cEle = frpr.getInnerElements(\"color\");\n                            if(cEle!=null && cEle.length>0){\n                                color = getColor(cEle[0],this.styles, \"t\");\n                            }\n\n                            \n                            let ff;\n                            // if(family!=null){\n                            //     ff = fontFamilys[family];\n                            // }\n                            if(rFont!=null){\n                                ff = rFont;\n                            }\n                            if(ff!=null){\n                                InlineString.ff = ff;\n                            }\n                            else if(cellValue.ff!=null){\n                                InlineString.ff = cellValue.ff;\n                            }\n\n                            if(color!=null){\n                                InlineString.fc = color;\n                            }\n                            else if(cellValue.fc!=null){\n                                InlineString.fc = cellValue.fc;\n                            }\n                            \n                            if(sz!=null){\n                                InlineString.fs = parseInt(sz);\n                            }\n                            else if(cellValue.fs!=null){\n                                InlineString.fs = cellValue.fs;\n                            }\n\n                            if(strike!=null){\n                                InlineString.cl = parseInt(strike);\n                            }\n                            else if(cellValue.cl!=null){\n                                InlineString.cl = cellValue.cl;\n                            }\n\n                            if(u!=null){\n                                InlineString.un = parseInt(u);\n                            }\n                            else if(cellValue.un!=null){\n                                InlineString.un = cellValue.un;\n                            }\n\n                            if(b!=null){\n                                InlineString.bl = parseInt(b);\n                            }\n                            else if(cellValue.bl!=null){\n                                InlineString.bl = cellValue.bl;\n                            }\n\n                            if(i!=null){\n                                InlineString.it = parseInt(i);\n                            }\n                            else if(cellValue.it!=null){\n                                InlineString.it = cellValue.it;\n                            }\n\n                            if(vertAlign!=null){\n                                InlineString.va = parseInt(vertAlign);\n                            }\n\n\n                            // ff:string | undefined //font family\n                            // fc:string | undefined//font color\n                            // fs:number | undefined//font size\n                            // cl:number | undefined//strike\n                            // un:number | undefined//underline\n                            // bl:number | undefined//blod\n                            // it:number | undefined//italic\n                            // v:string | undefined\n                        }\n                        else{\n                            if(InlineString.ff==null && cellValue.ff!=null){\n                                InlineString.ff = cellValue.ff;\n                            }\n    \n                            if(InlineString.fc==null && cellValue.fc!=null){\n                                InlineString.fc = cellValue.fc;\n                            }\n                            \n                            if(InlineString.fs==null && cellValue.fs!=null){\n                                InlineString.fs = cellValue.fs;\n                            }\n    \n                            if(InlineString.cl==null && cellValue.cl!=null){\n                                InlineString.cl = cellValue.cl;\n                            }\n    \n                            if(InlineString.un==null && cellValue.un!=null){\n                                InlineString.un = cellValue.un;\n                            }\n    \n                            if(InlineString.bl==null && cellValue.bl!=null){\n                                InlineString.bl = cellValue.bl;\n                            }\n    \n                            if(InlineString.it==null && cellValue.it!=null){\n                                InlineString.it = cellValue.it;\n                            }\n                        }\n\n\n                        styles.push(InlineString);\n                    });\n\n                    let cellFormat = cellValue.ct;\n                    if(cellFormat==null){\n                        cellFormat = new LuckySheetCellFormat();\n                    }\n                    cellFormat.t = \"inlineStr\";\n                    cellFormat.s = styles;\n                    cellValue.ct = cellFormat;\n                }\n            }\n            // else if(t==ST_CellType[\"InlineString\"] && v!=null){\n    \n            // }\n            else {\n                value = escapeCharacter(value);\n                cellValue.v = value;\n            }\n        }\n\n        if(quotePrefix!=null){\n            cellValue.qp = parseInt(quotePrefix);\n        }\n\n        return cellValue;\n    \n    }\n\n    private replaceSpecialWrap(text:string):string{\n        text = text.replace(/_x000D_/g, \"\").replace(/&#13;&#10;/g, \"\\r\\n\").replace(/&#13;/g, \"\\r\").replace(/&#10;/g, \"\\n\");\n        return text;\n    }\n\n\n    private getBackgroundByFill(fill:Element, clrScheme:Element[]):string|null{\n        let patternFills = fill.getInnerElements(\"patternFill\");\n        if(patternFills!=null){\n            let patternFill = patternFills[0];\n            let fgColors = patternFill.getInnerElements(\"fgColor\");\n            let bgColors = patternFill.getInnerElements(\"bgColor\");\n            let fg, bg;\n            if(fgColors!=null){\n                let fgColor = fgColors[0];\n                fg = getColor(fgColor, this.styles);\n            }\n\n            if(bgColors!=null){\n                let bgColor = bgColors[0];\n                bg = getColor(bgColor, this.styles);\n            }\n            // console.log(fgColors,bgColors,clrScheme);\n            if(fg!=null){\n                return fg;\n            }\n            else if(bg!=null){\n                return bg;\n            }\n        }\n        else{\n            let gradientfills = fill.getInnerElements(\"gradientFill\");\n            if(gradientfills!=null){\n                //graient color fill handler\n\n                return null;\n            }\n        }\n    }\n\n    private getBorderInfo(borders:Element[]):LuckySheetborderInfoCellValueStyle{\n        if(borders==null){\n            return null;\n        }\n\n        let border = borders[0], attrList = border.attributeList;\n        let clrScheme = this.styles[\"clrScheme\"] as Element[];\n        let style:string = attrList.style;\n        if(style==null || style==\"none\"){\n            return null;\n        }\n\n        let colors = border.getInnerElements(\"color\");\n        let colorRet = \"#000000\";\n        if(colors!=null){\n            let color = colors[0];\n            colorRet = getColor(color, this.styles, \"b\");\n            if(colorRet==null){\n                colorRet = \"#000000\";\n            }\n        }\n\n        let ret = new LuckySheetborderInfoCellValueStyle();\n        ret.style = borderTypes[style];\n        ret.color = colorRet;\n\n        return ret;\n    }\n\n    private htmlDecode (str:string):string {\n        return str.replace(/&#(x)?([^&]{1,5});?/g,function($,$1,$2) {\n            return String.fromCharCode(parseInt($2 , $1 ? 16:10));\n        });\n    };\n\n}\n\n","﻿import { ILuckyFile,IluckySheetRowAndColumnHidden,IluckySheetRowAndColumnLen} from \"./ILuck\";\nimport { LuckySheet} from \"./LuckySheet\";\nimport {IuploadfileList, IattributeList} from \"../ICommon\";\nimport {workBookFile, coreFile, appFile, stylesFile, sharedStringsFile,numFmtDefault,theme1File,calcChainFile,workbookRels} from \"../common/constant\";\nimport { ReadXml,IStyleCollections,Element } from \"./ReadXml\";\nimport {getXmlAttibute} from \"../common/method\";\nimport { LuckyFileBase,LuckyFileInfo,LuckySheetBase,LuckySheetCelldataBase,LuckySheetCelldataValue,LuckySheetCellFormat } from \"./LuckyBase\";\nimport {ImageList} from \"./LuckyImage\";\n\nexport class LuckyFile extends LuckyFileBase {\n\n    private files:IuploadfileList\n    private sheetNameList:IattributeList\n    private readXml:ReadXml\n    private fileName:string\n    private styles:IStyleCollections\n    private sharedStrings:Element[]\n    private calcChain:Element[]\n    private imageList:ImageList\n\n    constructor(files:IuploadfileList, fileName:string) { \n        super();\n        this.files = files;\n        this.fileName = fileName;\n        this.readXml = new ReadXml(files);\n        this.getSheetNameList();\n\n        this.sharedStrings = this.readXml.getElementsByTagName(\"sst/si\", sharedStringsFile);\n        this.calcChain = this.readXml.getElementsByTagName(\"calcChain/c\", calcChainFile);\n        this.styles = {};\n        this.styles[\"cellXfs\"] =  this.readXml.getElementsByTagName(\"cellXfs/xf\", stylesFile);\n        this.styles[\"cellStyleXfs\"] =  this.readXml.getElementsByTagName(\"cellStyleXfs/xf\", stylesFile);\n        this.styles[\"cellStyles\"] =  this.readXml.getElementsByTagName(\"cellStyles/cellStyle\", stylesFile);\n        this.styles[\"fonts\"] =  this.readXml.getElementsByTagName(\"fonts/font\", stylesFile);\n        this.styles[\"fills\"] =  this.readXml.getElementsByTagName(\"fills/fill\", stylesFile);\n        this.styles[\"borders\"] =  this.readXml.getElementsByTagName(\"borders/border\", stylesFile);\n        this.styles[\"clrScheme\"] =  this.readXml.getElementsByTagName(\"a:clrScheme/a:dk1|a:lt1|a:dk2|a:lt2|a:accent1|a:accent2|a:accent3|a:accent4|a:accent5|a:accent6|a:hlink|a:folHlink\", theme1File);\n        this.styles[\"indexedColors\"] =  this.readXml.getElementsByTagName(\"colors/indexedColors/rgbColor\", stylesFile);\n        this.styles[\"mruColors\"] =  this.readXml.getElementsByTagName(\"colors/mruColors/color\", stylesFile);\n\n        this.imageList = new ImageList(files);\n\n        let numfmts =  this.readXml.getElementsByTagName(\"numFmt/numFmt\", stylesFile);\n        let numFmtDefaultC = numFmtDefault;\n        for(let i=0;i<numfmts.length;i++){\n            let attrList = numfmts[i].attributeList;\n            let numfmtid = getXmlAttibute(attrList, \"numFmtId\", \"49\");\n            let formatcode = getXmlAttibute(attrList, \"formatCode\", \"@\");\n            // console.log(numfmtid, formatcode);\n            if(!(numfmtid in numFmtDefault)){\n                numFmtDefaultC[numfmtid] = formatcode;\n            }\n        }\n\n        // console.log(JSON.stringify(numFmtDefaultC), numfmts);\n        this.styles[\"numfmts\"] =  numFmtDefaultC;\n    }\n\n    /**\n    * @return All sheet name of workbook\n    */\n    private getSheetNameList(){\n        let workbookRelList = this.readXml.getElementsByTagName(\"Relationships/Relationship\", workbookRels);\n        if(workbookRelList==null){\n            return;\n        }\n\n        let regex = new RegExp(\"worksheets/[^/]*?.xml\");\n        let sheetNames:IattributeList = {};\n        for(let i=0;i<workbookRelList.length;i++){\n            let rel = workbookRelList[i], attrList = rel.attributeList;\n            let id = attrList[\"Id\"], target = attrList[\"Target\"];\n            if(regex.test(target)){\n                sheetNames[id] = \"xl/\" + target;\n            }\n           \n        }\n\n        this.sheetNameList = sheetNames;\n    }\n\n    /**\n    * @param sheetName WorkSheet'name \n    * @return sheet file name and path in zip\n    */\n   private getSheetFileBysheetId(sheetId:string){\n        // for(let i=0;i<this.sheetNameList.length;i++){\n        //     let sheetFileName = this.sheetNameList[i];\n        //     if(sheetFileName.indexOf(\"sheet\"+sheetId)>-1){\n        //         return sheetFileName;\n        //     }\n        // }\n        return this.sheetNameList[sheetId];\n    }\n\n    /**\n    * @return workBook information\n    */\n    getWorkBookInfo(){\n        let Company = this.readXml.getElementsByTagName(\"Company\", appFile);\n        let AppVersion = this.readXml.getElementsByTagName(\"AppVersion\", appFile);\n        let creator = this.readXml.getElementsByTagName(\"dc:creator\", coreFile);\n        let lastModifiedBy = this.readXml.getElementsByTagName(\"cp:lastModifiedBy\", coreFile);\n        let created = this.readXml.getElementsByTagName(\"dcterms:created\", coreFile);\n        let modified = this.readXml.getElementsByTagName(\"dcterms:modified\", coreFile);\n        this.info = new LuckyFileInfo();\n        this.info.name = this.fileName;\n        this.info.creator = creator.length>0?creator[0].value:\"\";\n        this.info.lastmodifiedby = lastModifiedBy.length>0?lastModifiedBy[0].value:\"\";\n        this.info.createdTime = created.length>0?created[0].value:\"\";\n        this.info.modifiedTime = modified.length>0?modified[0].value:\"\";\n        this.info.company = Company.length>0?Company[0].value:\"\";\n        this.info.appversion = AppVersion.length>0?AppVersion[0].value:\"\";\n    }\n\n    /**\n    * @return All sheet , include whole information\n    */\n    getSheetsFull(isInitialCell:boolean=true){\n        let sheets = this.readXml.getElementsByTagName(\"sheets/sheet\", workBookFile);\n        let sheetList:IattributeList = {};\n        for(let key in sheets){\n            let sheet = sheets[key];\n            sheetList[sheet.attributeList.name] = sheet.attributeList[\"sheetId\"];\n        }\n        this.sheets = [];\n        let order = 0;\n        for(let key in sheets){\n            let sheet = sheets[key];\n            let sheetName = sheet.attributeList.name; \n            let sheetId = sheet.attributeList[\"sheetId\"]; \n            let rid = sheet.attributeList[\"r:id\"]; \n            let sheetFile = this.getSheetFileBysheetId(rid);\n\n            let drawing = this.readXml.getElementsByTagName(\"worksheet/drawing\", sheetFile), drawingFile, drawingRelsFile;\n            if(drawing!=null && drawing.length>0){\n                let attrList = drawing[0].attributeList;\n                let rid = getXmlAttibute(attrList, \"r:id\", null);\n                if(rid!=null){\n                    drawingFile = this.getDrawingFile(rid, sheetFile);\n                    drawingRelsFile = this.getDrawingRelsFile(drawingFile);\n                }\n            }\n  \n            if(sheetFile!=null){\n                let sheet = new LuckySheet(sheetName, sheetId, order, isInitialCell,\n                    {\n                        sheetFile:sheetFile,\n                        readXml:this.readXml, \n                        sheetList:sheetList, \n                        styles:this.styles, \n                        sharedStrings:this.sharedStrings, \n                        calcChain:this.calcChain, \n                        imageList:this.imageList,\n                        drawingFile:drawingFile,\n                        drawingRelsFile:drawingRelsFile,\n                    }\n                )\n\n                this.columnWidthSet = [];\n                this.rowHeightSet = [];\n\n                this.imagePositionCaculation(sheet);\n\n                this.sheets.push(sheet);\n                order++;\n            }\n        }\n    }\n\n    private columnWidthSet:number[] = [];\n    private rowHeightSet:number[] = [];\n\n    private extendArray(index:number, sets:number[],def:number, hidden:IluckySheetRowAndColumnHidden, lens:IluckySheetRowAndColumnLen){\n        if(index<sets.length){\n            return;\n        }\n        \n        let startIndex = sets.length, endIndex = index;\n        let allGap = 0;\n        if(startIndex>0){\n            allGap = sets[startIndex-1];\n        }\n        // else{\n        //     sets.push(0);\n        // }\n        for(let i=startIndex;i<=endIndex;i++){\n            let gap = def, istring  = i.toString();\n            if(istring in hidden){\n                gap = 0;\n            }\n            else if(istring in lens){\n                gap = lens[istring];\n            }\n\n            allGap += Math.round(gap + 1);\n\n            sets.push(allGap);\n        }\n    }\n    \n    private imagePositionCaculation(sheet:LuckySheet){\n        let images = sheet.images, defaultColWidth = sheet.defaultColWidth, defaultRowHeight = sheet.defaultRowHeight;\n        let colhidden = {};\n        if(sheet.config.colhidden){\n            colhidden = sheet.config.colhidden;\n        }\n\n        let columnlen = {};\n        if(sheet.config.columnlen){\n            columnlen = sheet.config.columnlen;\n        }\n\n        let rowhidden = {};\n        if(sheet.config.rowhidden){\n            rowhidden = sheet.config.rowhidden;\n        }\n\n        let rowlen = {};\n        if(sheet.config.rowlen){\n            rowlen = sheet.config.rowlen;\n        }\n        \n        for(let key in images){\n            let imageObject:any = images[key];//Image, luckyImage\n            let fromCol = imageObject.fromCol;\n            let fromColOff = imageObject.fromColOff;\n            let fromRow = imageObject.fromRow;\n            let fromRowOff = imageObject.fromRowOff;\n\n            let toCol = imageObject.toCol;\n            let toColOff = imageObject.toColOff;\n            let toRow = imageObject.toRow;\n            let toRowOff = imageObject.toRowOff;\n\n            let x_n =0,y_n = 0;\n            let cx_n = 0, cy_n = 0; \n\n            if(fromCol>=this.columnWidthSet.length){\n                this.extendArray(fromCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);\n            }\n            if(fromCol==0){\n                x_n = 0;\n            }\n            else{\n                x_n = this.columnWidthSet[fromCol-1];\n            }\n            x_n = x_n + fromColOff;\n\n            if(fromRow>=this.rowHeightSet.length){\n                this.extendArray(fromRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);\n            }\n            if(fromRow==0){\n                y_n = 0;\n            }\n            else{\n                y_n = this.rowHeightSet[fromRow-1];\n            }\n            y_n = y_n + fromRowOff;\n\n\n            if(toCol>=this.columnWidthSet.length){\n                this.extendArray(toCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);\n            }\n            if(toCol==0){\n                cx_n = 0;\n            }\n            else{\n                cx_n = this.columnWidthSet[toCol-1];\n            }\n            cx_n = cx_n + toColOff- x_n;\n\n            if(toRow>=this.rowHeightSet.length){\n                this.extendArray(toRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);\n            }\n            if(toRow==0){\n                cy_n = 0;\n            }\n            else{\n                cy_n = this.rowHeightSet[toRow-1];\n            }\n\n            cy_n = cy_n + toRowOff - y_n;\n\n            console.log(defaultColWidth, colhidden , columnlen);\n            console.log(fromCol, this.columnWidthSet[fromCol] , fromColOff);\n            console.log(toCol, this.columnWidthSet[toCol] , toColOff, JSON.stringify(this.columnWidthSet));\n\n            imageObject.originWidth = cx_n;\n            imageObject.originHeight = cy_n;\n\n            imageObject.crop.height = cy_n;\n            imageObject.crop.width = cx_n;\n\n            imageObject.default.height = cy_n;\n            imageObject.default.left = x_n;\n            imageObject.default.top = y_n;\n            imageObject.default.width = cx_n;\n        }\n\n        console.log(this.columnWidthSet, this.rowHeightSet);\n    }\n\n    /**\n    * @return drawing file string\n    */\n   private getDrawingFile(rid:string, sheetFile:string):string{\n        let sheetRelsPath = \"xl/worksheets/_rels/\";\n        let sheetFileArr = sheetFile.split(\"/\");\n        let sheetRelsName = sheetFileArr[sheetFileArr.length-1];\n\n        let sheetRelsFile = sheetRelsPath + sheetRelsName + \".rels\";\n\n        let drawing = this.readXml.getElementsByTagName(\"Relationships/Relationship\", sheetRelsFile);\n        if(drawing.length>0){\n            for(let i=0;i<drawing.length;i++){\n                let relationship = drawing[i];\n                let attrList = relationship.attributeList;\n                let relationshipId = getXmlAttibute(attrList, \"Id\", null);\n                if(relationshipId==rid){\n                    let target = getXmlAttibute(attrList, \"Target\", null);\n                    if(target!=null){\n                        return target.replace(/\\.\\.\\//g, \"\");\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n    \n    private getDrawingRelsFile(drawingFile:string):string{\n        let drawingRelsPath = \"xl/drawings/_rels/\";\n        let drawingFileArr = drawingFile.split(\"/\");\n        let drawingRelsName = drawingFileArr[drawingFileArr.length-1];\n\n        let drawingRelsFile = drawingRelsPath + drawingRelsName + \".rels\";\n\n        return drawingRelsFile;\n    }\n\n    /**\n    * @return All sheet base information widthout cell and config\n    */\n    getSheetsWithoutCell(){\n        this.getSheetsFull(false);\n    }\n    \n    /**\n    * @return LuckySheet file json\n    */\n    Parse():string{\n        // let xml = this.readXml;\n        // for(let key in this.sheetNameList){\n        //     let sheetName=this.sheetNameList[key];\n        //     let sheetColumns = xml.getElementsByTagName(\"row/c/f\", sheetName);\n        //     console.log(sheetColumns);\n        // }\n        // return \"\";\n\n        this.getWorkBookInfo();\n        this.getSheetsFull();\n\n        // for(let i=0;i<this.sheets.length;i++){\n        //     let sheet = this.sheets[i];\n        //     let _borderInfo = sheet.config._borderInfo;\n        //     if(_borderInfo==null){\n        //         continue;\n        //     }\n        //     let _borderInfoKeys = Object.keys(_borderInfo);\n        //     _borderInfoKeys.sort();\n        //     for(let a=0;a<_borderInfoKeys.length;a++){\n        //         let key = parseInt(_borderInfoKeys[a]);\n        //         let b = _borderInfo[key];\n        //         if(b.cells.length==0){\n        //             continue;\n        //         }\n        //         if(sheet.config.borderInfo==null){\n        //             sheet.config.borderInfo = [];\n        //         }\n        //         sheet.config.borderInfo.push(b);\n        //     }\n        // }\n\n        return this.toJsonString(this);\n    }\n\n    private toJsonString(file:ILuckyFile):string{\n        let LuckyOutPutFile = new LuckyFileBase();\n        LuckyOutPutFile.info = file.info;\n        LuckyOutPutFile.sheets = [];\n\n        file.sheets.forEach((sheet)=>{\n            let sheetout = new LuckySheetBase();\n            //let attrName = [\"name\",\"color\",\"config\",\"index\",\"status\",\"order\",\"row\",\"column\",\"luckysheet_select_save\",\"scrollLeft\",\"scrollTop\",\"zoomRatio\",\"showGridLines\",\"defaultColWidth\",\"defaultRowHeight\",\"celldata\",\"chart\",\"isPivotTable\",\"pivotTable\",\"luckysheet_conditionformat_save\",\"freezen\",\"calcChain\"];\n\n            if(sheet.name!=null){\n                sheetout.name = sheet.name;\n            }\n\n            if(sheet.color!=null){\n                sheetout.color = sheet.color;\n            }\n\n            if(sheet.config!=null){\n                sheetout.config = sheet.config;\n                // if(sheetout.config._borderInfo!=null){\n                //     delete sheetout.config._borderInfo;\n                // }\n            }\n\n            if(sheet.index!=null){\n                sheetout.index = sheet.index;\n            }\n\n            if(sheet.status!=null){\n                sheetout.status = sheet.status;\n            }\n\n            if(sheet.order!=null){\n                sheetout.order = sheet.order;\n            }\n\n            if(sheet.row!=null){\n                sheetout.row = sheet.row;\n            }\n\n            if(sheet.column!=null){\n                sheetout.column = sheet.column;\n            }\n\n            if(sheet.luckysheet_select_save!=null){\n                sheetout.luckysheet_select_save = sheet.luckysheet_select_save;\n            }\n\n            if(sheet.scrollLeft!=null){\n                sheetout.scrollLeft = sheet.scrollLeft;\n            }\n\n            if(sheet.scrollTop!=null){\n                sheetout.scrollTop = sheet.scrollTop;\n            }\n\n            if(sheet.zoomRatio!=null){\n                sheetout.zoomRatio = sheet.zoomRatio;\n            }\n\n            if(sheet.showGridLines!=null){\n                sheetout.showGridLines = sheet.showGridLines;\n            }\n\n            if(sheet.defaultColWidth!=null){\n                sheetout.defaultColWidth = sheet.defaultColWidth;\n            }\n\n            if(sheet.defaultRowHeight!=null){\n                sheetout.defaultRowHeight = sheet.defaultRowHeight;\n            }\n\n            if(sheet.celldata!=null){\n                // sheetout.celldata = sheet.celldata;\n                sheetout.celldata = [];\n                sheet.celldata.forEach((cell)=>{\n                    let cellout = new LuckySheetCelldataBase();\n                    cellout.r = cell.r;\n                    cellout.c = cell.c;\n                    cellout.v = cell.v;\n                    sheetout.celldata.push(cellout);\n                });\n            }\n\n            if(sheet.chart!=null){\n                sheetout.chart = sheet.chart;\n            }\n\n            if(sheet.isPivotTable!=null){\n                sheetout.isPivotTable = sheet.isPivotTable;\n            }\n\n            if(sheet.pivotTable!=null){\n                sheetout.pivotTable = sheet.pivotTable;\n            }\n\n            if(sheet.luckysheet_conditionformat_save!=null){\n                sheetout.luckysheet_conditionformat_save = sheet.luckysheet_conditionformat_save;\n            }\n\n            if(sheet.freezen!=null){\n                sheetout.freezen = sheet.freezen;\n            }\n\n            if(sheet.calcChain!=null){\n                sheetout.calcChain = sheet.calcChain;\n            }\n\n            if(sheet.images!=null){\n                sheetout.images = sheet.images;\n            }\n            \n            LuckyOutPutFile.sheets.push(sheetout);\n        });\n\n        return JSON.stringify(LuckyOutPutFile);\n    }\n\n\n}","import { IluckyImage } from \"./ILuck\";\nimport {LuckySheetCelldata} from \"./LuckyCell\";\nimport { IuploadfileList, IattributeList } from \"../ICommon\";\nimport {getXmlAttibute, getColumnWidthPixel, fromulaRef,getRowHeightPixel,getcellrange} from \"../common/method\";\nimport {borderTypes} from \"../common/constant\";\nimport { ReadXml, IStyleCollections, Element,getColor } from \"./ReadXml\";\nimport { LuckyImageBase } from \"./LuckyBase\";\nimport { UDOC,FromEMF,ToContext2D  } from \"../common/emf\";\n\n\nexport class ImageList {\n    private images:IattributeList\n    constructor(files:IuploadfileList) {\n        if(files==null){\n            return;\n        }\n        this.images = {};\n        for(let fileKey in files){\n            // let reg = new RegExp(\"xl/media/image1.png\", \"g\");\n            if(fileKey.indexOf(\"xl/media/\")>-1){\n                let fileNameArr = fileKey.split(\".\");\n                let suffix = fileNameArr[fileNameArr.length-1].toLowerCase();\n                if(suffix in {\"png\":1, \"jpeg\":1, \"jpg\":1, \"gif\":1,\"bmp\":1,\"tif\":1,\"webp\":1,\"emf\":1}){\n                    if(suffix==\"emf\"){\n                        var pNum  = 0;  // number of the page, that you want to render\n                        var scale = 1;  // the scale of the document\n                        var wrt = new ToContext2D(pNum, scale);\n                        var inp, out, stt;\n                        FromEMF.K = [];\n                        inp = FromEMF.C;   out = FromEMF.K;   stt=4;\n                        for(var p in inp) out[inp[p]] = p.slice(stt);\n                        FromEMF.Parse(files[fileKey], wrt);\n                        this.images[fileKey] = wrt.canvas.toDataURL(\"image/png\");\n                    }\n                    else{\n                        this.images[fileKey] = files[fileKey];\n                    }\n                    \n                }\n            }\n        }\n    }\n\n    getImageByName(pathName:string):Image{\n        if(pathName in this.images){\n            let base64 = this.images[pathName];\n            return new Image(pathName, base64);\n        }\n        return null;\n    }\n}\n\n\nclass Image extends LuckyImageBase {\n\n    fromCol:number\n    fromColOff:number\n    fromRow:number\n    fromRowOff:number\n\n    toCol:number\n    toColOff:number\n    toRow:number\n    toRowOff:number\n\n    constructor(pathName:string, base64:string) {\n        super();\n        this.src = base64;\n    }\n\n    setDefault(){\n\n    }\n}","﻿import { IluckyImageBorder,IluckyImageCrop,IluckyImageDefault,IluckyImages,IluckySheetCelldata,IluckySheetCelldataValue,IMapluckySheetborderInfoCellForImp,IluckySheetborderInfoCellValue,IluckySheetborderInfoCellValueStyle,IFormulaSI,IluckySheetRowAndColumnLen,IluckySheetRowAndColumnHidden,IluckySheetSelection,IluckysheetFrozen} from \"./ILuck\";\nimport {LuckySheetCelldata} from \"./LuckyCell\";\nimport { IattributeList } from \"../ICommon\";\nimport {getXmlAttibute, getColumnWidthPixel, fromulaRef,getRowHeightPixel,getcellrange,generateRandomIndex,getPxByEMUs} from \"../common/method\";\nimport {borderTypes} from \"../common/constant\";\nimport { ReadXml, IStyleCollections, Element,getColor } from \"./ReadXml\";\nimport { LuckyFileBase,LuckySheetBase,LuckyConfig,LuckySheetborderInfoCellForImp,LuckySheetborderInfoCellValue,LuckysheetCalcChain,LuckySheetConfigMerge } from \"./LuckyBase\";\nimport {ImageList} from \"./LuckyImage\";\n\nexport class LuckySheet extends LuckySheetBase {\n\n    private readXml:ReadXml\n    private sheetFile:string\n    private isInitialCell:boolean\n    private styles:IStyleCollections\n    private sharedStrings:Element[]\n    private mergeCells:Element[]\n    private calcChainEles:Element[]\n    private sheetList:IattributeList\n\n    private imageList:ImageList\n\n    private formulaRefList:IFormulaSI\n\n    constructor(sheetName:string, sheetId:string, sheetOrder:number,isInitialCell:boolean=false, allFileOption:any){\n        //Private\n        super();\n        this.isInitialCell = isInitialCell;\n\n        this.readXml = allFileOption.readXml;\n        this.sheetFile = allFileOption.sheetFile;\n        this.styles = allFileOption.styles;\n        this.sharedStrings = allFileOption.sharedStrings;\n        this.calcChainEles = allFileOption.calcChain;\n        this.sheetList = allFileOption.sheetList;\n        this.imageList = allFileOption.imageList;  \n\n        //Output\n        this.name = sheetName;\n        this.index = sheetId;\n        this.order = sheetOrder.toString();\n        this.config = new LuckyConfig();\n        this.celldata = [];\n        this.mergeCells = this.readXml.getElementsByTagName(\"mergeCells/mergeCell\", this.sheetFile);\n        let clrScheme = this.styles[\"clrScheme\"] as Element[];\n        let sheetView = this.readXml.getElementsByTagName(\"sheetViews/sheetView\", this.sheetFile);\n        let showGridLines = \"1\", tabSelected=\"0\", zoomScale = \"100\", activeCell = \"A1\";\n        if(sheetView.length>0){\n            let attrList = sheetView[0].attributeList;\n            showGridLines = getXmlAttibute(attrList, \"showGridLines\", \"1\");\n            tabSelected = getXmlAttibute(attrList, \"tabSelected\", \"0\");\n            zoomScale = getXmlAttibute(attrList, \"zoomScale\", \"100\");\n            // let colorId = getXmlAttibute(attrList, \"colorId\", \"0\");\n            let selections = sheetView[0].getInnerElements(\"selection\");\n            if(selections!=null && selections.length>0){\n                activeCell = getXmlAttibute(selections[0].attributeList, \"activeCell\", \"A1\");\n                let range:IluckySheetSelection = getcellrange(activeCell, this.sheetList, sheetId);\n                this.luckysheet_select_save = [];\n                this.luckysheet_select_save.push(range);\n            }\n        }\n        this.showGridLines = showGridLines;\n        this.status = tabSelected;\n        this.zoomRatio = parseInt(zoomScale)/100;\n\n        let tabColors = this.readXml.getElementsByTagName(\"sheetPr/tabColor\", this.sheetFile);\n        if(tabColors!=null && tabColors.length>0){\n            let tabColor = tabColors[0], attrList = tabColor.attributeList;\n            // if(attrList.rgb!=null){\n                let tc = getColor(tabColor, this.styles, \"b\");\n                this.color = tc;\n            // }\n        }\n\n        let sheetFormatPr = this.readXml.getElementsByTagName(\"sheetFormatPr\", this.sheetFile);\n        let defaultColWidth, defaultRowHeight;\n        if(sheetFormatPr.length>0){\n            let attrList = sheetFormatPr[0].attributeList;\n            defaultColWidth = getXmlAttibute(attrList, \"defaultColWidth\", \"9.21\");\n            defaultRowHeight = getXmlAttibute(attrList, \"defaultRowHeight\", \"19\");\n        }\n\n        this.defaultColWidth = getColumnWidthPixel(parseFloat(defaultColWidth));\n        this.defaultRowHeight = getRowHeightPixel(parseFloat(defaultRowHeight));\n\n\n        this.generateConfigColumnLenAndHidden();\n        this.generateConfigRowLenAndHiddenAddCell();\n\n        if(this.formulaRefList!=null){\n            for(let key in this.formulaRefList){\n                let funclist = this.formulaRefList[key];\n                let mainFunc = funclist[\"mainRef\"], mainCellValue = mainFunc.cellValue;\n                let formulaTxt = mainFunc.fv;\n                let mainR = mainCellValue.r, mainC = mainCellValue.c;\n                // let refRange = getcellrange(ref);\n                for(let name in funclist){\n                    if(name == \"mainRef\"){\n                        continue;\n                    }\n\n                    let funcValue = funclist[name], cellValue = funcValue.cellValue;\n                    if(cellValue==null){\n                        continue;\n                    }\n                    let r = cellValue.r, c = cellValue.c;\n\n                    let func = formulaTxt;\n                    let offsetRow = r - mainR, offsetCol = c - mainC;\n\n                    \n                    if(offsetRow > 0){\n                        func = \"=\" + fromulaRef.functionCopy(func, \"down\", offsetRow);\n                    }\n                    else if(offsetRow < 0){\n                        func = \"=\" + fromulaRef.functionCopy(func, \"up\", Math.abs(offsetRow));\n                    }\n\n                    if(offsetCol > 0){\n                        func = \"=\" + fromulaRef.functionCopy(func, \"right\", offsetCol);\n                    }\n                    else if(offsetCol < 0){\n                        func = \"=\" + fromulaRef.functionCopy(func, \"left\", Math.abs(offsetCol));\n                    }\n\n                    // console.log(offsetRow, offsetCol, func);\n\n                    (cellValue.v as IluckySheetCelldataValue ).f = func;\n                    \n                }\n            }\n        }\n\n\n        if(this.calcChain==null){\n            this.calcChain = [];\n        }\n        for(let c=0;c<this.calcChainEles.length;c++){\n            let calcChainEle = this.calcChainEles[c], attrList = calcChainEle.attributeList;\n            if(attrList.i!=sheetId){\n                continue;\n            }\n\n            let r = attrList.r , i = attrList.i, l = attrList.l, s = attrList.s, a = attrList.a, t = attrList.t;\n\n            let range = getcellrange(r);\n            let chain = new LuckysheetCalcChain();\n            chain.r = range.row[0];\n            chain.c = range.column[0];\n            chain.index = this.index;\n            this.calcChain.push(chain);\n        }\n\n        if(this.mergeCells!=null){\n            for(let i=0;i<this.mergeCells.length;i++){\n                let merge = this.mergeCells[i], attrList = merge.attributeList;\n                let ref = attrList.ref;\n                if(ref==null){\n                    continue;\n                }\n                let range = getcellrange(ref, this.sheetList, sheetId);\n                let mergeValue = new LuckySheetConfigMerge();\n                mergeValue.r = range.row[0];\n                mergeValue.c = range.column[0];\n                mergeValue.rs = range.row[1]-range.row[0]+1;\n                mergeValue.cs = range.column[1]-range.column[0]+1;\n                if(this.config.merge==null){\n                    this.config.merge = {};\n                }\n                this.config.merge[range.row[0] + \"_\" + range.column[0]] = mergeValue;\n            }\n        }\n\n        let drawingFile = allFileOption.drawingFile, drawingRelsFile = allFileOption.drawingRelsFile;\n        if(drawingFile!=null && drawingRelsFile!=null){\n            let twoCellAnchors = this.readXml.getElementsByTagName(\"xdr:twoCellAnchor\", drawingFile);\n\n            if(twoCellAnchors!=null && twoCellAnchors.length>0){\n                for(let i=0;i<twoCellAnchors.length;i++){\n                    let twoCellAnchor = twoCellAnchors[i];\n                    let editAs = getXmlAttibute(twoCellAnchor.attributeList, \"editAs\", \"twoCell\");\n\n                    let xdrFroms = twoCellAnchor.getInnerElements(\"xdr:from\"), xdrTos = twoCellAnchor.getInnerElements(\"xdr:to\");\n\n                    let xdr_blipfills = twoCellAnchor.getInnerElements(\"a:blip\");\n                    if(xdrFroms!=null && xdr_blipfills!=null && xdrFroms.length>0 && xdr_blipfills.length>0){\n                        let xdrFrom = xdrFroms[0], xdrTo = xdrTos[0],xdr_blipfill = xdr_blipfills[0];\n                        \n                        let rembed = getXmlAttibute(xdr_blipfill.attributeList, \"r:embed\", null);\n\n                        let imageObject = this.getBase64ByRid(rembed, drawingRelsFile);\n\n\n\n                        // let aoff = xdr_xfrm.getInnerElements(\"a:off\"), aext = xdr_xfrm.getInnerElements(\"a:ext\");\n\n                        \n\n                        // if(aoff!=null && aext!=null && aoff.length>0 && aext.length>0){\n                        //     let aoffAttribute = aoff[0].attributeList, aextAttribute = aext[0].attributeList;\n                        //     let x = getXmlAttibute(aoffAttribute, \"x\", null);\n                        //     let y = getXmlAttibute(aoffAttribute, \"y\", null);\n\n                        //     let cx = getXmlAttibute(aextAttribute, \"cx\", null);\n                        //     let cy = getXmlAttibute(aextAttribute, \"cy\", null);\n\n                        //     if(x!=null && y!=null && cx!=null && cy!=null && imageObject !=null){\n                        // let x_n = getPxByEMUs(parseInt(x), \"c\"),y_n = getPxByEMUs(parseInt(y));\n                        // let cx_n = getPxByEMUs(parseInt(cx), \"c\"),cy_n = getPxByEMUs(parseInt(cy));\n\n                        let x_n =0,y_n = 0;\n                        let cx_n = 0, cy_n = 0;\n\n                        imageObject.fromCol = this.getXdrValue(xdrFrom.getInnerElements(\"xdr:col\"));\n                        imageObject.fromColOff = getPxByEMUs(this.getXdrValue(xdrFrom.getInnerElements(\"xdr:colOff\")));\n                        imageObject.fromRow= this.getXdrValue(xdrFrom.getInnerElements(\"xdr:row\"));\n                        imageObject.fromRowOff = getPxByEMUs(this.getXdrValue(xdrFrom.getInnerElements(\"xdr:rowOff\")));\n\n                        imageObject.toCol = this.getXdrValue(xdrTo.getInnerElements(\"xdr:col\"));\n                        imageObject.toColOff = getPxByEMUs(this.getXdrValue(xdrTo.getInnerElements(\"xdr:colOff\")));\n                        imageObject.toRow = this.getXdrValue(xdrTo.getInnerElements(\"xdr:row\"));\n                        imageObject.toRowOff = getPxByEMUs(this.getXdrValue(xdrTo.getInnerElements(\"xdr:rowOff\")));\n\n                        imageObject.originWidth = cx_n;\n                        imageObject.originHeight = cy_n;\n                        \n                        if(editAs==\"absolute\"){\n                            imageObject.type = \"3\";\n                        }\n                        else if(editAs==\"oneCell\"){\n                            imageObject.type = \"2\";\n                        }\n                        else{\n                            imageObject.type = \"1\";\n                        }\n\n                        imageObject.isFixedPos = false;\n                        imageObject.fixedLeft = 0;\n                        imageObject.fixedTop = 0;\n\n                        let imageBorder:IluckyImageBorder = {\n                            color: \"#000\",\n                            radius: 0,\n                            style: \"solid\",\n                            width: 0\n                        }\n                        imageObject.border = imageBorder;\n\n                        let imageCrop:IluckyImageCrop = {\n                            height: cy_n,\n                            offsetLeft: 0,\n                            offsetTop: 0,\n                            width: cx_n\n                        }\n                        imageObject.crop = imageCrop;\n\n                        let imageDefault:IluckyImageDefault = {\n                            height: cy_n,\n                            left: x_n,\n                            top: y_n,\n                            width: cx_n\n                        }\n                        imageObject.default = imageDefault;\n\n                        if(this.images==null){\n                            this.images = {};\n                        }\n                        this.images[generateRandomIndex(\"image\")] = imageObject;\n                        //     }\n                        // }\n                    }\n                }\n            }\n            \n        } \n    }\n\n    private getXdrValue(ele:Element[]):number{\n        if(ele==null || ele.length==0){\n            return null;\n        }\n\n        return parseInt(ele[0].value);\n    }\n\n    private getBase64ByRid(rid:string, drawingRelsFile:string){\n        let Relationships = this.readXml.getElementsByTagName(\"Relationships/Relationship\", drawingRelsFile);\n\n        if(Relationships!=null && Relationships.length>0){\n            for(let i=0;i<Relationships.length;i++){\n                let Relationship = Relationships[i];\n                let attrList = Relationship.attributeList;\n                let Id = getXmlAttibute(attrList, \"Id\", null);\n                let src = getXmlAttibute(attrList, \"Target\", null);\n                if(Id == rid){\n                    src = src.replace(/\\.\\.\\//g, \"\");\n                    src = \"xl/\" + src;\n                    let imgage = this.imageList.getImageByName(src);\n                    return imgage;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n    * @desc This will convert cols/col to luckysheet config of column'width\n    */\n    private generateConfigColumnLenAndHidden(){\n        let cols = this.readXml.getElementsByTagName(\"cols/col\", this.sheetFile);\n        for(let i=0;i<cols.length;i++){\n            let col = cols[i], attrList = col.attributeList;\n            let min = getXmlAttibute(attrList, \"min\", null);\n            let max = getXmlAttibute(attrList, \"max\", null);\n            let width = getXmlAttibute(attrList, \"width\", null);\n            let hidden = getXmlAttibute(attrList, \"hidden\", null);\n            let customWidth = getXmlAttibute(attrList, \"customWidth\", null);\n\n\n            if(min==null || max==null){\n                continue;\n            }\n\n            let minNum = parseInt(min)-1, maxNum=parseInt(max)-1, widthNum=parseFloat(width);\n            \n            for(let m=minNum;m<=maxNum;m++){\n                if(width!=null){\n                    if(this.config.columnlen==null){\n                        this.config.columnlen = {};\n                    }\n                    this.config.columnlen[m] = getColumnWidthPixel(widthNum);\n                }\n\n                if(hidden==\"1\"){\n                    if(this.config.colhidden==null){\n                        this.config.colhidden = {};\n                    }\n                    this.config.colhidden[m] = 0;\n\n                    if(this.config.columnlen){\n                        delete this.config.columnlen[m];\n                    }\n                    \n                }\n\n                if(customWidth!=null){\n                    if(this.config.customWidth==null){\n                        this.config.customWidth = {};\n                    }\n                    this.config.customWidth[m] = 1;\n                }\n            } \n        }\n    }\n\n    /**\n    * @desc This will convert cols/col to luckysheet config of column'width\n    */\n   private generateConfigRowLenAndHiddenAddCell(){\n        let rows = this.readXml.getElementsByTagName(\"sheetData/row\", this.sheetFile);\n        for(let i=0;i<rows.length;i++){\n            let row = rows[i], attrList = row.attributeList;\n            let rowNo = getXmlAttibute(attrList, \"r\", null);\n            let height = getXmlAttibute(attrList, \"ht\", null);\n            let hidden = getXmlAttibute(attrList, \"hidden\", null);\n            let customHeight = getXmlAttibute(attrList, \"customHeight\", null);\n\n            if(rowNo==null){\n                continue;\n            }\n\n            let rowNoNum = parseInt(rowNo) - 1;\n            if(height!=null){\n                let heightNum = parseFloat(height);\n                if(this.config.rowlen==null){\n                    this.config.rowlen = {};\n                }\n                this.config.rowlen[rowNoNum] = getRowHeightPixel(heightNum);\n            }\n\n            if(hidden==\"1\"){\n                if(this.config.rowhidden==null){\n                    this.config.rowhidden = {};\n                }\n                this.config.rowhidden[rowNoNum] = 0;\n                \n                if(this.config.rowlen){\n                    delete this.config.rowlen[rowNoNum];\n                }\n                \n            }\n\n            if(customHeight!=null){\n                if(this.config.customHeight==null){\n                    this.config.customHeight = {};\n                }\n                this.config.customHeight[rowNoNum] = 1;\n            }\n\n\n            if(this.isInitialCell){\n                let cells = row.getInnerElements(\"c\");\n                for(let key in cells){\n                    let cell = cells[key];\n                    let cellValue = new LuckySheetCelldata(cell, this.styles, this.sharedStrings, this.mergeCells,this.sheetFile, this.readXml);\n                    if(cellValue._borderObject!=null){\n                        if(this.config.borderInfo==null){\n                            this.config.borderInfo = [];\n                        }\n                        this.config.borderInfo.push(cellValue._borderObject);\n                        delete cellValue._borderObject;\n                    }\n                    \n                    // let borderId = cellValue._borderId;\n                    // if(borderId!=null){\n                    //     let borders = this.styles[\"borders\"] as Element[];\n                    //     if(this.config._borderInfo==null){\n                    //         this.config._borderInfo = {};\n                    //     }\n                    //     if( borderId in this.config._borderInfo){\n                    //         this.config._borderInfo[borderId].cells.push(cellValue.r + \"_\" + cellValue.c);\n                    //     }\n                    //     else{\n                    //         let border = borders[borderId];\n                    //         let borderObject = new LuckySheetborderInfoCellForImp();\n                    //         borderObject.rangeType = \"cellGroup\";\n                    //         borderObject.cells = [];\n                    //         let borderCellValue = new LuckySheetborderInfoCellValue();\n                            \n                    //         let lefts = border.getInnerElements(\"left\");\n                    //         let rights = border.getInnerElements(\"right\");\n                    //         let tops = border.getInnerElements(\"top\");\n                    //         let bottoms = border.getInnerElements(\"bottom\");\n                    //         let diagonals = border.getInnerElements(\"diagonal\");\n\n                    //         let left = this.getBorderInfo(lefts);\n                    //         let right = this.getBorderInfo(rights);\n                    //         let top = this.getBorderInfo(tops);\n                    //         let bottom = this.getBorderInfo(bottoms);\n                    //         let diagonal = this.getBorderInfo(diagonals);\n\n                    //         let isAdd = false;\n                    //         if(left!=null && left.color!=null){\n                    //             borderCellValue.l = left;\n                    //             isAdd = true;\n                    //         }\n\n                    //         if(right!=null && right.color!=null){\n                    //             borderCellValue.r = right;\n                    //             isAdd = true;\n                    //         }\n\n                    //         if(top!=null && top.color!=null){\n                    //             borderCellValue.t = top;\n                    //             isAdd = true;\n                    //         }\n\n                    //         if(bottom!=null && bottom.color!=null){\n                    //             borderCellValue.b = bottom;\n                    //             isAdd = true;\n                    //         }\n\n                    //         if(isAdd){\n                    //             borderObject.value = borderCellValue;\n                    //             this.config._borderInfo[borderId] = borderObject;\n                    //         }\n\n                    //     }\n                    // }\n                    if(cellValue._formulaType==\"shared\"){\n                        if(this.formulaRefList==null){\n                            this.formulaRefList = {};\n                        }\n\n                        if(this.formulaRefList[cellValue._formulaSi]==null){\n                            this.formulaRefList[cellValue._formulaSi] = {}\n                        }\n\n                        let fv;\n                        if(cellValue.v!=null){\n                            fv = (cellValue.v as IluckySheetCelldataValue).f;\n                        }\n\n                        let refValue = {\n                            t:cellValue._formulaType,\n                            ref:cellValue._fomulaRef,\n                            si:cellValue._formulaSi,\n                            fv:fv,\n                            cellValue:cellValue\n                        }\n\n                        if(cellValue._fomulaRef!=null){\n                            this.formulaRefList[cellValue._formulaSi][\"mainRef\"] = refValue;\n                        }\n                        else{\n                            this.formulaRefList[cellValue._formulaSi][cellValue.r+\"_\"+cellValue.c] = refValue;\n                        }\n\n                        // console.log(refValue, this.formulaRefList);\n                    }\n\n                    this.celldata.push(cellValue);\n                }\n                \n            }\n        }\n    }\n\n    // private getBorderInfo(borders:Element[]):LuckySheetborderInfoCellValueStyle{\n    //     if(borders==null){\n    //         return null;\n    //     }\n\n    //     let border = borders[0], attrList = border.attributeList;\n    //     let clrScheme = this.styles[\"clrScheme\"] as Element[];\n    //     let style:string = attrList.style;\n    //     if(style==null || style==\"none\"){\n    //         return null;\n    //     }\n\n    //     let colors = border.getInnerElements(\"color\");\n    //     let colorRet = \"#000000\";\n    //     if(colors!=null){\n    //         let color = colors[0];\n    //         colorRet = getColor(color, clrScheme);\n    //     }\n\n    //     let ret = new LuckySheetborderInfoCellValueStyle();\n    //     ret.style = borderTypes[style];\n    //     ret.color = colorRet;\n\n    //     return ret;\n    // }\n}\n","import {IuploadfileList, IattributeList, stringToNum} from \"../ICommon\";\nimport {indexedColors}  from \"../common/constant\";\nimport {LightenDarkenColor}  from \"../common/method\";\n\n\nclass xmloperation {\n    /**\n    * @param tag Search xml tag name , div,title etc.\n    * @param file Xml string\n    * @return Xml element string \n    */\n    protected getElementsByOneTag(tag:string, file:string):string[]{\n        //<a:[^/>: ]+?>.*?</a:[^/>: ]+?>\n        let readTagReg;\n        if(tag.indexOf(\"|\")>-1){\n            let tags = tag.split(\"|\"), tagsRegTxt=\"\";\n            for(let i=0;i<tags.length;i++){\n                let t = tags[i];\n                tagsRegTxt += \"|<\"+ t +\" [^>]+?[^/]>[\\\\s\\\\S]*?</\"+ t +\">|<\"+ t +\" [^>]+?/>|<\"+ t +\">[\\\\s\\\\S]*?</\"+ t +\">|<\"+ t +\"/>\";\n            }\n            tagsRegTxt = tagsRegTxt.substr(1, tagsRegTxt.length);\n            readTagReg = new RegExp(tagsRegTxt, \"g\");\n        }\n        else{\n            readTagReg = new RegExp(\"<\"+ tag +\" [^>]+?[^/]>[\\\\s\\\\S]*?</\"+ tag +\">|<\"+ tag +\" [^>]+?/>|<\"+ tag +\">[\\\\s\\\\S]*?</\"+ tag +\">|<\"+ tag +\"/>\", \"g\");\n        }\n        \n        let ret = file.match(readTagReg);\n        if(ret==null){\n            return [];\n        }\n        else{\n            return ret;\n        }\n    }\n}\n\nexport class ReadXml extends xmloperation{\n    originFile:IuploadfileList\n    constructor(files:IuploadfileList){\n        super();\n        this.originFile = files;\n    }\n    /**\n    * @param path Search xml tag group , div,title etc.\n    * @param fileName One of uploadfileList, uploadfileList is file group, {key:value}\n    * @return Xml element calss\n    */\n    getElementsByTagName(path:string, fileName:string): Element[]{\n        \n        let file = this.getFileByName(fileName);\n        let pathArr = path.split(\"/\"), ret:string[] | string;\n        for(let key in pathArr){\n            let path = pathArr[key];\n            if(ret==undefined){\n                ret = this.getElementsByOneTag(path,file);\n            }\n            else{\n                if(ret instanceof Array){\n                    let items:string[]=[];\n                    for(let key in ret){\n                        let item = ret[key];\n                        items = items.concat(this.getElementsByOneTag(path,item));\n                    }\n                    ret = items;\n                }\n                else{\n                    ret = this.getElementsByOneTag(path,ret);\n                }\n            }\n        }\n\n        let elements:Element[] = [];\n\n        for(let i=0;i<ret.length;i++){\n            let ele = new Element(ret[i]);\n            elements.push(ele);\n        }\n\n        return elements;\n    }\n\n    /**\n    * @param name One of uploadfileList's name, search for file by this parameter\n    * @retrun Select a file from uploadfileList\n    */\n    private getFileByName(name:string):string{\n        for(let fileKey in this.originFile){\n            if(fileKey.indexOf(name)>-1){\n                return this.originFile[fileKey];\n            }\n        }\n        return \"\";\n    }\n\n    \n}\n\nexport class Element extends xmloperation {\n    elementString:string\n    attributeList:IattributeList\n    value:string\n    container:string\n    constructor(str:string){\n        super();\n        this.elementString = str;\n        this.setValue();\n        const readAttrReg = new RegExp('[a-zA-Z0-9_:]*?=\".*?\"', \"g\");\n        let attrList = this.container.match(readAttrReg);\n        this.attributeList = {};\n        if(attrList!=null){\n            for(let key in attrList){\n                let attrFull = attrList[key];\n                // let al= attrFull.split(\"=\");\n                if(attrFull.length==0){\n                    continue;\n                }\n                let attrKey = attrFull.substr(0, attrFull.indexOf('='));\n                let attrValue = attrFull.substr(attrFull.indexOf('=') + 1);\n                if(attrKey==null || attrValue==null ||attrKey.length==0 || attrValue.length==0){\n                    continue;\n                }\n                this.attributeList[attrKey] = attrValue.substr(1, attrValue.length-2);\n            }\n        }\n    }\n\n    /**\n    * @param name Get attribute by key in element\n    * @return Single attribute\n    */\n    get(name:string):string|number|boolean{\n        return this.attributeList[name];\n    }\n\n    /**\n    * @param tag Get elements by tag in elementString\n    * @return Element group\n    */\n    getInnerElements(tag:string):Element[]{\n        let ret = this.getElementsByOneTag(tag,this.elementString);\n        let elements:Element[] = [];\n\n        for(let i=0;i<ret.length;i++){\n            let ele = new Element(ret[i]);\n            elements.push(ele);\n        }\n\n        if(elements.length==0){\n            return null;\n        }\n        return elements;\n    }\n\n    /**\n    * @desc get xml dom value and container, <container>value</container>\n    */\n    private setValue(){\n        let str = this.elementString;\n        if(str.substr(str.length-2, 2)==\"/>\"){\n            this.value = \"\";\n            this.container = str;\n        }\n        else{\n            let firstTag = this.getFirstTag();\n            const firstTagReg = new RegExp(\"(<\"+ firstTag +\" [^>]+?[^/]>)([\\\\s\\\\S]*?)</\"+ firstTag +\">|(<\"+ firstTag +\">)([\\\\s\\\\S]*?)</\"+ firstTag +\">\", \"g\");\n            let result = firstTagReg.exec(str);\n            if (result != null) {\n                if(result[1]!=null){\n                    this.container = result[1];\n                    this.value = result[2];\n                }\n                else{\n                    this.container = result[3];\n                    this.value = result[4];\n                }\n            }\n        }\n    }\n\n    /**\n    * @desc get xml dom first tag, <a><b></b></a>, get a\n    */\n    private getFirstTag(){\n        let str = this.elementString;\n        let firstTag = str.substr(0, str.indexOf(' '));\n        if(firstTag==\"\" || firstTag.indexOf(\">\")>-1){\n            firstTag = str.substr(0, str.indexOf('>'));\n        }\n        firstTag = firstTag.substr(1,firstTag.length);\n        return firstTag;\n    }\n}\n\n\nexport interface IStyleCollections {\n    [index:string]:Element[] | IattributeList\n}\n\nfunction combineIndexedColor(indexedColorsInner:Element[], indexedColors:IattributeList):IattributeList{\n    let ret:IattributeList = {};\n    if(indexedColorsInner==null || indexedColorsInner.length==0){\n        return indexedColors;\n    }\n    for(let key in indexedColors){\n        let value = indexedColors[key], kn = parseInt(key);\n        let inner = indexedColorsInner[kn];\n        if(inner==null){\n            ret[key] = value;\n        }\n        else{\n            let rgb = inner.attributeList.rgb;\n            ret[key] = rgb;\n        }\n    }\n\n    return ret;\n}\n\n//clrScheme:Element[]\nexport function getColor(color:Element, styles:IStyleCollections , type:string=\"g\"){\n    let attrList = color.attributeList;\n    let clrScheme = styles[\"clrScheme\"] as Element[];\n    let indexedColorsInner = styles[\"indexedColors\"] as Element[];\n    let mruColorsInner = styles[\"mruColors\"];\n    let indexedColorsList = combineIndexedColor(indexedColorsInner, indexedColors);\n    let indexed = attrList.indexed, rgb = attrList.rgb, theme = attrList.theme, tint = attrList.tint;\n    let bg;\n    if(indexed!=null){\n        let indexedNum = parseInt(indexed);\n        bg = indexedColorsList[indexedNum];\n        if(bg!=null){\n            bg = bg.substring(bg.length-6, bg.length);\n            bg = \"#\"+bg;\n        }\n    }\n    else if(rgb!=null){\n        rgb = rgb.substring(rgb.length-6, rgb.length);\n        bg = \"#\"+rgb;\n    }\n    else if(theme!=null){\n        let themeNum = parseInt(theme);\n        if(themeNum==0){\n            themeNum = 1;\n        }\n        else if(themeNum==1){\n            themeNum = 0;\n        }\n        else if(themeNum==2){\n            themeNum = 3;\n        }\n        else if(themeNum==3){\n            themeNum = 2;\n        }\n        let clrSchemeElement = clrScheme[themeNum];\n        if(clrSchemeElement!=null){\n            let clrs = clrSchemeElement.getInnerElements(\"a:sysClr|a:srgbClr\");\n            if(clrs!=null){\n                let clr = clrs[0];\n                let clrAttrList = clr.attributeList;\n                // console.log(clr.container, );\n                if(clr.container.indexOf(\"sysClr\")>-1){\n                    // if(type==\"g\" && clrAttrList.val==\"windowText\"){\n                    //     bg = null;\n                    // }\n                    // else if((type==\"t\" || type==\"b\") && clrAttrList.val==\"window\"){\n                    //     bg = null;\n                    // }                    \n                    // else \n                    if(clrAttrList.lastClr!=null){\n                        bg = \"#\" + clrAttrList.lastClr;\n                    }\n                    else if(clrAttrList.val!=null){\n                        bg = \"#\" + clrAttrList.val;\n                    }\n\n                }\n                else if(clr.container.indexOf(\"srgbClr\")>-1){\n                    // console.log(clrAttrList.val);\n                    bg = \"#\" + clrAttrList.val;\n                }\n            }\n        }\n        \n    }\n    \n    if(tint!=null){\n        let tintNum = parseFloat(tint);\n        if(bg!=null){\n            bg = LightenDarkenColor(bg, tintNum);\n        }\n    }\n\n    return bg;\n}\n\n\n/** \n * @dom xml attribute object\n * @attr attribute name\n * @d if attribute is null, return default value \n * @return attribute value\n*/\nexport function getlineStringAttr(frpr:Element, attr:string):string{\n    let attrEle = frpr.getInnerElements(attr), value;\n\n    if(attrEle!=null && attrEle.length>0){\n        if(attr==\"b\" || attr==\"i\" || attr==\"strike\"){\n            value = \"1\";\n        }\n        else if(attr==\"u\"){\n            let v = attrEle[0].attributeList.val;\n            if(v==\"double\"){\n                value =  \"2\";\n            }\n            else if(v==\"singleAccounting\"){\n                value =  \"3\";\n            }\n            else if(v==\"doubleAccounting\"){\n                value =  \"4\";\n            }\n            else{\n                value = \"1\";\n            }\n        }\n        else if(attr==\"vertAlign\"){\n            let v = attrEle[0].attributeList.val;\n            if(v==\"subscript\"){\n                value = \"1\";\n            }\n            else if(v==\"superscript\"){\n                value = \"2\";\n            }\n        }\n        else{\n            value = attrEle[0].attributeList.val;\n        }\n        \n    }\n\n    return value;\n}","import {stringToNum, IattributeList, numTostring} from \"../ICommon\";\n\nexport const columeHeader_word:string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\nexport const columeHeader_word_index:stringToNum = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8, 'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16, 'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24, 'Z': 25 };\n\nexport const coreFile = \"docProps/core.xml\";\nexport const appFile = \"docProps/app.xml\";\nexport const contentTypesFile = \"[Content_Types].xml\";\nexport const workBookFile = \"xl/workbook.xml\";\nexport const calcChainFile = \"xl/calcChain.xml\";\nexport const stylesFile = \"xl/styles.xml\";\nexport const sharedStringsFile = \"xl/sharedStrings.xml\";\nexport const worksheetFilePath = \"xl/worksheets/\";\nexport const theme1File = \"xl/theme/theme1.xml\";\nexport const workbookRels= \"xl/_rels/workbook.xml.rels\";\n\n\n\n\n//Excel Built-In cell type\nexport const ST_CellType:IattributeList ={\n    \"Boolean\":\"b\",\n    \"Date\":\"d\",\n    \"Error\":\"e\",\n    \"InlineString\":\"inlineStr\",\n    \"Number\":\"n\",\n    \"SharedString\":\"s\",\n    \"String\":\"str\",\n}\n\n//Excel Built-In cell style\nexport const BuiltInCellStyles:IattributeList = {\n    \"0\":\"Normal\",\n\n}\n\n\nexport let numFmtDefault:IattributeList = {\n    \"0\":'General',\n    \"1\": '0',\n    \"2\": '0.00',\n    \"3\": '#,##0',\n    \"4\": '#,##0.00',\n    \"9\":'0%',\n    \"10\": '0.00%',\n    \"11\": '0.00E+00',\n    \"12\": '# ?/?',\n    \"13\": '# ??/??',\n    \"14\": 'm/d/yy',\n    \"15\": 'd-mmm-yy',\n    \"16\": 'd-mmm',\n    \"17\": 'mmm-yy',\n    \"18\": 'h:mm AM/PM',\n    \"19\": 'h:mm:ss AM/PM',\n    \"20\": 'h:mm',\n    \"21\": 'h:mm:ss',\n    \"22\": 'm/d/yy h:mm',\n    \"37\": '#,##0 ;(#,##0)',\n    \"38\": '#,##0 ;[Red](#,##0)',\n    \"39\": '#,##0.00;(#,##0.00)',\n    \"40\": '#,##0.00;[Red](#,##0.00)',\n    \"45\": 'mm:ss',\n    \"46\": '[h]:mm:ss',\n    \"47\": 'mmss.0',\n    \"48\": '##0.0E+0',\n    \"49\": '@'\n}\n\nexport const indexedColors:IattributeList = {\n    \"0\":'00000000',\n    \"1\":'00FFFFFF',\n    \"2\":'00FF0000',\n    \"3\":'0000FF00',\n    \"4\":'000000FF',\n    \"5\":'00FFFF00',\n    \"6\":'00FF00FF',\n    \"7\":'0000FFFF',\n    \"8\":'00000000',\n    \"9\":'00FFFFFF',\n    \"10\":'00FF0000',\n    \"11\":'0000FF00',\n    \"12\":'000000FF',\n    \"13\":'00FFFF00',\n    \"14\":'00FF00FF',\n    \"15\":'0000FFFF',\n    \"16\":'00800000',\n    \"17\":'00008000',\n    \"18\":'00000080',\n    \"19\":'00808000',\n    \"20\":'00800080',\n    \"21\":'00008080',\n    \"22\":'00C0C0C0',\n    \"23\":'00808080',\n    \"24\":'009999FF',\n    \"25\":'00993366',\n    \"26\":'00FFFFCC',\n    \"27\":'00CCFFFF',\n    \"28\":'00660066',\n    \"29\":'00FF8080',\n    \"30\":'000066CC',\n    \"31\":'00CCCCFF',\n    \"32\":'00000080',\n    \"33\":'00FF00FF',\n    \"34\":'00FFFF00',\n    \"35\":'0000FFFF',\n    \"36\":'00800080',\n    \"37\":'00800000',\n    \"38\":'00008080',\n    \"39\":'000000FF',\n    \"40\":'0000CCFF',\n    \"41\":'00CCFFFF',\n    \"42\":'00CCFFCC',\n    \"43\":'00FFFF99',\n    \"44\":'0099CCFF',\n    \"45\":'00FF99CC',\n    \"46\":'00CC99FF',\n    \"47\":'00FFCC99',\n    \"48\":'003366FF',\n    \"49\":'0033CCCC',\n    \"50\":'0099CC00',\n    \"51\":'00FFCC00',\n    \"52\":'00FF9900',\n    \"53\":'00FF6600',\n    \"54\":'00666699',\n    \"55\":'00969696',\n    \"56\":'00003366',\n    \"57\":'00339966',\n    \"58\":'00003300',\n    \"59\":'00333300',\n    \"60\":'00993300',\n    \"61\":'00993366',\n    \"62\":'00333399',\n    \"63\":'00333333',\n    \"64\":null,//system Foreground n/a\n    \"65\":null,//system Background n/a\n}\n\nexport const OEM_CHARSET:IattributeList = {\n    \"0\": \"ANSI_CHARSET\",\n    \"1\": \"DEFAULT_CHARSET\",\n    \"2\": \"SYMBOL_CHARSET\",\n    \"77\": \"MAC_CHARSET\",\n    \"128\": \"SHIFTJIS_CHARSET\",\n    \"129\": \"HANGUL_CHARSET\",\n    \"130\": \"JOHAB_CHARSET\",\n    \"134\": \"GB2312_CHARSET\",\n    \"136\": \"CHINESEBIG5_CHARSET\",\n    \"161\": \"GREEK_CHARSET\",\n    \"162\": \"TURKISH_CHARSET\",\n    \"163\": \"VIETNAMESE_CHARSET\",\n    \"177\": \"HEBREW_CHARSET\",\n    \"178\": \"ARABIC_CHARSET\",\n    \"186\": \"BALTIC_CHARSET\",\n    \"204\": \"RUSSIAN_CHARSET\",\n    \"222\": \"THAI_CHARSET\",\n    \"238\": \"EASTEUROPE_CHARSET\",\n    \"255\": \"OEM_CHARSET\",\n}\n\n\nexport const borderTypes:stringToNum = {\n    \"none\":0,\n    \"thin\":1, \n    \"hair\":2, \n    \"dotted\":3, \n    \"dashed\":4, \n    \"dashDot\":5, \n    \"dashDotDot\":6, \n    \"double\":7, \n    \"medium\":8, \n    \"mediumDashed\":9, \n    \"mediumDashDot\":10, \n    \"mediumDashDotDot\":11, \n    \"slantDashDot\":12, \n    \"thick\":13\n}\n\n\nexport const fontFamilys:IattributeList = {\n    \"0\":\"defualt\",\n    \"1\":\"Roman\",\n    \"2\":\"Swiss\",\n    \"3\":\"Modern\",\n    \"4\":\"Script\",\n    \"5\":\"Decorative\"\n}","export let UDOC:any = {};\n\t\n\tUDOC.G = {\n\t\tconcat : function(p:any,r:any) {\n\t\t\tfor(var i=0; i<r.cmds.length; i++) p.cmds.push(r.cmds[i]);\n\t\t\tfor(var i=0; i<r.crds.length; i++) p.crds.push(r.crds[i]);\n\t\t},\n\t\tgetBB  : function(ps:any) {\n\t\t\tvar x0=1e99, y0=1e99, x1=-x0, y1=-y0;\n\t\t\tfor(var i=0; i<ps.length; i+=2) {  var x=ps[i],y=ps[i+1];  if(x<x0)x0=x; else if(x>x1)x1=x;  if(y<y0)y0=y;  else if(y>y1)y1=y;  }\n\t\t\treturn [x0,y0,x1,y1];\n\t\t},\n\t\trectToPath: function(r:any) {  return  {cmds:[\"M\",\"L\",\"L\",\"L\",\"Z\"],crds:[r[0],r[1],r[2],r[1], r[2],r[3],r[0],r[3]]};  },\n\t\t// a inside b\n\t\tinsideBox: function(a:any,b:any) {  return b[0]<=a[0] && b[1]<=a[1] && a[2]<=b[2] && a[3]<=b[3];   },\n\t\tisBox : function(p:any, bb:any) {\n\t\t\tvar sameCrd8 = function(pcrd:any, crds:any) {\n\t\t\t\tfor(var o=0; o<8; o+=2) {  var eq = true;  for(var j=0; j<8; j++) if(Math.abs(crds[j]-pcrd[(j+o)&7])>=2) {  eq = false;  break;  }    if(eq) return true;  }\n\t\t\t\treturn false;\n\t\t\t};\n\t\t\tif(p.cmds.length>10) return false;\n\t\t\tvar cmds=p.cmds.join(\"\"), crds=p.crds;\n\t\t\tvar sameRect = false;\n\t\t\tif((cmds==\"MLLLZ\"  && crds.length== 8) \n\t\t\t ||(cmds==\"MLLLLZ\" && crds.length==10) ) {\n\t\t\t\tif(crds.length==10) crds=crds.slice(0,8);\n\t\t\t\tvar x0=bb[0],y0=bb[1],x1=bb[2],y1=bb[3];\n\t\t\t\tif(!sameRect) sameRect = sameCrd8(crds, [x0,y0,x1,y0,x1,y1,x0,y1]);\n\t\t\t\tif(!sameRect) sameRect = sameCrd8(crds, [x0,y1,x1,y1,x1,y0,x0,y0]);\n\t\t\t}\n\t\t\treturn sameRect;\n\t\t},\n\t\tboxArea: function(a:any) {  var w=a[2]-a[0], h=a[3]-a[1];  return w*h;  },\n\t\tnewPath: function(gst:any    ) {  gst.pth = {cmds:[], crds:[]};  },\n\t\tmoveTo : function(gst:any,x:any,y:any) {  var p=UDOC.M.multPoint(gst.ctm,[x,y]);  //if(gst.cpos[0]==p[0] && gst.cpos[1]==p[1]) return;\n\t\t\t\t\t\t\t\t\t\tgst.pth.cmds.push(\"M\");  gst.pth.crds.push(p[0],p[1]);  gst.cpos = p;  },\n\t\tlineTo : function(gst:any,x:any,y:any) {  var p=UDOC.M.multPoint(gst.ctm,[x,y]);  if(gst.cpos[0]==p[0] && gst.cpos[1]==p[1]) return;\n\t\t\t\t\t\t\t\t\t\tgst.pth.cmds.push(\"L\");  gst.pth.crds.push(p[0],p[1]);  gst.cpos = p;  },\n\t\tcurveTo: function(gst:any,x1:any,y1:any,x2:any,y2:any,x3:any,y3:any) {   var p;  \n\t\t\tp=UDOC.M.multPoint(gst.ctm,[x1,y1]);  x1=p[0];  y1=p[1];\n\t\t\tp=UDOC.M.multPoint(gst.ctm,[x2,y2]);  x2=p[0];  y2=p[1];\n\t\t\tp=UDOC.M.multPoint(gst.ctm,[x3,y3]);  x3=p[0];  y3=p[1];  gst.cpos = p;\n\t\t\tgst.pth.cmds.push(\"C\");  \n\t\t\tgst.pth.crds.push(x1,y1,x2,y2,x3,y3);  \n\t\t},\n\t\tclosePath: function(gst:any  ) {  gst.pth.cmds.push(\"Z\");  },\n\t\tarc : function(gst:any,x:any,y:any,r:any,a0:any,a1:any, neg:any) {\n\t\t\t\n\t\t\t// circle from a0 counter-clock-wise to a1\n\t\t\tif(neg) while(a1>a0) a1-=2*Math.PI;\n\t\t\telse    while(a1<a0) a1+=2*Math.PI;\n\t\t\tvar th = (a1-a0)/4;\n\t\t\t\n\t\t\tvar x0 = Math.cos(th/2), y0 = -Math.sin(th/2);\n\t\t\tvar x1 = (4-x0)/3, y1 = y0==0 ? y0 : (1-x0)*(3-x0)/(3*y0);\n\t\t\tvar x2 = x1, y2 = -y1;\n\t\t\tvar x3 = x0, y3 = -y0;\n\t\t\t\n\t\t\tvar p0 = [x0,y0], p1 = [x1,y1], p2 = [x2,y2], p3 = [x3,y3];\n\t\t\t\n\t\t\tvar pth = {cmds:[(gst.pth.cmds.length==0)?\"M\":\"L\",\"C\",\"C\",\"C\",\"C\"], crds:[x0,y0,x1,y1,x2,y2,x3,y3]};\n\t\t\t\n\t\t\tvar rot = [1,0,0,1,0,0];  UDOC.M.rotate(rot,-th);\n\t\t\t\n\t\t\tfor(var i=0; i<3; i++) {\n\t\t\t\tp1 = UDOC.M.multPoint(rot,p1);  p2 = UDOC.M.multPoint(rot,p2);  p3 = UDOC.M.multPoint(rot,p3);\n\t\t\t\tpth.crds.push(p1[0],p1[1],p2[0],p2[1],p3[0],p3[1]);\n\t\t\t}\n\t\t\t\n\t\t\tvar sc = [r,0,0,r,x,y];  \n\t\t\tUDOC.M.rotate(rot, -a0+th/2);  UDOC.M.concat(rot, sc);  UDOC.M.multArray(rot, pth.crds);\n\t\t\tUDOC.M.multArray(gst.ctm, pth.crds);\n\t\t\t\n\t\t\tUDOC.G.concat(gst.pth, pth);\n\t\t\tvar y:any=pth.crds.pop();  x=pth.crds.pop();\n\t\t\tgst.cpos = [x,y];\n\t\t},\n\t\ttoPoly : function(p:any) {\n\t\t\tif(p.cmds[0]!=\"M\" || p.cmds[p.cmds.length-1]!=\"Z\") return null;\n\t\t\tfor(var i=1; i<p.cmds.length-1; i++) if(p.cmds[i]!=\"L\") return null;\n\t\t\tvar out = [], cl = p.crds.length;\n\t\t\tif(p.crds[0]==p.crds[cl-2] && p.crds[1]==p.crds[cl-1]) cl-=2;\n\t\t\tfor(var i=0; i<cl; i+=2) out.push([p.crds[i],p.crds[i+1]]);\n\t\t\tif(UDOC.G.polyArea(p.crds)<0) out.reverse();\n\t\t\treturn out;\n\t\t},\n\t\tfromPoly : function(p:any) {\n\t\t\tvar o:any = {cmds:[],crds:[]};\n\t\t\tfor(var i=0; i<p.length; i++) { o.crds.push(p[i][0], p[i][1]);  o.cmds.push(i==0?\"M\":\"L\");  }\n\t\t\to.cmds.push(\"Z\");\n\t\t\treturn o;\n\t\t},\n\t\tpolyArea : function(p:any) {\n\t\t\tif(p.length <6) return 0;\n\t\t\tvar l = p.length - 2;\n\t\t\tvar sum = (p[0]-p[l]) * (p[l+1]+p[1]);\n\t\t\tfor(var i=0; i<l; i+=2)\n\t\t\t\tsum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);\n\t\t\treturn - sum * 0.5;\n\t\t},\n\t\tpolyClip : function(p0:any, p1:any) {  // p0 clipped by p1\n            var cp1:any, cp2:any, s:any, e:any;\n            var inside = function (p:any) {\n                return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);\n            };\n            var isc = function () {\n                var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],\n                    dp = [ s[0] - e[0], s[1] - e[1] ],\n                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\n                    n2 = s[0] * e[1] - s[1] * e[0], \n                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\n                return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];\n            };\n            var out = p0;\n            cp1 = p1[p1.length-1];\n            for (let j in p1) {\n                var cp2 = p1[j];\n                var inp = out;\n                out = [];\n                s = inp[inp.length - 1]; //last on the input list\n                for (let i in inp) {\n                    var e = inp[i];\n                    if (inside(e)) {\n                        if (!inside(s)) {\n                            out.push(isc());\n                        }\n                        out.push(e);\n                    }\n                    else if (inside(s)) {\n                        out.push(isc());\n                    }\n                    s = e;\n                }\n                cp1 = cp2;\n            }\n            return out\n        }\n\t}\n\tUDOC.M = {\n\t\tgetScale : function(m:any) {  return Math.sqrt(Math.abs(m[0]*m[3]-m[1]*m[2]));  },\n\t\ttranslate: function(m:any,x:any,y:any) {  UDOC.M.concat(m, [1,0,0,1,x,y]);  },\n\t\trotate   : function(m:any,a:any  ) {  UDOC.M.concat(m, [Math.cos(a), -Math.sin(a), Math.sin(a), Math.cos(a),0,0]);  },\n\t\tscale    : function(m:any,x:any,y:any) {  UDOC.M.concat(m, [x,0,0,y,0,0]);  },\n\t\tconcat   : function(m:any,w:any  ) {  \n\t\t\tvar a=m[0],b=m[1],c=m[2],d=m[3],tx=m[4],ty=m[5];\n\t\t\tm[0] = (a *w[0])+(b *w[2]);       m[1] = (a *w[1])+(b *w[3]);\n\t\t\tm[2] = (c *w[0])+(d *w[2]);       m[3] = (c *w[1])+(d *w[3]);\n\t\t\tm[4] = (tx*w[0])+(ty*w[2])+w[4];  m[5] = (tx*w[1])+(ty*w[3])+w[5]; \n\t\t},\n\t\tinvert   : function(m:any    ) {  \n\t\t\tvar a=m[0],b=m[1],c=m[2],d=m[3],tx=m[4],ty=m[5], adbc=a*d-b*c;\n\t\t\tm[0] = d/adbc;  m[1] = -b/adbc;  m[2] =-c/adbc;  m[3] =  a/adbc;\n\t\t\tm[4] = (c*ty - d*tx)/adbc;  m[5] = (b*tx - a*ty)/adbc;\n\t\t},\n\t\tmultPoint: function(m:any, p:any ) {  var x=p[0],y=p[1];  return [x*m[0]+y*m[2]+m[4],   x*m[1]+y*m[3]+m[5]];  },\n\t\tmultArray: function(m:any, a:any ) {  for(var i=0; i<a.length; i+=2) {  var x=a[i],y=a[i+1];  a[i]=x*m[0]+y*m[2]+m[4];  a[i+1]=x*m[1]+y*m[3]+m[5];  }  }\n\t}\n\tUDOC.C = {\n\t\tsrgbGamma : function(x:any) {  return x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1.0 / 2.4) - 0.055;  },\n\t\tcmykToRgb : function(clr:any) { \n\t\t\tvar c=clr[0], m=clr[1], y=clr[2], k=clr[3];\n\t\t\t// return [1-Math.min(1,c+k), 1-Math.min(1, m+k), 1-Math.min(1,y+k)];\n\t\t\tvar r = 255\n\t\t\t+ c * (-4.387332384609988  * c + 54.48615194189176  * m +  18.82290502165302  * y + 212.25662451639585 * k +  -285.2331026137004) \n\t\t\t+ m * ( 1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) \n\t\t\t+ y * (-2.5217340131683033 * y - 21.248923337353073 * k +  17.5119270841813) \n\t\t\t+ k * (-21.86122147463605  * k - 189.48180835922747);\n\t\t\tvar g = 255\n\t\t\t+ c * (8.841041422036149   * c + 60.118027045597366 * m +  6.871425592049007  * y + 31.159100130055922 * k +  -79.2970844816548) \n\t\t\t+ m * (-15.310361306967817 * m + 17.575251261109482 * y +  131.35250912493976 * k - 190.9453302588951) \n\t\t\t+ y * (4.444339102852739   * y + 9.8632861493405    * k -  24.86741582555878) \n\t\t\t+ k * (-20.737325471181034 * k - 187.80453709719578);\n\t\t\tvar b = 255\n\t\t\t+ c * (0.8842522430003296  * c + 8.078677503112928  * m +  30.89978309703729  * y - 0.23883238689178934 * k + -14.183576799673286) \n\t\t\t+ m * (10.49593273432072   * m + 63.02378494754052  * y +  50.606957656360734 * k - 112.23884253719248) \n\t\t\t+ y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505)\n\t\t\t+ k * (-22.33816807309886  * k - 180.12613974708367);\n\n\t\t\treturn [Math.max(0, Math.min(1, r/255)), Math.max(0, Math.min(1, g/255)), Math.max(0, Math.min(1, b/255))];\n\t\t\t//var iK = 1-c[3];  \n\t\t\t//return [(1-c[0])*iK, (1-c[1])*iK, (1-c[2])*iK];  \n\t\t},\n\t\tlabToRgb  : function(lab:any) {\n\t\t\tvar k = 903.3, e = 0.008856, L = lab[0], a = lab[1], b = lab[2];\n\t\t\tvar fy = (L+16)/116, fy3 = fy*fy*fy;\n\t\t\tvar fz = fy - b/200, fz3 = fz*fz*fz;\n\t\t\tvar fx = a/500 + fy, fx3 = fx*fx*fx;\n\t\t\tvar zr = fz3>e ? fz3 : (116*fz-16)/k;\n\t\t\tvar yr = fy3>e ? fy3 : (116*fy-16)/k;\n\t\t\tvar xr = fx3>e ? fx3 : (116*fx-16)/k;\n\t\t\t\t\n\t\t\tvar X = xr*96.72, Y = yr*100, Z = zr*81.427, xyz = [X/100,Y/100,Z/100];\n\t\t\tvar x2s = [3.1338561, -1.6168667, -0.4906146, -0.9787684,  1.9161415,  0.0334540, 0.0719453, -0.2289914,  1.4052427];\n\t\t\t\n\t\t\tvar rgb = [ x2s[0]*xyz[0] + x2s[1]*xyz[1] + x2s[2]*xyz[2],\n\t\t\t\t\t\tx2s[3]*xyz[0] + x2s[4]*xyz[1] + x2s[5]*xyz[2],\n\t\t\t\t\t\tx2s[6]*xyz[0] + x2s[7]*xyz[1] + x2s[8]*xyz[2]  ];\n\t\t\tfor(var i=0; i<3; i++) rgb[i] = Math.max(0, Math.min(1, UDOC.C.srgbGamma(rgb[i])));\n\t\t\treturn rgb;\n\t\t}\n\t}\n\t\n\tUDOC.getState = function(crds:any):any {\n\t\treturn {\n\t\t\tfont : UDOC.getFont(),\n\t\t\tdd: {flat:1},  // device-dependent\n\t\t\tspace :\"/DeviceGray\",\n\t\t\t// fill\n\t\t\tca: 1,\n\t\t\tcolr  : [0,0,0],\n\t\t\tsspace:\"/DeviceGray\",\n\t\t\t// stroke\n\t\t\tCA: 1,\n\t\t\tCOLR : [0,0,0],\n\t\t\tbmode: \"/Normal\",\n\t\t\tSA:false, OPM:0, AIS:false, OP:false, op:false, SMask:\"/None\",\n\t\t\tlwidth : 1,\n\t\t\tlcap: 0,\n\t\t\tljoin: 0,\n\t\t\tmlimit: 10,\n\t\t\tSM : 0.1,\n\t\t\tdoff: 0,\n\t\t\tdash: [],\n\t\t\tctm : [1,0,0,1,0,0],\n\t\t\tcpos: [0,0],\n\t\t\tpth : {cmds:[],crds:[]}, \n\t\t\tcpth: crds ? UDOC.G.rectToPath(crds) : null  // clipping path\n\t\t};\n\t}\n\t\n\tUDOC.getFont = function() {\n\t\treturn {\n\t\t\tTc: 0, // character spacing\n\t\t\tTw: 0, // word spacing\n\t\t\tTh:100, // horizontal scale\n\t\t\tTl: 0, // leading\n\t\t\tTf:\"Helvetica-Bold\", \n\t\t\tTfs:1, // font size\n\t\t\tTmode:0, // rendering mode\n\t\t\tTrise:0, // rise\n\t\t\tTk: 0,  // knockout\n\t\t\tTal:0,  // align, 0: left, 1: right, 2: center\n\t\t\tTun:0,  // 0: no, 1: underline\n\t\t\t\n\t\t\tTm :[1,0,0,1,0,0],\n\t\t\tTlm:[1,0,0,1,0,0],\n\t\t\tTrm:[1,0,0,1,0,0]\n\t\t};\n\t}\n\n\nexport let FromEMF:any = function()\n{\n}\n\nFromEMF.Parse = function(buff:any, genv:any)\n{\n    buff = new Uint8Array(buff);  var off=0;\n    //console.log(buff.slice(0,32));\n    var prms:any = {fill:false, strk:false, bb:[0,0,1,1], wbb:[0,0,1,1], fnt:{nam:\"Arial\",hgh:25,und:false,orn:0}, tclr:[0,0,0], talg:0}, gst, tab = [], sts=[];\n    \n    var rI = FromEMF.B.readShort, rU = FromEMF.B.readUshort, rI32 = FromEMF.B.readInt, rU32 = FromEMF.B.readUint, rF32 = FromEMF.B.readFloat;\t\n    \n    var opn=0;\n    while(true) {\n        var fnc = rU32(buff, off);  off+=4;\n        var fnm = FromEMF.K[fnc]; \n        var siz = rU32(buff, off);  off+=4;\n        \n        //if(gst && isNaN(gst.ctm[0])) throw \"e\";\n        //console.log(fnc,fnm,siz);\n        \n        var loff = off;\n        \n        //if(opn++==253) break;\n        var obj:any = null, oid = 0;\n        //console.log(fnm, siz);\n        \n        if(false) {}\n        else if(fnm==\"EOF\") {  break;  }\n        else if(fnm==\"HEADER\") {\n            prms.bb = FromEMF._readBox(buff,loff);   loff+=16;  //console.log(fnm, prms.bb);\n            genv.StartPage(prms.bb[0],prms.bb[1],prms.bb[2],prms.bb[3]);\n            gst = UDOC.getState(prms.bb);\t\n        }\n        else if(fnm==\"SAVEDC\") sts.push(JSON.stringify(gst), JSON.stringify(prms));\n        else if(fnm==\"RESTOREDC\") {\n            var dif = rI32(buff, loff);  loff+=4;\n            while(dif<-1) {  sts.pop();  sts.pop();  }\n            prms = JSON.parse(sts.pop());  gst = JSON.parse(sts.pop());\n        }\n        else if(fnm==\"SELECTCLIPPATH\") {  gst.cpth = JSON.parse(JSON.stringify(gst.pth));  }\n        else if([\"SETMAPMODE\",\"SETPOLYFILLMODE\",\"SETBKMODE\"/*,\"SETVIEWPORTEXTEX\"*/,\"SETICMMODE\",\"SETROP2\",\"EXTSELECTCLIPRGN\"].indexOf(fnm)!=-1) {}\n        //else if(fnm==\"INTERSECTCLIPRECT\") {  var r=prms.crct=FromEMF._readBox(buff, loff);  /*var y0=r[1],y1=r[3]; if(y0>y1){r[1]=y1; r[3]=y0;}*/ console.log(prms.crct);  }\n        else if(fnm==\"SETMITERLIMIT\") gst.mlimit = rU32(buff, loff);\n        else if(fnm==\"SETTEXTCOLOR\") prms.tclr = [buff[loff]/255, buff[loff+1]/255, buff[loff+2]/255]; \n        else if(fnm==\"SETTEXTALIGN\") prms.talg = rU32(buff, loff);\n        else if(fnm==\"SETVIEWPORTEXTEX\" || fnm==\"SETVIEWPORTORGEX\") {\n            if(prms.vbb==null) prms.vbb=[];\n            var coff = fnm==\"SETVIEWPORTORGEX\" ? 0 : 2;\n            prms.vbb[coff  ] = rI32(buff, loff);  loff+=4;\n            prms.vbb[coff+1] = rI32(buff, loff);  loff+=4;\n            //console.log(prms.vbb);\n            if(fnm==\"SETVIEWPORTEXTEX\") FromEMF._updateCtm(prms, gst);\n        }\n        else if(fnm==\"SETWINDOWEXTEX\" || fnm==\"SETWINDOWORGEX\") {\n            var coff = fnm==\"SETWINDOWORGEX\" ? 0 : 2;\n            prms.wbb[coff  ] = rI32(buff, loff);  loff+=4;\n            prms.wbb[coff+1] = rI32(buff, loff);  loff+=4;\n            if(fnm==\"SETWINDOWEXTEX\") FromEMF._updateCtm(prms, gst);\n        }\n        //else if(fnm==\"SETMETARGN\") {}\n        else if(fnm==\"COMMENT\") {  var ds = rU32(buff, loff);  loff+=4;  }\n        \n        else if(fnm==\"SELECTOBJECT\") {\n            var ind = rU32(buff, loff);  loff+=4;\n            //console.log(ind.toString(16), tab, tab[ind]);\n            if     (ind==0x80000000) {  prms.fill=true ;  gst.colr=[1,1,1];  } // white brush\n            else if(ind==0x80000005) {  prms.fill=false;  } // null brush\n            else if(ind==0x80000007) {  prms.strk=true ;  prms.lwidth=1;  gst.COLR=[0,0,0];  } // black pen\n            else if(ind==0x80000008) {  prms.strk=false;  } // null  pen\n            else if(ind==0x8000000d) {} // system font\n            else if(ind==0x8000000e) {}  // device default font\n            else {\n                var co:any = tab[ind];  //console.log(ind, co);\n                if(co.t==\"b\") {\n                    prms.fill=co.stl!=1;\n                    if     (co.stl==0) {}\n                    else if(co.stl==1) {}\n                    else throw co.stl+\" e\";\n                    gst.colr=co.clr;\n                }\n                else if(co.t==\"p\") {\n                    prms.strk=co.stl!=5;\n                    gst.lwidth = co.wid;\n                    gst.COLR=co.clr;\n                }\n                else if(co.t==\"f\") {\n                    prms.fnt = co;\n                    gst.font.Tf = co.nam;\n                    gst.font.Tfs = Math.abs(co.hgh);\n                    gst.font.Tun = co.und;\n                }\n                else throw \"e\";\n            }\n        }\n        else if(fnm==\"DELETEOBJECT\") {\n            var ind = rU32(buff, loff);  loff+=4;\n            if(tab[ind]!=null) tab[ind]=null;\n            else throw \"e\";\n        }\n        else if(fnm==\"CREATEBRUSHINDIRECT\") {\n            oid = rU32(buff, loff);  loff+=4;\n            obj = {t:\"b\"};\n            obj.stl = rU32(buff, loff);  loff+=4;\n            obj.clr = [buff[loff]/255, buff[loff+1]/255, buff[loff+2]/255];  loff+=4;\n            obj.htc = rU32(buff, loff);  loff+=4;\n            //console.log(oid, obj);\n        }\n        else if(fnm==\"CREATEPEN\" || fnm==\"EXTCREATEPEN\") {\n            oid = rU32(buff, loff);  loff+=4;\n            obj = {t:\"p\"};\n            if(fnm==\"EXTCREATEPEN\") {\n                loff+=16;\n                obj.stl = rU32(buff, loff);  loff+=4;\n                obj.wid = rU32(buff, loff);  loff+=4;\n                //obj.stl = rU32(buff, loff);  \n                loff+=4;\n            } else {\n                obj.stl = rU32(buff, loff);  loff+=4;\n                obj.wid = rU32(buff, loff);  loff+=4;  loff+=4;\n            }\n            obj.clr = [buff[loff]/255, buff[loff+1]/255, buff[loff+2]/255];  loff+=4;\n        }\n        else if(fnm==\"EXTCREATEFONTINDIRECTW\") {\n            oid = rU32(buff, loff);  loff+=4;\n            obj = {t:\"f\", nam:\"\"};\n            obj.hgh = rI32(buff, loff);  loff += 4;\n            loff += 4*2;\n            obj.orn = rI32(buff, loff)/10;  loff+=4;\n            var wgh = rU32(buff, loff);  loff+=4;  //console.log(fnm, obj.orn, wgh);\n            //console.log(rU32(buff,loff), rU32(buff,loff+4), buff.slice(loff,loff+8));\n            obj.und = buff[loff+1];  obj.stk = buff[loff+2];  loff += 4*2;\n            while(rU(buff,loff)!=0) {  obj.nam+=String.fromCharCode(rU(buff,loff));  loff+=2;  }\n            if(wgh>500) obj.nam+=\"-Bold\";\n            //console.log(wgh, obj.nam);\n        }\n        else if(fnm==\"EXTTEXTOUTW\") {\n            //console.log(buff.slice(loff-8, loff-8+siz));\n            loff+=16;\n            var mod = rU32(buff, loff);  loff+=4;  //console.log(mod);\n            var scx = rF32(buff, loff);  loff+=4;\n            var scy = rF32(buff, loff);  loff+=4;\n            var rfx = rI32(buff, loff);  loff+=4;\n            var rfy = rI32(buff, loff);  loff+=4;\n            //console.log(mod, scx, scy,rfx,rfy);\n            \n            gst.font.Tm = [1,0,0,-1,0,0];\n            UDOC.M.rotate(gst.font.Tm, prms.fnt.orn*Math.PI/180);\n            UDOC.M.translate(gst.font.Tm, rfx, rfy);\n            \n            var alg = prms.talg;  //console.log(alg.toString(2));\n            if     ((alg&6)==6) gst.font.Tal = 2;\n            else if((alg&7)==0) gst.font.Tal = 0;\n            else throw alg+\" e\";\n            if((alg&24)==24) {}  // baseline\n            else if((alg&24)==0) UDOC.M.translate(gst.font.Tm, 0, gst.font.Tfs);\n            else throw \"e\";\n            \n            \n            var crs = rU32(buff, loff);  loff+=4;\n            var ofs = rU32(buff, loff);  loff+=4;\n            var ops = rU32(buff, loff);  loff+=4;  //if(ops!=0) throw \"e\";\n            //console.log(ofs,ops,crs);\n            loff+=16;\n            var ofD = rU32(buff, loff);  loff+=4;  //console.log(ops, ofD, loff, ofs+off-8);\n            ofs += off-8;  //console.log(crs, ops);\n            var str = \"\";\n            for(var i=0; i<crs; i++) {  var cc=rU(buff,ofs+i*2);  str+=String.fromCharCode(cc);  };\n            var oclr = gst.colr;  gst.colr = prms.tclr;\n            //console.log(str, gst.colr, gst.font.Tm);\n            //var otfs = gst.font.Tfs;  gst.font.Tfs *= 1/gst.ctm[0];\n            genv.PutText(gst, str, str.length*gst.font.Tfs*0.5);  gst.colr=oclr;\n            //gst.font.Tfs = otfs;\n            //console.log(rfx, rfy, scx, ops, rcX, rcY, rcW, rcH, offDx, str);\n        }\n        else if(fnm==\"BEGINPATH\") {  UDOC.G.newPath(gst);  }\n        else if(fnm==\"ENDPATH\"  ) {    }\n        else if(fnm==\"CLOSEFIGURE\") UDOC.G.closePath(gst);\n        else if(fnm==\"MOVETOEX\" ) {  UDOC.G.moveTo(gst, rI32(buff,loff), rI32(buff,loff+4));  }\n        else if(fnm==\"LINETO\"   ) {  \n            if(gst.pth.cmds.length==0) {  var im=gst.ctm.slice(0);  UDOC.M.invert(im);  var p = UDOC.M.multPoint(im, gst.cpos);  UDOC.G.moveTo(gst, p[0], p[1]);  }  \n            UDOC.G.lineTo(gst, rI32(buff,loff), rI32(buff,loff+4));  }\n        else if(fnm==\"POLYGON\" || fnm==\"POLYGON16\" || fnm==\"POLYLINE\" || fnm==\"POLYLINE16\" || fnm==\"POLYLINETO\" || fnm==\"POLYLINETO16\") {\n            loff+=16;\n            var ndf = fnm.startsWith(\"POLYGON\"), isTo = fnm.indexOf(\"TO\")!=-1;\n            var cnt = rU32(buff, loff);  loff+=4;\n            if(!isTo) UDOC.G.newPath(gst);\n            loff = FromEMF._drawPoly(buff,loff,cnt,gst, fnm.endsWith(\"16\")?2:4,  ndf, isTo);\n            if(!isTo) FromEMF._draw(genv,gst,prms, ndf);\n            //console.log(prms, gst.lwidth);\n            //console.log(JSON.parse(JSON.stringify(gst.pth)));\n        }\n        else if(fnm==\"POLYPOLYGON16\") {\n            loff+=16;\n            var ndf = fnm.startsWith(\"POLYPOLYGON\"), isTo = fnm.indexOf(\"TO\")!=-1;\n            var nop = rU32(buff, loff);  loff+=4;  loff+=4;\n            var pi = loff;  loff+= nop*4;\n            \n            if(!isTo) UDOC.G.newPath(gst);\n            for(var i=0; i<nop; i++) {\n                var ppp = rU(buff, pi+i*4);\n                loff = FromEMF._drawPoly(buff,loff,ppp,gst, fnm.endsWith(\"16\")?2:4, ndf, isTo);\n            }\n            if(!isTo) FromEMF._draw(genv,gst,prms, ndf);\n        }\n        else if(fnm==\"POLYBEZIER\" || fnm==\"POLYBEZIER16\" || fnm==\"POLYBEZIERTO\" || fnm==\"POLYBEZIERTO16\") {\n            loff+=16;\n            var is16 = fnm.endsWith(\"16\"), rC = is16?rI:rI32, nl = is16?2:4;\n            var cnt = rU32(buff, loff);  loff+=4;\n            if(fnm.indexOf(\"TO\")==-1) {\n                UDOC.G.moveTo(gst, rC(buff,loff), rC(buff,loff+nl));  loff+=2*nl;  cnt--;\n            }\n            while(cnt>0) {\n                UDOC.G.curveTo(gst, rC(buff,loff), rC(buff,loff+nl), rC(buff,loff+2*nl), rC(buff,loff+3*nl), rC(buff,loff+4*nl), rC(buff,loff+5*nl) );\n                loff+=6*nl;\n                cnt-=3;\n            }\n            //console.log(JSON.parse(JSON.stringify(gst.pth)));\n        }\n        else if(fnm==\"RECTANGLE\" || fnm==\"ELLIPSE\") {\n            UDOC.G.newPath(gst);\n            var bx = FromEMF._readBox(buff, loff);\n            if(fnm==\"RECTANGLE\") {\n                UDOC.G.moveTo(gst, bx[0],bx[1]);\n                UDOC.G.lineTo(gst, bx[2],bx[1]);\n                UDOC.G.lineTo(gst, bx[2],bx[3]);\n                UDOC.G.lineTo(gst, bx[0],bx[3]);\n            }\n            else {\n                var x = (bx[0]+bx[2])/2, y = (bx[1]+bx[3])/2;\n                UDOC.G.arc(gst,x,y,(bx[2]-bx[0])/2,0,2*Math.PI, false);\n            }\n            UDOC.G.closePath(gst);\n            FromEMF._draw(genv,gst,prms, true);\n            //console.log(prms, gst.lwidth);\n        }\n        else if(fnm==\"FILLPATH\"  ) genv.Fill(gst, false);\n        else if(fnm==\"STROKEPATH\") genv.Stroke(gst);\n        else if(fnm==\"STROKEANDFILLPATH\") {  genv.Fill(gst, false);  genv.Stroke(gst);  }\n        else if(fnm==\"SETWORLDTRANSFORM\" || fnm==\"MODIFYWORLDTRANSFORM\") {\n            var mat = [];\n            for(var i=0; i<6; i++) mat.push(rF32(buff,loff+i*4));  loff+=24;\n            //console.log(fnm, gst.ctm.slice(0), mat);\n            if(fnm==\"SETWORLDTRANSFORM\") gst.ctm=mat;\n            else {\n                var mod = rU32(buff,loff);  loff+=4;\n                if(mod==2) {  var om=gst.ctm;  gst.ctm=mat;  UDOC.M.concat(gst.ctm, om);  }\n                else throw \"e\";\n            }\n        }\n        else if(fnm==\"SETSTRETCHBLTMODE\") {  var sm = rU32(buff, loff);  loff+=4;  }\n        else if(fnm==\"STRETCHDIBITS\") {\n            var bx = FromEMF._readBox(buff, loff);  loff+=16;\n            var xD = rI32(buff, loff);  loff+=4;\n            var yD = rI32(buff, loff);  loff+=4;\n            var xS = rI32(buff, loff);  loff+=4;\n            var yS = rI32(buff, loff);  loff+=4;\n            var wS = rI32(buff, loff);  loff+=4;\n            var hS = rI32(buff, loff);  loff+=4;\n            var ofH = rU32(buff, loff)+off-8;  loff+=4;\n            var szH = rU32(buff, loff);  loff+=4;\n            var ofB = rU32(buff, loff)+off-8;  loff+=4;\n            var szB = rU32(buff, loff);  loff+=4;\n            var usg = rU32(buff, loff);  loff+=4;  if(usg!=0) throw \"e\";\n            var bop = rU32(buff, loff);  loff+=4;\n            var wD = rI32(buff, loff);  loff+=4;\n            var hD = rI32(buff, loff);  loff+=4;  //console.log(bop, wD, hD);\n            \n            //console.log(ofH, szH, ofB, szB, ofH+40);\n            //console.log(bx, xD,yD,wD,hD);\n            //console.log(xS,yS,wS,hS);\n            //console.log(ofH,szH,ofB,szB,usg,bop);\n            \n            var hl = rU32(buff, ofH);  ofH+=4;\n            var w  = rU32(buff, ofH);  ofH+=4;\n            var h  = rU32(buff, ofH);  ofH+=4;  if(w!=wS || h!=hS) throw \"e\";\n            var ps = rU  (buff, ofH);  ofH+=2;\n            var bc = rU  (buff, ofH);  ofH+=2;  if(bc!=8 && bc!=24 && bc!=32) throw bc+\" e\";\n            var cpr= rU32(buff, ofH);  ofH+=4;  if(cpr!=0) throw cpr+\" e\";\n            var sz = rU32(buff, ofH);  ofH+=4;\n            var xpm= rU32(buff, ofH);  ofH+=4;\n            var ypm= rU32(buff, ofH);  ofH+=4;\n            var cu = rU32(buff, ofH);  ofH+=4;\n            var ci = rU32(buff, ofH);  ofH+=4;  //console.log(hl, w, h, ps, bc, cpr, sz, xpm, ypm, cu, ci);\n            \n            //console.log(hl,w,h,\",\",xS,yS,wS,hS,\",\",xD,yD,wD,hD,\",\",xpm,ypm);\n            \n            var rl = Math.floor(((w * ps * bc + 31) & ~31) / 8);\n            var img = new Uint8Array(w*h*4);\n            if(bc==8) {\n                for(var y=0; y<h; y++) \n                    for(var x=0; x<w; x++) {\n                        var qi = (y*w+x)<<2, ind:any = buff[ofB+(h-1-y)*rl+x]<<2;\n                        img[qi  ] = buff[ofH+ind+2];\n                        img[qi+1] = buff[ofH+ind+1];\n                        img[qi+2] = buff[ofH+ind+0];\n                        img[qi+3] = 255;\n                    }\n            }\n            if(bc==24) {\n                for(var y=0; y<h; y++) \n                    for(var x=0; x<w; x++) {\n                        var qi = (y*w+x)<<2, ti=ofB+(h-1-y)*rl+x*3;\n                        img[qi  ] = buff[ti+2];\n                        img[qi+1] = buff[ti+1];\n                        img[qi+2] = buff[ti+0];\n                        img[qi+3] = 255;\n                    }\n            }\n            if(bc==32) {\n                for(var y=0; y<h; y++) \n                    for(var x=0; x<w; x++) {\n                        var qi = (y*w+x)<<2, ti=ofB+(h-1-y)*rl+x*4;\n                        img[qi  ] = buff[ti+2];\n                        img[qi+1] = buff[ti+1];\n                        img[qi+2] = buff[ti+0];\n                        img[qi+3] = buff[ti+3];\n                    }\n            }\n            \n            var ctm = gst.ctm.slice(0);\n            gst.ctm = [1,0,0,1,0,0];\n            UDOC.M.scale(gst.ctm, wD, -hD);\n            UDOC.M.translate(gst.ctm, xD, yD+hD);\n            UDOC.M.concat(gst.ctm, ctm);\n            genv.PutImage(gst, img, w, h);\n            gst.ctm = ctm;\n        }\n        else {\n            console.log(fnm, siz);\n        }\n        \n        if(obj!=null) tab[oid]=obj;\n        \n        off+=siz-8;\n    }\n    //genv.Stroke(gst);\n    genv.ShowPage();  genv.Done();\n}\nFromEMF._readBox = function(buff:any, off:any) {  var b=[];  for(var i=0; i<4; i++) b[i] = FromEMF.B.readInt(buff,off+i*4);  return b;  }\t\n\nFromEMF._updateCtm = function(prms:any, gst:any) {\n    var mat = [1,0,0,1,0,0];\n    var wbb = prms.wbb, bb = prms.bb, vbb=(prms.vbb && prms.vbb.length==4) ? prms.vbb:prms.bb;\n    \n    //var y0 = bb[1], y1 = bb[3];  bb[1]=Math.min(y0,y1);  bb[3]=Math.max(y0,y1);\n    \n    UDOC.M.translate(mat, -wbb[0],-wbb[1]);\n    UDOC.M.scale(mat, 1/wbb[2], 1/wbb[3]);\n    \n    UDOC.M.scale(mat, vbb[2], vbb[3]);\n    //UDOC.M.scale(mat, vbb[2]/(bb[2]-bb[0]), vbb[3]/(bb[3]-bb[1]));\n    \n    //UDOC.M.scale(mat, bb[2]-bb[0],bb[3]-bb[1]);\n    \n    gst.ctm = mat;\n}\nFromEMF._draw = function(genv:any, gst:any, prms:any, needFill:any) {\n    if(prms.fill && needFill     ) genv.Fill  (gst, false);\n    if(prms.strk && gst.lwidth!=0) genv.Stroke(gst);\n}\nFromEMF._drawPoly = function(buff:any, off:any, ppp:any, gst:any, nl:any, clos:any, justLine:any) {\n    var rS = nl==2 ? FromEMF.B.readShort : FromEMF.B.readInt;\n    for(var j=0; j<ppp; j++) {\n        var px = rS(buff, off);  off+=nl;  \n        var py = rS(buff, off);  off+=nl;\n        if(j==0 && !justLine) UDOC.G.moveTo(gst,px,py);  else UDOC.G.lineTo(gst,px,py);\n    }\n    if(clos) UDOC.G.closePath(gst);\n    return off;\n}\n\nFromEMF.B = {\n    uint8 : new Uint8Array(4),\n    readShort  : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  return FromEMF.B.int16 [0];  },\n    readUshort : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  return FromEMF.B.uint16[0];  },\n    readInt    : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  u8[2]=buff[p+2];  u8[3]=buff[p+3];  return FromEMF.B.int32 [0];  },\n    readUint   : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  u8[2]=buff[p+2];  u8[3]=buff[p+3];  return FromEMF.B.uint32[0];  },\n    readFloat  : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  u8[2]=buff[p+2];  u8[3]=buff[p+3];  return FromEMF.B.flot32[0];  },\n    readASCII  : function(buff:any,p:any,l:any):any {  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    }\n}\nFromEMF.B.int16  = new Int16Array (FromEMF.B.uint8.buffer);\nFromEMF.B.uint16 = new Uint16Array(FromEMF.B.uint8.buffer);\nFromEMF.B.int32  = new Int32Array (FromEMF.B.uint8.buffer);\nFromEMF.B.uint32 = new Uint32Array(FromEMF.B.uint8.buffer);\nFromEMF.B.flot32 = new Float32Array(FromEMF.B.uint8.buffer);\n\n\nFromEMF.C = {\n    EMR_HEADER : 0x00000001,\n    EMR_POLYBEZIER : 0x00000002,\n    EMR_POLYGON : 0x00000003,\n    EMR_POLYLINE : 0x00000004,\n    EMR_POLYBEZIERTO : 0x00000005,\n    EMR_POLYLINETO : 0x00000006,\n    EMR_POLYPOLYLINE : 0x00000007,\n    EMR_POLYPOLYGON : 0x00000008,\n    EMR_SETWINDOWEXTEX : 0x00000009,\n    EMR_SETWINDOWORGEX : 0x0000000A,\n    EMR_SETVIEWPORTEXTEX : 0x0000000B,\n    EMR_SETVIEWPORTORGEX : 0x0000000C,\n    EMR_SETBRUSHORGEX : 0x0000000D,\n    EMR_EOF : 0x0000000E,\n    EMR_SETPIXELV : 0x0000000F,\n    EMR_SETMAPPERFLAGS : 0x00000010,\n    EMR_SETMAPMODE : 0x00000011,\n    EMR_SETBKMODE : 0x00000012,\n    EMR_SETPOLYFILLMODE : 0x00000013,\n    EMR_SETROP2 : 0x00000014,\n    EMR_SETSTRETCHBLTMODE : 0x00000015,\n    EMR_SETTEXTALIGN : 0x00000016,\n    EMR_SETCOLORADJUSTMENT : 0x00000017,\n    EMR_SETTEXTCOLOR : 0x00000018,\n    EMR_SETBKCOLOR : 0x00000019,\n    EMR_OFFSETCLIPRGN : 0x0000001A,\n    EMR_MOVETOEX : 0x0000001B,\n    EMR_SETMETARGN : 0x0000001C,\n    EMR_EXCLUDECLIPRECT : 0x0000001D,\n    EMR_INTERSECTCLIPRECT : 0x0000001E,\n    EMR_SCALEVIEWPORTEXTEX : 0x0000001F,\n    EMR_SCALEWINDOWEXTEX : 0x00000020,\n    EMR_SAVEDC : 0x00000021,\n    EMR_RESTOREDC : 0x00000022,\n    EMR_SETWORLDTRANSFORM : 0x00000023,\n    EMR_MODIFYWORLDTRANSFORM : 0x00000024,\n    EMR_SELECTOBJECT : 0x00000025,\n    EMR_CREATEPEN : 0x00000026,\n    EMR_CREATEBRUSHINDIRECT : 0x00000027,\n    EMR_DELETEOBJECT : 0x00000028,\n    EMR_ANGLEARC : 0x00000029,\n    EMR_ELLIPSE : 0x0000002A,\n    EMR_RECTANGLE : 0x0000002B,\n    EMR_ROUNDRECT : 0x0000002C,\n    EMR_ARC : 0x0000002D,\n    EMR_CHORD : 0x0000002E,\n    EMR_PIE : 0x0000002F,\n    EMR_SELECTPALETTE : 0x00000030,\n    EMR_CREATEPALETTE : 0x00000031,\n    EMR_SETPALETTEENTRIES : 0x00000032,\n    EMR_RESIZEPALETTE : 0x00000033,\n    EMR_REALIZEPALETTE : 0x00000034,\n    EMR_EXTFLOODFILL : 0x00000035,\n    EMR_LINETO : 0x00000036,\n    EMR_ARCTO : 0x00000037,\n    EMR_POLYDRAW : 0x00000038,\n    EMR_SETARCDIRECTION : 0x00000039,\n    EMR_SETMITERLIMIT : 0x0000003A,\n    EMR_BEGINPATH : 0x0000003B,\n    EMR_ENDPATH : 0x0000003C,\n    EMR_CLOSEFIGURE : 0x0000003D,\n    EMR_FILLPATH : 0x0000003E,\n    EMR_STROKEANDFILLPATH : 0x0000003F,\n    EMR_STROKEPATH : 0x00000040,\n    EMR_FLATTENPATH : 0x00000041,\n    EMR_WIDENPATH : 0x00000042,\n    EMR_SELECTCLIPPATH : 0x00000043,\n    EMR_ABORTPATH : 0x00000044,\n    EMR_COMMENT : 0x00000046,\n    EMR_FILLRGN : 0x00000047,\n    EMR_FRAMERGN : 0x00000048,\n    EMR_INVERTRGN : 0x00000049,\n    EMR_PAINTRGN : 0x0000004A,\n    EMR_EXTSELECTCLIPRGN : 0x0000004B,\n    EMR_BITBLT : 0x0000004C,\n    EMR_STRETCHBLT : 0x0000004D,\n    EMR_MASKBLT : 0x0000004E,\n    EMR_PLGBLT : 0x0000004F,\n    EMR_SETDIBITSTODEVICE : 0x00000050,\n    EMR_STRETCHDIBITS : 0x00000051,\n    EMR_EXTCREATEFONTINDIRECTW : 0x00000052,\n    EMR_EXTTEXTOUTA : 0x00000053,\n    EMR_EXTTEXTOUTW : 0x00000054,\n    EMR_POLYBEZIER16 : 0x00000055,\n    EMR_POLYGON16 : 0x00000056,\n    EMR_POLYLINE16 : 0x00000057,\n    EMR_POLYBEZIERTO16 : 0x00000058,\n    EMR_POLYLINETO16 : 0x00000059,\n    EMR_POLYPOLYLINE16 : 0x0000005A,\n    EMR_POLYPOLYGON16 : 0x0000005B,\n    EMR_POLYDRAW16 : 0x0000005C,\n    EMR_CREATEMONOBRUSH : 0x0000005D,\n    EMR_CREATEDIBPATTERNBRUSHPT : 0x0000005E,\n    EMR_EXTCREATEPEN : 0x0000005F,\n    EMR_POLYTEXTOUTA : 0x00000060,\n    EMR_POLYTEXTOUTW : 0x00000061,\n    EMR_SETICMMODE : 0x00000062,\n    EMR_CREATECOLORSPACE : 0x00000063,\n    EMR_SETCOLORSPACE : 0x00000064,\n    EMR_DELETECOLORSPACE : 0x00000065,\n    EMR_GLSRECORD : 0x00000066,\n    EMR_GLSBOUNDEDRECORD : 0x00000067,\n    EMR_PIXELFORMAT : 0x00000068,\n    EMR_DRAWESCAPE : 0x00000069,\n    EMR_EXTESCAPE : 0x0000006A,\n    EMR_SMALLTEXTOUT : 0x0000006C,\n    EMR_FORCEUFIMAPPING : 0x0000006D,\n    EMR_NAMEDESCAPE : 0x0000006E,\n    EMR_COLORCORRECTPALETTE : 0x0000006F,\n    EMR_SETICMPROFILEA : 0x00000070,\n    EMR_SETICMPROFILEW : 0x00000071,\n    EMR_ALPHABLEND : 0x00000072,\n    EMR_SETLAYOUT : 0x00000073,\n    EMR_TRANSPARENTBLT : 0x00000074,\n    EMR_GRADIENTFILL : 0x00000076,\n    EMR_SETLINKEDUFIS : 0x00000077,\n    EMR_SETTEXTJUSTIFICATION : 0x00000078,\n    EMR_COLORMATCHTOTARGETW : 0x00000079,\n    EMR_CREATECOLORSPACEW : 0x0000007A\n};\nFromEMF.K = [];\n\n// (function() {\n//     var inp, out, stt;\n//     inp = FromEMF.C;   out = FromEMF.K;   stt=4;\n//     for(var p in inp) out[inp[p]] = p.slice(stt);\n// }  )();\n\n\n\nexport let ToContext2D:any = function (needPage:any, scale:any)\n{\n    this.canvas = document.createElement(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.bb = null;\n    this.currPage = 0;\n    this.needPage = needPage;\n    this.scale = scale;\n}\nToContext2D.prototype.StartPage = function(x:any,y:any,w:any,h:any) {\n    if(this.currPage!=this.needPage) return;\n    this.bb = [x,y,w,h];\n    var scl = this.scale, dpr = window.devicePixelRatio;\n    var cnv = this.canvas, ctx = this.ctx;\n    cnv.width = Math.round(w*scl);  cnv.height = Math.round(h*scl);\n    ctx.translate(0,h*scl);  ctx.scale(scl,-scl);\n    cnv.setAttribute(\"style\", \"border:1px solid; width:\"+(cnv.width/dpr)+\"px; height:\"+(cnv.height/dpr)+\"px\");\n}\nToContext2D.prototype.Fill = function(gst:any, evenOdd:any) {\n    if(this.currPage!=this.needPage) return;\n    var ctx = this.ctx;\n    ctx.beginPath();\n    this._setStyle(gst, ctx);\n    this._draw(gst.pth, ctx);\n    ctx.fill();\n}\nToContext2D.prototype.Stroke = function(gst:any) {\n    if(this.currPage!=this.needPage) return;\n    var ctx = this.ctx;\n    ctx.beginPath();\n    this._setStyle(gst, ctx);\n    this._draw(gst.pth, ctx);\n    ctx.stroke();\n}\nToContext2D.prototype.PutText = function(gst:any, str:any, stw:any) {\n    if(this.currPage!=this.needPage) return;\n    var scl = this._scale(gst.ctm);\n    var ctx = this.ctx;\n    this._setStyle(gst, ctx);\n    ctx.save();\n    var m = [1,0,0,-1,0,0];  this._concat(m, gst.font.Tm);  this._concat(m, gst.ctm);\n    //console.log(str, m, gst);  throw \"e\";\n    ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);\n    ctx.fillText(str,0,0);\n    ctx.restore();\n}\nToContext2D.prototype.PutImage = function(gst:any, buff:any, w:any, h:any, msk:any) {\n    if(this.currPage!=this.needPage) return;\n    var ctx = this.ctx;\n    \n    if(buff.length==w*h*4) {\n        buff = buff.slice(0);\n        if(msk && msk.length==w*h*4) for(var i=0; i<buff.length; i+=4) buff[i+3] = msk[i+1];\n        \n        var cnv = document.createElement(\"canvas\"), cctx = cnv.getContext(\"2d\");\n        cnv.width = w;  cnv.height = h;\n        var imgd = cctx.createImageData(w,h);\n        for(var i=0; i<buff.length; i++) imgd.data[i]=buff[i];\n        cctx.putImageData(imgd,0,0);\n        \n        ctx.save();\n        var m = [1,0,0,1,0,0];  this._concat(m, [1/w,0,0,-1/h,0,1]);  this._concat(m, gst.ctm);\n        ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);\n        ctx.drawImage(cnv,0,0);\n        ctx.restore();\n    }\n}\nToContext2D.prototype.ShowPage = function() {  this.currPage++;  }\nToContext2D.prototype.Done = function() {}\n\n\nfunction _flt(n:any)  {  return \"\"+parseFloat(n.toFixed(2));  }\n\nToContext2D.prototype._setStyle = function(gst:any, ctx:any) {\n    var scl = this._scale(gst.ctm);\n    ctx.fillStyle = this._getFill(gst.colr, gst.ca, ctx);\n    ctx.strokeStyle=this._getFill(gst.COLR, gst.CA, ctx);\n    \n    ctx.lineCap = [\"butt\",\"round\",\"square\"][gst.lcap];\n    ctx.lineJoin= [\"miter\",\"round\",\"bevel\"][gst.ljoin];\n    ctx.lineWidth=gst.lwidth*scl;\n    var dsh = gst.dash.slice(0);  for(var i=0; i<dsh.length; i++) dsh[i] = _flt(dsh[i]*scl);\n    ctx.setLineDash(dsh); \n    ctx.miterLimit = gst.mlimit*scl;\n    \n    var fn = gst.font.Tf, ln = fn.toLowerCase();\n    var p0 = ln.indexOf(\"bold\")!=-1 ? \"bold \" : \"\";\n    var p1 = (ln.indexOf(\"italic\")!=-1 || ln.indexOf(\"oblique\")!=-1) ? \"italic \" : \"\";\n    ctx.font = p0+p1 + gst.font.Tfs+\"px \\\"\"+fn+\"\\\"\";\n}\nToContext2D.prototype._getFill = function(colr:any, ca:any, ctx:any)\n{\n    if(colr.typ==null) return this._colr(colr,ca);\n    else {\n        var grd = colr, crd = grd.crds, mat = grd.mat, scl=this._scale(mat), gf;\n        if     (grd.typ==\"lin\") {\n            var p0 = this._multPoint(mat,crd.slice(0,2)), p1 = this._multPoint(mat,crd.slice(2));\n            gf=ctx.createLinearGradient(p0[0],p0[1],p1[0],p1[1]);\n        }\n        else if(grd.typ==\"rad\") {\n            var p0 = this._multPoint(mat,crd.slice(0,2)), p1 = this._multPoint(mat,crd.slice(3));\n            gf=ctx.createRadialGradient(p0[0],p0[1],crd[2]*scl,p1[0],p1[1],crd[5]*scl);\n        }\n        for(var i=0; i<grd.grad.length; i++)  gf.addColorStop(grd.grad[i][0],this._colr(grd.grad[i][1], ca));\n        return gf;\n    }\n}\nToContext2D.prototype._colr  = function(c:any,a:any) {  return \"rgba(\"+Math.round(c[0]*255)+\",\"+Math.round(c[1]*255)+\",\"+Math.round(c[2]*255)+\",\"+a+\")\";  };\nToContext2D.prototype._scale = function(m:any)  {  return Math.sqrt(Math.abs(m[0]*m[3]-m[1]*m[2]));  };\nToContext2D.prototype._concat= function(m:any,w:any  ) {  \n        var a=m[0],b=m[1],c=m[2],d=m[3],tx=m[4],ty=m[5];\n        m[0] = (a *w[0])+(b *w[2]);       m[1] = (a *w[1])+(b *w[3]);\n        m[2] = (c *w[0])+(d *w[2]);       m[3] = (c *w[1])+(d *w[3]);\n        m[4] = (tx*w[0])+(ty*w[2])+w[4];  m[5] = (tx*w[1])+(ty*w[3])+w[5]; \n}\nToContext2D.prototype._multPoint= function(m:any, p:any) {  var x=p[0],y=p[1];  return [x*m[0]+y*m[2]+m[4],   x*m[1]+y*m[3]+m[5]];  },\nToContext2D.prototype._draw  = function(path:any, ctx:any)\n{\n    var c = 0, crds = path.crds;\n    for(var j=0; j<path.cmds.length; j++) {\n        var cmd = path.cmds[j];\n        if     (cmd==\"M\") {  ctx.moveTo(crds[c], crds[c+1]);  c+=2;  }\n        else if(cmd==\"L\") {  ctx.lineTo(crds[c], crds[c+1]);  c+=2;  }\n        else if(cmd==\"C\") {  ctx.bezierCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3], crds[c+4], crds[c+5]);  c+=6;  }\n        else if(cmd==\"Q\") {  ctx.quadraticCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3]);  c+=4;  }\n        else if(cmd==\"Z\") {  ctx.closePath();  }\n    }\n}\n","import { columeHeader_word, columeHeader_word_index } from \"./constant\";\nimport { IluckySheetSelection } from \"../ToLuckySheet/ILuck\";\nimport { IattributeList, stringToNum} from \"../ICommon\";\n\n\nexport function getRangetxt(range:IluckySheetSelection, sheettxt:string) {\n\n    let row0 = range[\"row\"][0], row1 = range[\"row\"][1];\n    let column0 = range[\"column\"][0], column1 = range[\"column\"][1];\n\n    if (row0 == null && row1 == null) {\n        return sheettxt + chatatABC(column0) + \":\" + chatatABC(column1);\n    }\n    else if (column0 == null && column1 == null) {\n        return sheettxt + (row0 + 1) + \":\" + (row1 + 1);\n    }\n    else {\n        if (column0 == column1 && row0 == row1) {\n            return sheettxt + chatatABC(column0) + (row0 + 1);\n        }\n        else {\n            return sheettxt + chatatABC(column0) + (row0 + 1) + \":\" + chatatABC(column1) + (row1 + 1);\n        }\n    }\n}\n\n\nexport function getcellrange (txt:string, sheets:IattributeList={}, sheetId:string=\"1\") {\n    let val = txt.split(\"!\");\n\n    let sheettxt = \"\",\n        rangetxt = \"\",\n        sheetIndex = -1;\n\n    if (val.length > 1) {\n        sheettxt = val[0];\n        rangetxt = val[1];\n        \n        let si = sheets[sheettxt];\n        if(si==null){\n            sheetIndex = parseInt(sheetId);\n        }\n        else{\n            sheetIndex = parseInt(si);\n        }\n    } \n    else {\n        sheetIndex = parseInt(sheetId);\n        rangetxt = val[0];\n    }\n    \n    if (rangetxt.indexOf(\":\") == -1) {\n        let row = parseInt(rangetxt.replace(/[^0-9]/g, \"\")) - 1;\n        let col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, \"\"));\n\n        if (!isNaN(row) && !isNaN(col)) {\n            return {\n                \"row\": [row, row],\n                \"column\": [col, col],\n                \"sheetIndex\": sheetIndex\n            };\n        }\n        else {\n            return null;\n        }\n    } \n    else {\n        let rangetxtArray:string[] = rangetxt.split(\":\");\n        let row = [],col = [];\n        row[0] = parseInt(rangetxtArray[0].replace(/[^0-9]/g, \"\")) - 1;\n        row[1] = parseInt(rangetxtArray[1].replace(/[^0-9]/g, \"\")) - 1;\n        // if (isNaN(row[0])) {\n        //     row[0] = 0;\n        // }\n        // if (isNaN(row[1])) {\n        //     row[1] = sheetdata.length - 1;\n        // }\n        if (row[0] > row[1]) {\n            return null;\n        }\n        col[0] = ABCatNum(rangetxtArray[0].replace(/[^A-Za-z]/g, \"\"));\n        col[1] = ABCatNum(rangetxtArray[1].replace(/[^A-Za-z]/g, \"\"));\n        // if (isNaN(col[0])) {\n        //     col[0] = 0;\n        // }\n        // if (isNaN(col[1])) {\n        //     col[1] = sheetdata[0].length - 1;\n        // }\n        if (col[0] > col[1]) {\n            return null;\n        }\n\n        return {\n            \"row\": row,\n            \"column\": col,\n            \"sheetIndex\": sheetIndex\n        };\n    }\n}\n\n//列下标  字母转数字\nfunction ABCatNum(abc:string) {\n    abc = abc.toUpperCase();\n\n    let abc_len = abc.length;\n    if (abc_len == 0) {\n        return NaN;\n    }\n\n    let abc_array = abc.split(\"\");\n    let wordlen = columeHeader_word.length;\n    let ret = 0;\n\n    for (let i = abc_len - 1; i >= 0; i--) {\n        if (i == abc_len - 1) {\n            ret += columeHeader_word_index[abc_array[i]];\n        }\n        else {\n            ret += Math.pow(wordlen, abc_len - i - 1) * (columeHeader_word_index[abc_array[i]] + 1);\n        }\n    }\n\n    return ret;\n}\n\n//列下标  数字转字母\nfunction chatatABC(index:number) {\n    let wordlen = columeHeader_word.length;\n\n    if (index < wordlen) {\n        return columeHeader_word[index];\n    }\n    else {\n        let last = 0, pre = 0, ret = \"\";\n        let i = 1, n = 0;\n\n        while (index >= (wordlen / (wordlen - 1)) * (Math.pow(wordlen, i++) - 1)) {\n            n = i;\n        }\n\n        let index_ab = index - (wordlen / (wordlen - 1)) * (Math.pow(wordlen, n - 1) - 1);//970\n        last = index_ab + 1;\n\n        for (let x = n; x > 0; x--) {\n            let last1 = last, x1 = x;//-702=268, 3\n\n            if (x == 1) {\n                last1 = last1 % wordlen;\n\n                if (last1 == 0) {\n                    last1 = 26;\n                }\n\n                return ret + columeHeader_word[last1 - 1];\n            }\n\n            last1 = Math.ceil(last1 / Math.pow(wordlen, x - 1));\n            //last1 = last1 % wordlen;\n            ret += columeHeader_word[last1 - 1];\n\n            if (x > 1) {\n                last = last - (last1 - 1) * wordlen;\n            }\n        }\n    }\n}\n\n/** \n * @return ratio, default 0.75 1in = 2.54cm = 25.4mm = 72pt = 6pc,  pt = 1/72 In, px = 1/dpi In\n*/\nexport function getptToPxRatioByDPI():number{\n    return 72/96;\n}\n\n/** \n * @emus EMUs, Excel drawing unit\n * @return pixel\n*/\nexport function getPxByEMUs(emus:number){\n    if(emus==null){\n        return 0;\n    }\n    let inch = emus/914400;\n    let pt = inch*72;\n    let px = pt / getptToPxRatioByDPI();\n    return px;\n}\n\n/** \n * @dom xml attribute object\n * @attr attribute name\n * @d if attribute is null, return default value \n * @return attribute value\n*/\nexport function getXmlAttibute(dom:IattributeList, attr:string, d:string){\n    let value = dom[attr];\n    value = value==null?d:value;\n    return value;\n}\n\n/** \n * @columnWidth Excel column width\n * @return pixel column width\n*/\nexport function getColumnWidthPixel(columnWidth:number){\n    let pix = Math.round((columnWidth-0.83) * 8 + 5);\n    return pix;\n}\n\n/** \n * @rowHeight Excel row height\n * @return pixel row height\n*/\nexport function getRowHeightPixel(rowHeight:number){\n    let pix = Math.round(rowHeight/getptToPxRatioByDPI());\n    return pix;\n}\n\nexport function LightenDarkenColor(sixColor:string, tint:number){\n    let hex:string = sixColor.substring(sixColor.length-6,sixColor.length);\n    let rgbArray:number[] = hexToRgbArray(\"#\"+hex);\n    let hslArray = rgbToHsl(rgbArray[0], rgbArray[1],rgbArray[2]);\n    if(tint>0){\n        hslArray[2] = hslArray[2] * (1.0-tint) + tint;\n    }\n    else if(tint<0){\n        hslArray[2] = hslArray[2] * (1.0 + tint)\n    }\n    else{\n        return \"#\"+hex;\n    }\n\n    let newRgbArray = hslToRgb(hslArray[0],hslArray[1],hslArray[2]);\n\n    return rgbToHex(\"RGB(\" + newRgbArray.join(\",\") + \")\");\n}\n\n\nfunction rgbToHex(rgb:string){\n    //十六进制颜色值的正则表达式\n    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\n    // 如果是rgb颜色表示\n    if (/^(rgb|RGB)/.test(rgb)) {\n        var aColor = rgb.replace(/(?:\\(|\\)|rgb|RGB)*/g, \"\").split(\",\");\n        var strHex = \"#\";\n        for (var i=0; i<aColor.length; i++) {\n            var hex = Number(aColor[i]).toString(16);\n            if (hex.length < 2) {\n                hex = '0' + hex;    \n            }\n            strHex += hex;\n        }\n        if (strHex.length !== 7) {\n            strHex = rgb;    \n        }\n        return strHex;\n    } else if (reg.test(rgb)) {\n        var aNum = rgb.replace(/#/,\"\").split(\"\");\n        if (aNum.length === 6) {\n            return rgb;    \n        } else if(aNum.length === 3) {\n            var numHex = \"#\";\n            for (var i=0; i<aNum.length; i+=1) {\n                numHex += (aNum[i] + aNum[i]);\n            }\n            return numHex;\n        }\n    }\n    return rgb;\n}\n\nfunction hexToRgb(hex:string){\n    var sColor = hex.toLowerCase();\n    //十六进制颜色值的正则表达式\n    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\n    // 如果是16进制颜色\n    if (sColor && reg.test(sColor)) {\n        if (sColor.length === 4) {\n            var sColorNew = \"#\";\n            for (var i=1; i<4; i+=1) {\n                sColorNew += sColor.slice(i, i+1).concat(sColor.slice(i, i+1));    \n            }\n            sColor = sColorNew;\n        }\n        //处理六位的颜色值\n        var sColorChange = [];\n        for (var i=1; i<7; i+=2) {\n            sColorChange.push(parseInt(\"0x\"+sColor.slice(i, i+2)));    \n        }\n        return \"RGB(\" + sColorChange.join(\",\") + \")\";\n    }\n    return sColor;\n}\n\nfunction hexToRgbArray(hex:string){\n    var sColor = hex.toLowerCase();\n    //十六进制颜色值的正则表达式\n    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\n    // 如果是16进制颜色\n    if (sColor && reg.test(sColor)) {\n        if (sColor.length === 4) {\n            var sColorNew = \"#\";\n            for (var i=1; i<4; i+=1) {\n                sColorNew += sColor.slice(i, i+1).concat(sColor.slice(i, i+1));    \n            }\n            sColor = sColorNew;\n        }\n        //处理六位的颜色值\n        var sColorChange:number[] = [];\n        for (var i=1; i<7; i+=2) {\n            sColorChange.push(parseInt(\"0x\"+sColor.slice(i, i+2)));    \n        }\n        return  sColorChange;\n    }\n    return null;\n}\n\n/**\n * HSL颜色值转换为RGB. \n * 换算公式改编自 http://en.wikipedia.org/wiki/HSL_color_space.\n * h, s, 和 l 设定在 [0, 1] 之间\n * 返回的 r, g, 和 b 在 [0, 255]之间\n *\n * @param   Number  h       色相\n * @param   Number  s       饱和度\n * @param   Number  l       亮度\n * @return  Array           RGB色值数值\n */\nfunction hslToRgb(h:number, s:number, l:number) {\n    var r, g, b;\n\n    if(s == 0) {\n        r = g = b = l; // achromatic\n    } else {\n        var hue2rgb = function hue2rgb(p:number, q:number, t:number) {\n            if(t < 0) t += 1;\n            if(t > 1) t -= 1;\n            if(t < 1/6) return p + (q - p) * 6 * t;\n            if(t < 1/2) return q;\n            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n            return p;\n        }\n\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1/3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1/3);\n    }\n\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n\n\n/**\n * RGB 颜色值转换为 HSL.\n * 转换公式参考自 http://en.wikipedia.org/wiki/HSL_color_space.\n * r, g, 和 b 需要在 [0, 255] 范围内\n * 返回的 h, s, 和 l 在 [0, 1] 之间\n *\n * @param   Number  r       红色色值\n * @param   Number  g       绿色色值\n * @param   Number  b       蓝色色值\n * @return  Array           HSL各值数组\n */\nfunction rgbToHsl(r:number, g:number, b:number) {\n    r /= 255, g /= 255, b /= 255;\n    var max = Math.max(r, g, b), min = Math.min(r, g, b);\n    var h, s, l = (max + min) / 2;\n\n    if (max == min){ \n        h = s = 0; // achromatic\n    } else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch(max) {\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: h = (b - r) / d + 2; break;\n            case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n    }\n\n    return [h, s, l];\n}\n \nexport function generateRandomIndex(prefix:string):string {\n    if(prefix == null){\n        prefix = \"Sheet\";\n    }\n\n    let userAgent = window.navigator.userAgent.replace(/[^a-zA-Z0-9]/g, \"\").split(\"\");\n\n    let mid = \"\";\n\n    for(let i = 0; i < 5; i++){\n        mid += userAgent[Math.round(Math.random() * (userAgent.length - 1))];\n    }\n\n    let time = new Date().getTime();\n\n    return prefix + \"_\" + mid + \"_\" + time;\n}\n\n\nexport function escapeCharacter(str:string){\n    if(str==null || str.length==0){\n        return str;\n    }\n\n    return str.replace(/&amp;/g, \"&\").replace(/&quot;/g, '\"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&nbsp;/g, ' ').replace(/&apos;/g, \"'\").replace(/&iexcl;/g, \"¡\").replace(/&cent;/g, \"¢\").replace(/&pound;/g, \"£\").replace(/&curren;/g, \"¤\").replace(/&yen;/g, \"¥\").replace(/&brvbar;/g, \"¦\").replace(/&sect;/g, \"§\").replace(/&uml;/g, \"¨\").replace(/&copy;/g, \"©\").replace(/&ordf;/g, \"ª\").replace(/&laquo;/g, \"«\").replace(/&not;/g, \"¬\").replace(/&shy;/g, \"­\").replace(/&reg;/g, \"®\").replace(/&macr;/g, \"¯\").replace(/&deg;/g, \"°\").replace(/&plusmn;/g, \"±\").replace(/&sup2;/g, \"²\").replace(/&sup3;/g, \"³\").replace(/&acute;/g, \"´\").replace(/&micro;/g, \"µ\").replace(/&para;/g, \"¶\").replace(/&middot;/g, \"·\").replace(/&cedil;/g, \"¸\").replace(/&sup1;/g, \"¹\").replace(/&ordm;/g, \"º\").replace(/&raquo;/g, \"»\").replace(/&frac14;/g, \"¼\").replace(/&frac12;/g, \"½\").replace(/&frac34;/g, \"¾\").replace(/&iquest;/g, \"¿\").replace(/&times;/g, \"×\").replace(/&divide;/g, \"÷\").replace(/&Agrave;/g, \"À\").replace(/&Aacute;/g, \"Á\").replace(/&Acirc;/g, \"Â\").replace(/&Atilde;/g, \"Ã\").replace(/&Auml;/g, \"Ä\").replace(/&Aring;/g, \"Å\").replace(/&AElig;/g, \"Æ\").replace(/&Ccedil;/g, \"Ç\").replace(/&Egrave;/g, \"È\").replace(/&Eacute;/g, \"É\").replace(/&Ecirc;/g, \"Ê\").replace(/&Euml;/g, \"Ë\").replace(/&Igrave;/g, \"Ì\").replace(/&Iacute;/g, \"Í\").replace(/&Icirc;/g, \"Î\").replace(/&Iuml;/g, \"Ï\").replace(/&ETH;/g, \"Ð\").replace(/&Ntilde;/g, \"Ñ\").replace(/&Ograve;/g, \"Ò\").replace(/&Oacute;/g, \"Ó\").replace(/&Ocirc;/g, \"Ô\").replace(/&Otilde;/g, \"Õ\").replace(/&Ouml;/g, \"Ö\").replace(/&Oslash;/g, \"Ø\").replace(/&Ugrave;/g, \"Ù\").replace(/&Uacute;/g, \"Ú\").replace(/&Ucirc;/g, \"Û\").replace(/&Uuml;/g, \"Ü\").replace(/&Yacute;/g, \"Ý\").replace(/&THORN;/g, \"Þ\").replace(/&szlig;/g, \"ß\").replace(/&agrave;/g, \"à\").replace(/&aacute;/g, \"á\").replace(/&acirc;/g, \"â\").replace(/&atilde;/g, \"ã\").replace(/&auml;/g, \"ä\").replace(/&aring;/g, \"å\").replace(/&aelig;/g, \"æ\").replace(/&ccedil;/g, \"ç\").replace(/&egrave;/g, \"è\").replace(/&eacute;/g, \"é\").replace(/&ecirc;/g, \"ê\").replace(/&euml;/g, \"ë\").replace(/&igrave;/g, \"ì\").replace(/&iacute;/g, \"í\").replace(/&icirc;/g, \"î\").replace(/&iuml;/g, \"ï\").replace(/&eth;/g, \"ð\").replace(/&ntilde;/g, \"ñ\").replace(/&ograve;/g, \"ò\").replace(/&oacute;/g, \"ó\").replace(/&ocirc;/g, \"ô\").replace(/&otilde;/g, \"õ\").replace(/&ouml;/g, \"ö\").replace(/&oslash;/g, \"ø\").replace(/&ugrave;/g, \"ù\").replace(/&uacute;/g, \"ú\").replace(/&ucirc;/g, \"û\").replace(/&uuml;/g, \"ü\").replace(/&yacute;/g, \"ý\").replace(/&thorn;/g, \"þ\").replace(/&yuml;/g, \"ÿ\");\n\n}\n\n\nexport class fromulaRef {\n\n    static operator = '==|!=|<>|<=|>=|=|+|-|>|<|/|*|%|&|^'\n    static error = {\n        v: \"#VALUE!\",    //错误的参数或运算符\n        n: \"#NAME?\",     //公式名称错误\n        na: \"#N/A\",      //函数或公式中没有可用数值\n        r: \"#REF!\",      //删除了由其他公式引用的单元格\n        d: \"#DIV/0!\",    //除数是0或空单元格\n        nm: \"#NUM!\",     //当公式或函数中某个数字有问题时\n        nl: \"#NULL!\",    //交叉运算符（空格）使用不正确\n        sp: \"#SPILL!\"    //数组范围有其它值\n    }\n\n    static operatorjson:stringToNum = null\n\n    static trim(str:string) {  \n        if(str == null){  \n            str = \"\";  \n        }  \n        return str.replace(/(^\\s*)|(\\s*$)/g, \"\");  \n    }\n\n    static functionCopy(txt:string, mode:string, step:number) {\n        let _this = this;\n\n        if (_this.operatorjson == null) {\n            let arr = _this.operator.split(\"|\"),\n                op:stringToNum = {};\n\n            for (let i = 0; i < arr.length; i++) {\n                op[arr[i].toString()] = 1;\n            }\n\n            _this.operatorjson = op;\n        }\n\n        if (mode == null) {\n            mode = \"down\";\n        }\n\n        if (step == null) {\n            step = 1;\n        }\n\n        if (txt.substr(0, 1) == \"=\") {\n            txt = txt.substr(1);\n        }\n\n        let funcstack = txt.split(\"\");\n        let i = 0,\n            str = \"\",\n            function_str = \"\",\n            ispassby = true;\n        \n        let matchConfig = {\n            \"bracket\": 0,\n            \"comma\": 0,\n            \"squote\": 0,\n            \"dquote\": 0\n        };\n\n        while (i < funcstack.length) {\n            let s = funcstack[i];\n\n            if (s == \"(\" && matchConfig.dquote == 0) {\n                matchConfig.bracket += 1;\n\n                if (str.length > 0) {\n                    function_str += str + \"(\";\n                } \n                else {\n                    function_str += \"(\";\n                }\n\n                str = \"\";\n            } \n            else if (s == \")\" && matchConfig.dquote == 0) {\n                matchConfig.bracket -= 1;\n                function_str += _this.functionCopy(str, mode, step) + \")\";\n                str = \"\";\n            }\n            else if (s == '\"' && matchConfig.squote == 0) {\n                if (matchConfig.dquote > 0) {\n                    function_str += str + '\"';\n                    matchConfig.dquote -= 1;\n                    str = \"\";\n                } \n                else {\n                    matchConfig.dquote += 1;\n                    str += '\"';\n                }\n            } \n            else if (s == ',' && matchConfig.dquote == 0) {\n                function_str += _this.functionCopy(str, mode, step) + ',';\n                str = \"\";\n            } \n            else if (s == '&' && matchConfig.dquote == 0) {\n                if (str.length > 0) {\n                    function_str += _this.functionCopy(str, mode, step) + \"&\";\n                    str = \"\";\n                } \n                else {\n                    function_str += \"&\";\n                }\n            } \n            else if (s in _this.operatorjson && matchConfig.dquote == 0) {\n                let s_next = \"\";\n\n                if ((i + 1) < funcstack.length) {\n                    s_next = funcstack[i + 1];\n                }\n\n                let p = i - 1, \n                    s_pre = null;\n\n                if(p >= 0){\n                    do {\n                        s_pre = funcstack[p--];\n                    }\n                    while (p>=0 && s_pre ==\" \")\n                }\n\n                if ((s + s_next) in _this.operatorjson) {\n                    if (str.length > 0) {\n                        function_str += _this.functionCopy(str, mode, step) + s + s_next;\n                        str = \"\";\n                    } \n                    else {\n                        function_str += s + s_next;\n                    }\n\n                    i++;\n                }\n                else if(!(/[^0-9]/.test(s_next)) && s==\"-\" && (s_pre==\"(\" || s_pre == null || s_pre == \",\" || s_pre == \" \" || s_pre in _this.operatorjson ) ){\n                    str += s;\n                }\n                else {\n                    if (str.length > 0) {\n                        function_str += _this.functionCopy(str, mode, step) + s;\n                        str = \"\";\n                    } \n                    else {\n                        function_str += s;\n                    }\n                }\n            } \n            else {\n                str += s;\n            }\n\n            if (i == funcstack.length - 1) {\n                if (_this.iscelldata(_this.trim(str))) {\n                    if (mode == \"down\") {\n                        function_str += _this.downparam(_this.trim(str), step);\n                    } \n                    else if (mode == \"up\") {\n                        function_str += _this.upparam(_this.trim(str), step);\n                    } \n                    else if (mode == \"left\") {\n                        function_str += _this.leftparam(_this.trim(str), step);\n                    } \n                    else if (mode == \"right\") {\n                        function_str += _this.rightparam(_this.trim(str), step);\n                    }\n                } \n                else {\n                    function_str += _this.trim(str);\n                }\n            }\n            \n            i++;\n        }\n\n        return function_str;\n    }\n\n\n    static downparam(txt:string, step:number) {\n        return this.updateparam(\"d\", txt, step);\n    }\n\n    static upparam(txt:string, step:number) {\n        return this.updateparam(\"u\", txt, step);\n    }\n\n    static leftparam(txt:string, step:number) {\n        return this.updateparam(\"l\", txt, step);\n    }\n\n    static rightparam (txt:string, step:number) {\n        return this.updateparam(\"r\", txt, step);\n    }\n\n\n    static updateparam (orient:string, txt:string, step:number) {\n        let _this = this;\n        let val = txt.split(\"!\"),\n            rangetxt, prefix = \"\";\n        \n        if (val.length > 1) {\n            rangetxt = val[1];\n            prefix = val[0] + \"!\";\n        } \n        else {\n            rangetxt = val[0];\n        }\n\n        if (rangetxt.indexOf(\":\") == -1) {\n            let row = parseInt(rangetxt.replace(/[^0-9]/g, \"\"));\n            let col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, \"\"));\n            let freezonFuc = _this.isfreezonFuc(rangetxt);\n            let $row = freezonFuc[0] ? \"$\" : \"\",\n                $col = freezonFuc[1] ? \"$\" : \"\";\n            \n            if (orient == \"u\" && !freezonFuc[0]) {\n                row -= step;\n            } \n            else if (orient == \"r\" && !freezonFuc[1]) {\n                col += step;\n            } \n            else if (orient == \"l\" && !freezonFuc[1]) {\n                col -= step;\n            } \n            else if (!freezonFuc[0]) {\n                row += step;\n            }\n\n            if(row < 0 || col < 0){\n                return _this.error.r;\n            }\n            \n            if (!isNaN(row) && !isNaN(col)) {\n                return prefix + $col + chatatABC(col) + $row + (row);\n            } \n            else if (!isNaN(row)) {\n                return prefix + $row + (row);\n            } \n            else if (!isNaN(col)) {\n                return prefix + $col + chatatABC(col);\n            } \n            else {\n                return txt;\n            }\n        } \n        else {\n            rangetxt = rangetxt.split(\":\");\n            let row = [],\n                col = [];\n\n            row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, \"\"));\n            row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, \"\"));\n            if (row[0] > row[1]) {\n                return txt;\n            }\n            \n            col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, \"\"));\n            col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, \"\"));\n            if (col[0] > col[1]) {\n                return txt;\n            }\n\n            let freezonFuc0 = _this.isfreezonFuc(rangetxt[0]);\n            let freezonFuc1 = _this.isfreezonFuc(rangetxt[1]);\n            let $row0 = freezonFuc0[0] ? \"$\" : \"\",\n                $col0 = freezonFuc0[1] ? \"$\" : \"\";\n            let $row1 = freezonFuc1[0] ? \"$\" : \"\",\n                $col1 = freezonFuc1[1] ? \"$\" : \"\";\n            \n            if (orient == \"u\") {\n                if (!freezonFuc0[0]) {\n                    row[0] -= step;\n                }\n\n                if (!freezonFuc1[0]) {\n                    row[1] -= step;\n                }\n            } \n            else if (orient == \"r\") {\n                if (!freezonFuc0[1]) {\n                    col[0] += step;\n                }\n\n                if (!freezonFuc1[1]) {\n                    col[1] += step;\n                }\n            } \n            else if (orient == \"l\") {\n                if (!freezonFuc0[1]) {\n                    col[0] -= step;\n                }\n\n                if (!freezonFuc1[1]) {\n                    col[1] -= step;\n                }\n            } \n            else {\n                if (!freezonFuc0[0]) {\n                    row[0] += step;\n                }\n\n                if (!freezonFuc1[0]) {\n                    row[1] += step;\n                }\n            }\n\n            if(row[0] < 0 || col[0] < 0){\n                return _this.error.r;\n            }\n\n            if (isNaN(col[0]) && isNaN(col[1])) {\n                return prefix + $row0 + (row[0]) + \":\" + $row1 + (row[1]);\n            } \n            else if (isNaN(row[0]) && isNaN(row[1])) {\n                return prefix + $col0 + chatatABC(col[0]) + \":\" + $col1 + chatatABC(col[1]);\n            } \n            else {\n                return prefix + $col0 + chatatABC(col[0]) + $row0 + (row[0]) + \":\" + $col1 + chatatABC(col[1]) + $row1 + (row[1]);\n            }\n        }\n    }\n\n\n    static iscelldata(txt:string) { //判断是否为单元格格式\n        let val = txt.split(\"!\"),\n            rangetxt;\n\n        if (val.length > 1) {\n            rangetxt = val[1];\n        } \n        else {\n            rangetxt = val[0];\n        }\n\n        let reg_cell = /^(([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+))$/g; //增加正则判断单元格为字母+数字的格式：如 A1:B3\n        let reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+))))$/g; //增加正则判断单元格为字母+数字或字母的格式：如 A1:B3，A:A\n        \n        if (rangetxt.indexOf(\":\") == -1) {\n            let row = parseInt(rangetxt.replace(/[^0-9]/g, \"\")) - 1;\n            let col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, \"\"));\n            \n            if (!isNaN(row) && !isNaN(col) && rangetxt.toString().match(reg_cell)) {\n                return true;\n            } \n            else if (!isNaN(row)) {\n                return false;\n            } \n            else if (!isNaN(col)) {\n                return false;\n            } \n            else {\n                return false;\n            }\n        } \n        else {\n            reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+)))|((([0-9]+)|([$][0-9]+s))))$/g;\n\n            rangetxt = rangetxt.split(\":\");\n\n            let row = [],col = [];\n            row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, \"\")) - 1;\n            row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, \"\")) - 1;\n            if (row[0] > row[1]) {\n                return false;\n            }\n\n            col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, \"\"));\n            col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, \"\"));\n            if (col[0] > col[1]) {\n                return false;\n            }\n\n            if(rangetxt[0].toString().match(reg_cellRange) && rangetxt[1].toString().match(reg_cellRange)){\n                return true;\n            }\n            else{\n                return false;\n            }\n        }\n    }\n\n    static isfreezonFuc(txt:string) {\n        let row = txt.replace(/[^0-9]/g, \"\");\n        let col = txt.replace(/[^A-Za-z]/g, \"\");\n        let row$ = txt.substr(txt.indexOf(row) - 1, 1);\n        let col$ = txt.substr(txt.indexOf(col) - 1, 1);\n        let ret = [false, false];\n\n        if (row$ == \"$\") {\n            ret[0] = true;\n        }\n        if (col$ == \"$\") {\n            ret[1] = true;\n        }\n\n        return ret;\n    }\n\n}\n\n\n\nexport function isChinese(temp:string):boolean\n{ \n    var re = /[^\\u4e00-\\u9fa5]/; \n    var reg = /[\\u3002|\\uff1f|\\uff01|\\uff0c|\\u3001|\\uff1b|\\uff1a|\\u201c|\\u201d|\\u2018|\\u2019|\\uff08|\\uff09|\\u300a|\\u300b|\\u3008|\\u3009|\\u3010|\\u3011|\\u300e|\\u300f|\\u300c|\\u300d|\\ufe43|\\ufe44|\\u3014|\\u3015|\\u2026|\\u2014|\\uff5e|\\ufe4f|\\uffe5]/;\n    if(reg.test(temp)) return true; \n    if(re.test(temp)) return false; \n\treturn true; \n}\n \nexport function isJapanese(temp:string):boolean\n{ \n\tvar re = /[^\\u0800-\\u4e00]/; \n\tif(re.test(temp)) return false; \n\treturn true; \n}\n \nexport function isKoera(chr:any):boolean {\n\t\n\tif(((chr > 0x3130 && chr < 0x318F) || \n\t    (chr >= 0xAC00 && chr <= 0xD7A3))) \n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function isContainMultiType(str:string):boolean {\n\t\n    let isUnicode = false;\n    if(escape(str).indexOf(\"%u\")>-1){\n        isUnicode = true;\n    }\n\n    let isNot = false;\n    let reg = /[0-9a-z]/gi; \n    if(reg.test(str)){\n        isNot = true;\n    }\n\n    let reEnSign = /[\\x00-\\xff]+/g;\n    if(reEnSign.test(str)){\n        isNot = true;\n    }\n\n    if(isUnicode && isNot){\n        return true;\n    }\n\n    return false;\n\n}\n\n\n\n\n\n\n\n\nexport function getBinaryContent (path:any, options:any) {\n    let promise, resolve:any, reject:any;\n    let callback:any;\n\n    if (!options) {\n        options = {};\n    }\n\n    // taken from jQuery\n    let createStandardXHR = function () {\n        try {\n            return new window.XMLHttpRequest();\n        } catch( e ) {}\n    }\n\n    let createActiveXHR = function () {\n        try {\n            return new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n        } catch( e ) {}\n    }\n\n    // Create the request object\n    var createXHR = (typeof window !== \"undefined\" && window.ActiveXObject) ?\n        /* Microsoft failed to properly\n        * implement the XMLHttpRequest in IE7 (can't request local files),\n        * so we use the ActiveXObject when it is available\n        * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n        * we need a fallback.\n        */\n        function() {\n        return createStandardXHR() || createActiveXHR();\n    } :\n        // For all other browsers, use the standard XMLHttpRequest object\n        createStandardXHR;\n\n    // backward compatible callback\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    } else if (typeof options.callback === 'function') {\n        // callback inside options object\n        callback = options.callback;\n    }\n\n    resolve = function (data:any) { callback(null, data); };\n    reject = function (err:any) { callback(err, null); };\n\n    try {\n        var xhr = createXHR();\n\n        xhr.open('GET', path, true);\n\n        // recent browsers\n        if (\"responseType\" in xhr) {\n            xhr.responseType = \"arraybuffer\";\n        }\n\n        // older browser\n        if(xhr.overrideMimeType) {\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n        }\n\n        xhr.onreadystatechange = function (event:Event) {\n            // use `xhr` and not `this`... thanks IE\n            if (xhr.readyState === 4) {\n                if (xhr.status === 200 || xhr.status === 0) {\n                    try {\n                        resolve(function (xhr:XMLHttpRequest) {\n                            // for xhr.responseText, the 0xFF mask is applied by JSZip\n                            return xhr.response || xhr.responseText;\n                        }(xhr));\n                    } catch(err) {\n                        reject(new Error(err));\n                    }\n                } else {\n                    reject(new Error(\"Ajax error for \" + path + \" : \" + this.status + \" \" + this.statusText));\n                }\n            }\n        };\n\n        if(options.progress) {\n            xhr.onprogress = function(e:any) {\n                options.progress({\n                    path: path,\n                    originalEvent: e,\n                    percent: e.loaded / e.total * 100,\n                    loaded: e.loaded,\n                    total: e.total\n                });\n            };\n        }\n\n        xhr.send();\n\n    } catch (e) {\n        reject(new Error(e), null);\n    }\n\n    // returns a promise or undefined depending on whether a callback was\n    // provided\n    return promise;\n}","import { LuckyFile } from \"./ToLuckySheet/LuckyFile\";\n// import {SecurityDoor,Car} from './content';\n\nimport {HandleZip} from './HandleZip';\n\nimport {IuploadfileList} from \"./ICommon\";\nimport { LuckySheet } from \"./ToLuckySheet/LuckySheet\";\n\n//demo\nfunction demoHandler(){\n    let upload = document.getElementById(\"Luckyexcel-demo-file\");\n    let selectADemo = document.getElementById(\"Luckyexcel-select-demo\");\n    let downlodDemo = document.getElementById(\"Luckyexcel-downlod-file\");\n    let mask = document.getElementById(\"lucky-mask-demo\");\n    if(upload){\n        \n        window.onload = () => {\n            \n            upload.addEventListener(\"change\", function(evt){\n                var files:FileList = (evt.target as any).files;\n                if(files==null || files.length==0){\n                    alert(\"No files wait for import\");\n                    return;\n                }\n\n                let name = files[0].name;\n                let suffixArr = name.split(\".\"), suffix = suffixArr[suffixArr.length-1];\n                if(suffix!=\"xlsx\"){\n                    alert(\"Currently only supports the import of xlsx files\");\n                    return;\n                }\n                LuckyExcel.transformExcelToLucky(files[0], function(exportJson:any, luckysheetfile:string){\n                    \n                    if(exportJson.sheets==null || exportJson.sheets.length==0){\n                        alert(\"Failed to read the content of the excel file, currently does not support xls files!\");\n                        return;\n                    }\n                    console.log(exportJson, luckysheetfile);\n                    window.luckysheet.destroy();\n                    \n                    window.luckysheet.create({\n                        container: 'luckysheet', //luckysheet is the container id\n                        showinfobar:false,\n                        data:exportJson.sheets,\n                        title:exportJson.info.name,\n                        userInfo:exportJson.info.name.creator\n                    });\n                });\n            });\n\n            selectADemo.addEventListener(\"change\", function(evt){\n                var obj:any = selectADemo;\n                var index = obj.selectedIndex;\n                var value = obj.options[index].value;\n                var name = obj.options[index].innerHTML;\n                if(value==\"\"){\n                    return;\n                }\n                console.log('value :>> ', value);\n                mask.style.display = \"flex\";\n                LuckyExcel.transformExcelToLuckyByUrl(value, name, function(exportJson:any, luckysheetfile:string){\n                    \n                    if(exportJson.sheets==null || exportJson.sheets.length==0){\n                        alert(\"Failed to read the content of the excel file, currently does not support xls files!\");\n                        return;\n                    }\n                    console.log(exportJson, luckysheetfile);\n                    mask.style.display = \"none\";\n                    window.luckysheet.destroy();\n                    \n                    window.luckysheet.create({\n                        container: 'luckysheet', //luckysheet is the container id\n                        showinfobar:false,\n                        data:exportJson.sheets,\n                        title:exportJson.info.name,\n                        userInfo:exportJson.info.name.creator\n                    });\n                });\n            });\n\n            downlodDemo.addEventListener(\"click\", function(evt){\n                var obj:any = selectADemo;\n                var index = obj.selectedIndex;\n                var value = obj.options[index].value;\n\n                if(value.length==0){\n                    alert(\"Please select a demo file\");\n                    return;\n                }\n\n                var elemIF:any = document.getElementById(\"Lucky-download-frame\");\n                if(elemIF==null){\n                    elemIF = document.createElement(\"iframe\");\n                    elemIF.style.display = \"none\";\n                    elemIF.id = \"Lucky-download-frame\";\n                    document.body.appendChild(elemIF);\n                }\n                elemIF.src = value;\n\n                // elemIF.parentNode.removeChild(elemIF);\n            });\n        }\n    }\n}\ndemoHandler();\n\n// api\nexport class LuckyExcel{\n    static transformExcelToLucky(excelFile:File, callBack?:(files:IuploadfileList, fs?:string)=>void){\n        let handleZip:HandleZip = new HandleZip(excelFile);\n        handleZip.unzipFile(function(files:IuploadfileList){\n            let luckyFile = new LuckyFile(files, excelFile.name);\n            let luckysheetfile = luckyFile.Parse();\n            let exportJson = JSON.parse(luckysheetfile);\n            if(callBack != undefined){\n                callBack(exportJson, luckysheetfile);\n            }\n            \n        },\n        function(err:Error){\n            console.error(err);\n        });\n    }\n\n    static transformExcelToLuckyByUrl(url:string, name:string, callBack?:(files:IuploadfileList, fs?:string)=>void){\n        let handleZip:HandleZip = new HandleZip();\n        handleZip.unzipFileByUrl(url, function(files:IuploadfileList){\n            let luckyFile = new LuckyFile(files, name);\n            let luckysheetfile = luckyFile.Parse();\n            let exportJson = JSON.parse(luckysheetfile);\n            if(callBack != undefined){\n                callBack(exportJson, luckysheetfile);\n            }\n        },\n        function(err:Error){\n            console.error(err);\n        });\n    }\n\n    static transformLuckyToExcel(LuckyFile: any, callBack?: (files: string) => void) {\n        \n    }\n}\n\n\n\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbW1lZGlhdGUvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jb21wcmVzc2VkT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jb21wcmVzc2lvbnMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NyYzMyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZXh0ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2ZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9nZW5lcmF0ZS9aaXBGaWxlV29ya2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9nZW5lcmF0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2xvYWQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanNVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkYWJsZS1zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL0FycmF5UmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvRGF0YVJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL05vZGVCdWZmZXJSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9TdHJpbmdSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9VaW50OEFycmF5UmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvcmVhZGVyRm9yLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zaWduYXR1cmUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9Db252ZXJ0V29ya2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ3JjMzJQcm9iZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0RhdGFMZW5ndGhQcm9iZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0RhdGFXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9HZW5lcmljV29ya2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vU3RyZWFtSGVscGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdXBwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGY4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwRW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwRW50cnkuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcE9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9saWUvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NldC1pbW1lZGlhdGUtc2hpbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwic3JjL0hhbmRsZVppcC50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvTHVja3lCYXNlLnRzIiwic3JjL1RvTHVja3lTaGVldC9MdWNreUNlbGwudHMiLCJzcmMvVG9MdWNreVNoZWV0L0x1Y2t5RmlsZS50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvTHVja3lJbWFnZS50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvTHVja3lTaGVldC50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvUmVhZFhtbC50cyIsInNyYy9jb21tb24vY29uc3RhbnQudHMiLCJzcmMvY29tbW9uL2VtZi50cyIsInNyYy9jb21tb24vbWV0aG9kLnRzIiwic3JjL21haW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGhEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25FQSxJQUFBLE9BQUEsR0FBQSxlQUFBLENBQUEsT0FBQSxDQUFBLE9BQUEsQ0FBQSxDQUFBOztBQUVBLElBQUEsUUFBQSxHQUFBLE9BQUEsQ0FBQSxpQkFBQSxDQUFBOztB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QyxLQUFWLEVBQXJCO0FBQ0EsVUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxjQUFYLENBQWpCOztBQUNBLFVBQUcsUUFBUSxJQUFJLFNBQWYsRUFBeUI7QUFDckIsUUFBQSxRQUFRLENBQUMsVUFBRCxFQUFhLGNBQWIsQ0FBUjtBQUNIO0FBQ0osS0FQRCxFQVFBLFVBQVMsR0FBVCxFQUFrQjtBQUNkLE1BQUEsT0FBTyxDQUFDLEtBQVIsQ0FBYyxHQUFkO0FBQ0gsS0FWRDtBQVdILEdBYk07O0FBZUEsRUFBQSxVQUFBLENBQUEscUJBQUEsR0FBUCxVQUE2QixTQUE3QixFQUE2QyxRQUE3QyxFQUErRSxDQUU5RSxDQUZNOztBQUdYLFNBQUEsVUFBQTtBQUFDLENBbkNELEVBQUE7O0FBQWEsT0FBQSxDQUFBLFVBQUEsR0FBQSxVQUFBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGxcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgb2JqZWN0S2V5c1BvbHlmaWxsXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGZ1bmN0aW9uQmluZFBvbHlmaWxsXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX2V2ZW50cycpKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbnZhciBoYXNEZWZpbmVQcm9wZXJ0eTtcbnRyeSB7XG4gIHZhciBvID0ge307XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7XG4gIGhhc0RlZmluZVByb3BlcnR5ID0gby54ID09PSAwO1xufSBjYXRjaCAoZXJyKSB7IGhhc0RlZmluZVByb3BlcnR5ID0gZmFsc2UgfVxuaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgcG9zaXRpdmUgbnVtYmVyICh3aG9zZSB2YWx1ZSBpcyB6ZXJvIG9yXG4gICAgICAvLyBncmVhdGVyIGFuZCBub3QgYSBOYU4pLlxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVmYXVsdE1heExpc3RlbmVyc1wiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gZGVmYXVsdE1heExpc3RlbmVycztcbn1cblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnIFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0LicpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignJXM6ICVzJywgdy5uYW1lLCB3Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IGJpbmQuY2FsbChvbmNlV3JhcHBlciwgc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHtcbiAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzUG9seWZpbGwob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICBrZXlzLnB1c2goayk7XG4gIH1cbiAgcmV0dXJuIGs7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7XG4gIHZhciBmbiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxudmFyIHNjaGVkdWxlRHJhaW47XG5cbntcbiAgaWYgKE11dGF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKG5leHRUaWNrKTtcbiAgICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IG5leHRUaWNrO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiBnbG9iYWwgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljaygpO1xuXG4gICAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGljaywgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBpbnB1dC5sZW5ndGgsIHJlbWFpbmluZ0J5dGVzID0gbGVuO1xuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gbGVuIC0gaTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSByZW1haW5pbmdCeXRlcyA+IDEgPyAoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpIDogNjQ7XG4gICAgICAgIGVuYzQgPSByZW1haW5pbmdCeXRlcyA+IDIgPyAoY2hyMyAmIDYzKSA6IDY0O1xuXG4gICAgICAgIG91dHB1dC5wdXNoKF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGF0YVVybFByZWZpeCA9IFwiZGF0YTpcIjtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgZGF0YVVybFByZWZpeC5sZW5ndGgpID09PSBkYXRhVXJsUHJlZml4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb21tb24gZXJyb3I6IHBlb3BsZSBnaXZlIGEgZGF0YSB1cmxcbiAgICAgICAgLy8gKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUi4uLikgd2l0aCBhIHtiYXNlNjQ6IHRydWV9IGFuZFxuICAgICAgICAvLyB3b25kZXJzIHdoeSB0aGluZ3MgZG9uJ3Qgd29yay5cbiAgICAgICAgLy8gV2UgY2FuIGRldGVjdCB0aGF0IHRoZSBzdHJpbmcgaW5wdXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsIGJ1dCB3ZVxuICAgICAgICAvLyAqY2FuJ3QqIGJlIHN1cmUgaXQgaXMgb25lOiByZW1vdmluZyBldmVyeXRoaW5nIHVwIHRvIHRoZSBjb21tYSB3b3VsZFxuICAgICAgICAvLyBiZSB0b28gZGFuZ2Vyb3VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgaXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsLlwiKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlucHV0Lmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAyKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gdG90YWxMZW5ndGggaXMgbm90IGFuIGludGVnZXIsIHRoZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYSB2YWxpZFxuICAgICAgICAvLyBiYXNlNjQgY29udGVudC4gVGhhdCBjYW4gaGFwcGVuIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyBub3QgYSBiYXNlNjQgY29udGVudFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyAqYWxtb3N0KiBhIGJhc2U2NCBjb250ZW50LCB3aXRoIGEgZXh0cmEgY2hhcnMgYXQgdGhlXG4gICAgICAgIC8vICAgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgdXNlcyBhIGJhc2U2NCB2YXJpYW50IChiYXNlNjR1cmwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG5cbiAgICAgICAgZW5jMSA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIxO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciBEYXRhV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YVdvcmtlcicpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgRGF0YUxlbmd0aFByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50IGEgY29tcHJlc3NlZCBvYmplY3QsIHdpdGggZXZlcnl0aGluZyBuZWVkZWQgdG8gZGVjb21wcmVzcyBpdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGNvbXByZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdW5jb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBhZnRlciBkZWNvbXByZXNzaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGNyYzMyIHRoZSBjcmMzMiBvZiB0aGUgZGVjb21wcmVzc2VkIGZpbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcHJlc3Npb24gdGhlIHR5cGUgb2YgY29tcHJlc3Npb24sIHNlZSBsaWIvY29tcHJlc3Npb25zLmpzLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gQ29tcHJlc3NlZE9iamVjdChjb21wcmVzc2VkU2l6ZSwgdW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIsIGNvbXByZXNzaW9uLCBkYXRhKSB7XG4gICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHVuY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy5jcmMzMiA9IGNyYzMyO1xuICAgIHRoaXMuY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICB0aGlzLmNvbXByZXNzZWRDb250ZW50ID0gZGF0YTtcbn1cblxuQ29tcHJlc3NlZE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgdW5jb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50V29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAucGlwZSh0aGlzLmNvbXByZXNzaW9uLnVuY29tcHJlc3NXb3JrZXIoKSlcbiAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImRhdGFfbGVuZ3RoXCIpKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdvcmtlci5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZih0aGlzLnN0cmVhbUluZm9bJ2RhdGFfbGVuZ3RoJ10gIT09IHRoYXQudW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29tcHJlc3NlZFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3NlZFNpemVcIiwgdGhpcy5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwidW5jb21wcmVzc2VkU2l6ZVwiLCB0aGlzLnVuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsIHRoaXMuY3JjMzIpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIHRoaXMuY29tcHJlc3Npb24pXG4gICAgICAgIDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoYWluIHRoZSBnaXZlbiB3b3JrZXIgd2l0aCBvdGhlciB3b3JrZXJzIHRvIGNvbXByZXNzIHRoZSBjb250ZW50IHdpdGggdGhlXG4gKiBnaXZlbiBjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7R2VuZXJpY1dvcmtlcn0gdW5jb21wcmVzc2VkV29ya2VyIHRoZSB3b3JrZXIgdG8gcGlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSBuZXcgd29ya2VyIGNvbXByZXNzaW5nIHRoZSBjb250ZW50LlxuICovXG5Db21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20gPSBmdW5jdGlvbiAodW5jb21wcmVzc2VkV29ya2VyLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIHVuY29tcHJlc3NlZFdvcmtlclxuICAgIC5waXBlKG5ldyBDcmMzMlByb2JlKCkpXG4gICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcInVuY29tcHJlc3NlZFNpemVcIikpXG4gICAgLnBpcGUoY29tcHJlc3Npb24uY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb25PcHRpb25zKSlcbiAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwiY29tcHJlc3NlZFNpemVcIikpXG4gICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIiwgY29tcHJlc3Npb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wcmVzc2VkT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG5leHBvcnRzLlNUT1JFID0ge1xuICAgIG1hZ2ljOiBcIlxceDAwXFx4MDBcIixcbiAgICBjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uIChjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgY29tcHJlc3Npb25cIik7XG4gICAgfSxcbiAgICB1bmNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBkZWNvbXByZXNzaW9uXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkRFRkxBVEUgPSByZXF1aXJlKCcuL2ZsYXRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi96bGliL2NyYzMyLmpzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICAgIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gICAgZm9yKHZhciBuID0wOyBuIDwgMjU2OyBuKyspe1xuICAgICAgICBjID0gbjtcbiAgICAgICAgZm9yKHZhciBrID0wOyBrIDwgODsgaysrKXtcbiAgICAgICAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlW25dID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNyYzMyIG9mIGEgc3RyaW5nLlxuICogVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgdGhlIGZ1bmN0aW9uIGNyYzMyLCBidXQgZm9yIHN0cmluZ3MuIFVzaW5nIHRoZVxuICogc2FtZSBmdW5jdGlvbiBmb3IgdGhlIHR3byB1c2UgY2FzZXMgbGVhZHMgdG8gaG9ycmlibGUgcGVyZm9ybWFuY2VzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNyYyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGNyYy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgY3JjMzIgY29tcHV0YXRpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb21wdXRlZCBjcmMzMi5cbiAqL1xuZnVuY3Rpb24gY3JjMzJzdHIoY3JjLCBzdHIsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmMzMndyYXBwZXIoaW5wdXQsIGNyYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIgfHwgIWlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheSA9IHV0aWxzLmdldFR5cGVPZihpbnB1dCkgIT09IFwic3RyaW5nXCI7XG5cbiAgICBpZihpc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBjcmMzMihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyc3RyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0cy5iYXNlNjQgPSBmYWxzZTtcbmV4cG9ydHMuYmluYXJ5ID0gZmFsc2U7XG5leHBvcnRzLmRpciA9IGZhbHNlO1xuZXhwb3J0cy5jcmVhdGVGb2xkZXJzID0gdHJ1ZTtcbmV4cG9ydHMuZGF0ZSA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbDtcbmV4cG9ydHMuY29tbWVudCA9IG51bGw7XG5leHBvcnRzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG5leHBvcnRzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiIsIi8qIGdsb2JhbCBQcm9taXNlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIGxvYWQgdGhlIGdsb2JhbCBvYmplY3QgZmlyc3Q6XG4vLyAtIGl0IHNob3VsZCBiZSBiZXR0ZXIgaW50ZWdyYXRlZCBpbiB0aGUgc3lzdGVtICh1bmhhbmRsZWRSZWplY3Rpb24gaW4gbm9kZSlcbi8vIC0gdGhlIGVudmlyb25tZW50IG1heSBoYXZlIGEgY3VzdG9tIFByb21pc2UgaW1wbGVtZW50YXRpb24gKHNlZSB6b25lLmpzKVxudmFyIEVTNlByb21pc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgRVM2UHJvbWlzZSA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIEVTNlByb21pc2UgPSByZXF1aXJlKFwibGllXCIpO1xufVxuXG4vKipcbiAqIExldCB0aGUgdXNlciB1c2UvY2hhbmdlIHNvbWUgaW1wbGVtZW50YXRpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQcm9taXNlOiBFUzZQcm9taXNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVTRV9UWVBFREFSUkFZID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxudmFyIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxudmFyIEFSUkFZX1RZUEUgPSBVU0VfVFlQRURBUlJBWSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuXG5leHBvcnRzLm1hZ2ljID0gXCJcXHgwOFxceDAwXCI7XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRoYXQgdXNlcyBwYWtvIHRvIGluZmxhdGUvZGVmbGF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0aGUgbmFtZSBvZiB0aGUgcGFrbyBmdW5jdGlvbiB0byBjYWxsIDogZWl0aGVyIFwiRGVmbGF0ZVwiIG9yIFwiSW5mbGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gKGRlKWNvbXByZXNzaW5nLlxuICovXG5mdW5jdGlvbiBGbGF0ZVdvcmtlcihhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJGbGF0ZVdvcmtlci9cIiArIGFjdGlvbik7XG5cbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbiAgICB0aGlzLl9wYWtvQWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuX3Bha29PcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB0aGUgYG1ldGFgIG9iamVjdCBmcm9tIHRoZSBsYXN0IGNodW5rIHJlY2VpdmVkXG4gICAgLy8gdGhpcyBhbGxvdyB0aGlzIHdvcmtlciB0byBwYXNzIGFyb3VuZCBtZXRhZGF0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xufVxuXG51dGlscy5pbmhlcml0cyhGbGF0ZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5tZXRhID0gY2h1bmsubWV0YTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaCh1dGlscy50cmFuc2Zvcm1UbyhBUlJBWV9UWVBFLCBjaHVuay5kYXRhKSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2goW10sIHRydWUpO1xufTtcbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Bha28gPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIF9wYWtvIG9iamVjdC5cbiAqIFRPRE86IGxhenktbG9hZGluZyB0aGlzIG9iamVjdCBpc24ndCB0aGUgYmVzdCBzb2x1dGlvbiBidXQgaXQncyB0aGVcbiAqIHF1aWNrZXN0LiBUaGUgYmVzdCBzb2x1dGlvbiBpcyB0byBsYXp5LWxvYWQgdGhlIHdvcmtlciBsaXN0LiBTZWUgYWxzbyB0aGVcbiAqIGlzc3VlICM0NDYuXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5fY3JlYXRlUGFrbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYWtvID0gbmV3IHBha29bdGhpcy5fcGFrb0FjdGlvbl0oe1xuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGxldmVsOiB0aGlzLl9wYWtvT3B0aW9ucy5sZXZlbCB8fCAtMSAvLyBkZWZhdWx0IGNvbXByZXNzaW9uXG4gICAgfSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3Bha28ub25EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDogc2VsZi5tZXRhXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5leHBvcnRzLmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJEZWZsYXRlXCIsIGNvbXByZXNzaW9uT3B0aW9ucyk7XG59O1xuZXhwb3J0cy51bmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJJbmZsYXRlXCIsIHt9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4uL3V0ZjgnKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgc2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIHN0cmluZyBpbiBoZXhhZGVjaW1hbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjIHRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xudmFyIGRlY1RvSGV4ID0gZnVuY3Rpb24oZGVjLCBieXRlcykge1xuICAgIHZhciBoZXggPSBcIlwiLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICAgIGhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyAmIDB4ZmYpO1xuICAgICAgICBkZWMgPSBkZWMgPj4+IDg7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBVTklYIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1bml4UGVybWlzc2lvbnMgdGhlIHVuaXggcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE0NzA1L3RoZS16aXAtZm9ybWF0cy1leHRlcm5hbC1maWxlLWF0dHJpYnV0ZSA6XG4gKlxuICogVFRUVHNzdHJ3eHJ3eHJ3eDAwMDAwMDAwMDBBRFZTSFJcbiAqIF5eXl5fX19fX19fX19fX19fX19fX19fX19fX19fX19fIGZpbGUgdHlwZSwgc2VlIHppcGluZm8uYyAoVU5YXyopXG4gKiAgICAgXl5eX19fX19fX19fX19fX19fX19fX19fX19fXyBzZXR1aWQsIHNldGdpZCwgc3RpY2t5XG4gKiAgICAgICAgXl5eXl5eXl5eX19fX19fX19fX19fX19fXyBwZXJtaXNzaW9uc1xuICogICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5fX19fX18gbm90IHVzZWQgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl4gRE9TIGF0dHJpYnV0ZSBiaXRzIDogQXJjaGl2ZSwgRGlyZWN0b3J5LCBWb2x1bWUgbGFiZWwsIFN5c3RlbSBmaWxlLCBIaWRkZW4sIFJlYWQgb25seVxuICovXG52YXIgZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uICh1bml4UGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdW5peFBlcm1pc3Npb25zO1xuICAgIGlmICghdW5peFBlcm1pc3Npb25zKSB7XG4gICAgICAgIC8vIEkgY2FuJ3QgdXNlIG9jdGFsIHZhbHVlcyBpbiBzdHJpY3QgbW9kZSwgaGVuY2UgdGhlIGhleGEuXG4gICAgICAgIC8vICAwNDA3NzUgPT4gMHg0MWZkXG4gICAgICAgIC8vIDAxMDA2NjQgPT4gMHg4MWI0XG4gICAgICAgIHJlc3VsdCA9IGlzRGlyID8gMHg0MWZkIDogMHg4MWI0O1xuICAgIH1cbiAgICByZXR1cm4gKHJlc3VsdCAmIDB4RkZGRikgPDwgMTY7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBET1MgcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGRvc1Blcm1pc3Npb25zIHRoZSBkb3MgcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBCaXQgMCAgICAgUmVhZC1Pbmx5XG4gKiBCaXQgMSAgICAgSGlkZGVuXG4gKiBCaXQgMiAgICAgU3lzdGVtXG4gKiBCaXQgMyAgICAgVm9sdW1lIExhYmVsXG4gKiBCaXQgNCAgICAgRGlyZWN0b3J5XG4gKiBCaXQgNSAgICAgQXJjaGl2ZVxuICovXG52YXIgZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKGRvc1Blcm1pc3Npb25zLCBpc0Rpcikge1xuXG4gICAgLy8gdGhlIGRpciBmbGFnIGlzIGFscmVhZHkgc2V0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIChkb3NQZXJtaXNzaW9ucyB8fCAwKSAgJiAweDNGO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdmFyaW91cyBwYXJ0cyB1c2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZpbmFsIHppcCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1lZENvbnRlbnQgaXMgdGhlIGNvbnRlbnQgc3RyZWFtZWQgP1xuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1pbmdFbmRlZCBpcyB0aGUgc3RyZWFtIGZpbmlzaGVkID9cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgc3RyZWFtaW5nRW5kZWQsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGUgPSBzdHJlYW1JbmZvWydmaWxlJ10sXG4gICAgY29tcHJlc3Npb24gPSBzdHJlYW1JbmZvWydjb21wcmVzc2lvbiddLFxuICAgIHVzZUN1c3RvbUVuY29kaW5nID0gZW5jb2RlRmlsZU5hbWUgIT09IHV0ZjgudXRmOGVuY29kZSxcbiAgICBlbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShmaWxlLm5hbWUpKSxcbiAgICB1dGZFbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoZmlsZS5uYW1lKSksXG4gICAgY29tbWVudCA9IGZpbGUuY29tbWVudCxcbiAgICBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKSxcbiAgICB1dGZFbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShjb21tZW50KSksXG4gICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICB1c2VVVEY4Rm9yQ29tbWVudCA9IHV0ZkVuY29kZWRDb21tZW50Lmxlbmd0aCAhPT0gY29tbWVudC5sZW5ndGgsXG4gICAgZG9zVGltZSxcbiAgICBkb3NEYXRlLFxuICAgIGV4dHJhRmllbGRzID0gXCJcIixcbiAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgZGlyID0gZmlsZS5kaXIsXG4gICAgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuXG4gICAgdmFyIGRhdGFJbmZvID0ge1xuICAgICAgICBjcmMzMiA6IDAsXG4gICAgICAgIGNvbXByZXNzZWRTaXplIDogMCxcbiAgICAgICAgdW5jb21wcmVzc2VkU2l6ZSA6IDBcbiAgICB9O1xuXG4gICAgLy8gaWYgdGhlIGNvbnRlbnQgaXMgc3RyZWFtZWQsIHRoZSBzaXplcy9jcmMzMiBhcmUgb25seSBhdmFpbGFibGUgQUZURVJcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFzdHJlYW1lZENvbnRlbnQgfHwgc3RyZWFtaW5nRW5kZWQpIHtcbiAgICAgICAgZGF0YUluZm8uY3JjMzIgPSBzdHJlYW1JbmZvWydjcmMzMiddO1xuICAgICAgICBkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSA9IHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ107XG4gICAgICAgIGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ107XG4gICAgfVxuXG4gICAgdmFyIGJpdGZsYWcgPSAwO1xuICAgIGlmIChzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gQml0IDM6IHRoZSBzaXplcy9jcmMzMiBhcmUgc2V0IHRvIHplcm8gaW4gdGhlIGxvY2FsIGhlYWRlci5cbiAgICAgICAgLy8gVGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBwdXQgaW4gdGhlIGRhdGEgZGVzY3JpcHRvciBpbW1lZGlhdGVseVxuICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDAwMDg7XG4gICAgfVxuICAgIGlmICghdXNlQ3VzdG9tRW5jb2RpbmcgJiYgKHVzZVVURjhGb3JGaWxlTmFtZSB8fCB1c2VVVEY4Rm9yQ29tbWVudCkpIHtcbiAgICAgICAgLy8gQml0IDExOiBMYW5ndWFnZSBlbmNvZGluZyBmbGFnIChFRlMpLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDgwMDtcbiAgICB9XG5cblxuICAgIHZhciBleHRGaWxlQXR0ciA9IDA7XG4gICAgdmFyIHZlcnNpb25NYWRlQnkgPSAwO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgLy8gZG9zIG9yIHVuaXgsIHdlIHNldCB0aGUgZG9zIGRpciBmbGFnXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IDB4MDAwMTA7XG4gICAgfVxuICAgIGlmKHBsYXRmb3JtID09PSBcIlVOSVhcIikge1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMzFFOyAvLyBVTklYLCB2ZXJzaW9uIDMuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyKGZpbGUudW5peFBlcm1pc3Npb25zLCBkaXIpO1xuICAgIH0gZWxzZSB7IC8vIERPUyBvciBvdGhlciwgZmFsbGJhY2sgdG8gRE9TXG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAwMTQ7IC8vIERPUywgdmVyc2lvbiAyLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyKGZpbGUuZG9zUGVybWlzc2lvbnMsIGRpcik7XG4gICAgfVxuXG4gICAgLy8gZGF0ZVxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC81Mi8xMy5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY1LzE2Lmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjYvMTYuaHRtbFxuXG4gICAgZG9zVGltZSA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA2O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDU2Vjb25kcygpIC8gMjtcblxuICAgIGRvc0RhdGUgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDQ7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgaWYgKHVzZVVURjhGb3JGaWxlTmFtZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC4gdW56aXAgbmVlZHMgYXQgbGVhc3Qgb25lIGV4dHJhXG4gICAgICAgIC8vIGZpZWxkIHRvIGNvcnJlY3RseSBoYW5kbGUgdW5pY29kZSBwYXRoLCBzbyB1c2luZyB0aGUgcGF0aCBpcyBhcyBnb29kXG4gICAgICAgIC8vIGFzIGFueSBvdGhlciBpbmZvcm1hdGlvbi4gVGhpcyBjb3VsZCBpbXByb3ZlIHRoZSBzaXR1YXRpb24gd2l0aFxuICAgICAgICAvLyBvdGhlciBhcmNoaXZlIG1hbmFnZXJzIHRvby5cbiAgICAgICAgLy8gVGhpcyBmaWVsZCBpcyB1c3VhbGx5IHVzZWQgd2l0aG91dCB0aGUgdXRmOCBmbGFnLCB3aXRoIGEgbm9uXG4gICAgICAgIC8vIHVuaWNvZGUgcGF0aCBpbiB0aGUgaGVhZGVyICh3aW5yYXIsIHdpbnppcCkuIFRoaXMgaGVscHMgKGEgYml0KVxuICAgICAgICAvLyB3aXRoIHRoZSBtZXNzeSBXaW5kb3dzJyBkZWZhdWx0IGNvbXByZXNzZWQgZm9sZGVycyBmZWF0dXJlIGJ1dFxuICAgICAgICAvLyBicmVha3Mgb24gcDd6aXAgd2hpY2ggZG9lc24ndCBzZWVrIHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuXG4gICAgICAgIC8vIFNvIGZvciBub3csIFVURi04IGV2ZXJ5d2hlcmUgIVxuICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gTmFtZUNSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkRmlsZU5hbWUpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZEZpbGVOYW1lO1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg3MFwiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVQYXRoRXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICBpZih1c2VVVEY4Rm9yQ29tbWVudCkge1xuXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBDb21tZW50Q1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRDb21tZW50KSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRDb21tZW50O1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg2M1wiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyID0gXCJcIjtcblxuICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBoZWFkZXIgKz0gXCJcXHgwQVxceDAwXCI7XG4gICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGJpdGZsYWcsIDIpO1xuICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIGhlYWRlciArPSBjb21wcmVzc2lvbi5tYWdpYztcbiAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zVGltZSwgMik7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSBkYXRlXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc0RhdGUsIDIpO1xuICAgIC8vIGNyYy0zMlxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jcmMzMiwgNCk7XG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby51bmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyBmaWxlIG5hbWUgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGVuY29kZWRGaWxlTmFtZS5sZW5ndGgsIDIpO1xuICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChleHRyYUZpZWxkcy5sZW5ndGgsIDIpO1xuXG5cbiAgICB2YXIgZmlsZVJlY29yZCA9IHNpZ25hdHVyZS5MT0NBTF9GSUxFX0hFQURFUiArIGhlYWRlciArIGVuY29kZWRGaWxlTmFtZSArIGV4dHJhRmllbGRzO1xuXG4gICAgdmFyIGRpclJlY29yZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0ZJTEVfSEVBREVSICtcbiAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5ICgwMDogRE9TKVxuICAgICAgICBkZWNUb0hleCh2ZXJzaW9uTWFkZUJ5LCAyKSArXG4gICAgICAgIC8vIGZpbGUgaGVhZGVyIChjb21tb24gdG8gZmlsZSBhbmQgY2VudHJhbCBkaXJlY3RvcnkpXG4gICAgICAgIGhlYWRlciArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIFRPRE9cbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgZGVjVG9IZXgoZXh0RmlsZUF0dHIsIDQpICtcbiAgICAgICAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICAgICAgICBkZWNUb0hleChvZmZzZXQsIDQpICtcbiAgICAgICAgLy8gZmlsZSBuYW1lXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSArXG4gICAgICAgIC8vIGV4dHJhIGZpZWxkXG4gICAgICAgIGV4dHJhRmllbGRzICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVJlY29yZDogZmlsZVJlY29yZCxcbiAgICAgICAgZGlyUmVjb3JkOiBkaXJSZWNvcmRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRU9DRCByZWNvcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gZW50cmllc0NvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2VudHJhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGNlbnRyYWwgZGlyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvY2FsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgbG9jYWwgZGlyLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIHppcCBmaWxlIGNvbW1lbnQgYXMgYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgY29tbWVudC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIEVPQ0QgcmVjb3JkLlxuICovXG52YXIgZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kID0gZnVuY3Rpb24gKGVudHJpZXNDb3VudCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIGNvbW1lbnQsIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGRpckVuZCA9IFwiXCI7XG4gICAgdmFyIGVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoY29tbWVudCkpO1xuXG4gICAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZVxuICAgIGRpckVuZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhpcyBkaXNrXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2tcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KGNlbnRyYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICAgICAgZGVjVG9IZXgobG9jYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiBkaXJFbmQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGRhdGEgZGVzY3JpcHRvcnMgZm9yIGEgZmlsZSBlbnRyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIGdlbmVyYXRlZCBieSBhIHdvcmtlciwgY29udGFpbmluZyBpbmZvcm1hdGlvblxuICogb24gdGhlIGZpbGUgZW50cnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkYXRhIGRlc2NyaXB0b3JzLlxuICovXG52YXIgZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMgPSBmdW5jdGlvbiAoc3RyZWFtSW5mbykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gXCJcIjtcbiAgICBkZXNjcmlwdG9yID0gc2lnbmF0dXJlLkRBVEFfREVTQ1JJUFRPUiArXG4gICAgICAgIC8vIGNyYy0zMiAgICAgICAgICAgICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvWydjcmMzMiddLCA0KSArXG4gICAgICAgIC8vIGNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvWydjb21wcmVzc2VkU2l6ZSddLCA0KSArXG4gICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ10sIDQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG5cbi8qKlxuICogQSB3b3JrZXIgdG8gY29uY2F0ZW5hdGUgb3RoZXIgd29ya2VycyB0byBjcmVhdGUgYSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtRmlsZXMgYHRydWVgIHRvIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMsXG4gKiBgZmFsc2VgIHRvIGFjY3VtdWxhdGUgaXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgY29tbWVudCB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhdGZvcm0gdGhlIHBsYXRmb3JtIHRvIHVzZSwgXCJVTklYXCIgb3IgXCJET1NcIi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgZmlsZSBuYW1lcyBhbmQgY29tbWVudHMuXG4gKi9cbmZ1bmN0aW9uIFppcEZpbGVXb3JrZXIoc3RyZWFtRmlsZXMsIGNvbW1lbnQsIHBsYXRmb3JtLCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIlppcEZpbGVXb3JrZXJcIik7XG4gICAgLy8gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIHNvIGZhci4gVGhpcyBkb2Vzbid0IGNvdW50IGFjY3VtdWxhdGVkIGNodW5rcy5cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG4gICAgLy8gVGhlIGNvbW1lbnQgb2YgdGhlIHppcCBmaWxlXG4gICAgdGhpcy56aXBDb21tZW50ID0gY29tbWVudDtcbiAgICAvLyBUaGUgcGxhdGZvcm0gXCJnZW5lcmF0aW5nXCIgdGhlIHppcCBmaWxlLlxuICAgIHRoaXMuemlwUGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAvLyB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICAgIHRoaXMuZW5jb2RlRmlsZU5hbWUgPSBlbmNvZGVGaWxlTmFtZTtcbiAgICAvLyBTaG91bGQgd2Ugc3RyZWFtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlcyA/XG4gICAgdGhpcy5zdHJlYW1GaWxlcyA9IHN0cmVhbUZpbGVzO1xuICAgIC8vIElmIGBzdHJlYW1GaWxlc2AgaXMgZmFsc2UsIHdlIHdpbGwgbmVlZCB0byBhY2N1bXVsYXRlIHRoZSBjb250ZW50IG9mIHRoZVxuICAgIC8vIGZpbGVzIHRvIGNhbGN1bGF0ZSBzaXplcyAvIGNyYzMyIChhbmQgd3JpdGUgdGhlbSAqYmVmb3JlKiB0aGUgY29udGVudCkuXG4gICAgLy8gVGhpcyBib29sZWFuIGluZGljYXRlcyBpZiB3ZSBhcmUgYWNjdW11bGF0aW5nIGNodW5rcyAoaXQgd2lsbCBjaGFuZ2UgYSBsb3RcbiAgICAvLyBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIHRoaXMgd29ya2VyKS5cbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICAvLyBUaGUgYnVmZmVyIHJlY2VpdmluZyBjaHVua3Mgd2hlbiBhY2N1bXVsYXRpbmcgY29udGVudC5cbiAgICB0aGlzLmNvbnRlbnRCdWZmZXIgPSBbXTtcbiAgICAvLyBUaGUgbGlzdCBvZiBnZW5lcmF0ZWQgZGlyZWN0b3J5IHJlY29yZHMuXG4gICAgdGhpcy5kaXJSZWNvcmRzID0gW107XG4gICAgLy8gVGhlIG9mZnNldCAoaW4gYnl0ZXMpIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgemlwIGZpbGUgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSAwO1xuICAgIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHppcCBmaWxlLlxuICAgIHRoaXMuZW50cmllc0NvdW50ID0gMDtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBjdXJyZW50bHkgYmVpbmcgYWRkZWQsIG51bGwgd2hlbiBoYW5kbGluZyB0aGUgZW5kIG9mIHRoZSB6aXAgZmlsZS5cbiAgICAvLyBVc2VkIGZvciB0aGUgZW1pdHRlZCBtZXRhZGF0YS5cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcblxuXG5cbiAgICB0aGlzLl9zb3VyY2VzID0gW107XG59XG51dGlscy5pbmhlcml0cyhaaXBGaWxlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgY3VycmVudEZpbGVQZXJjZW50ID0gY2h1bmsubWV0YS5wZXJjZW50IHx8IDA7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IHRoaXMuZW50cmllc0NvdW50O1xuICAgIHZhciByZW1haW5pbmdGaWxlcyA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuXG4gICAgaWYodGhpcy5hY2N1bXVsYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGVudEJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBjaHVuay5kYXRhLmxlbmd0aDtcblxuICAgICAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZGF0YSA6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlIDogdGhpcy5jdXJyZW50RmlsZSxcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogZW50cmllc0NvdW50ID8gKGN1cnJlbnRGaWxlUGVyY2VudCArIDEwMCAqIChlbnRyaWVzQ291bnQgLSByZW1haW5pbmdGaWxlcyAtIDEpKSAvIGVudHJpZXNDb3VudCA6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgc3RhcnRlZCBhIG5ldyBzb3VyY2UgKGFuIG90aGVyIHdvcmtlcikuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgc3RyZWFtSW5mbyBvYmplY3QgZnJvbSB0aGUgbmV3IHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUub3BlbmVkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLm5hbWU7XG5cbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcblxuICAgIC8vIGRvbid0IHN0cmVhbSBmb2xkZXJzIChiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgY29udGVudClcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZSBmaWxlIGJlZm9yZSBwdXNoaW5nIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIGZpbmlzaGVkIGEgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIGZpbmlzaGVkIHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcbiAgICB2YXIgcmVjb3JkID0gZ2VuZXJhdGVaaXBQYXJ0cyhzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHRydWUsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLmRpclJlY29yZHMucHVzaChyZWNvcmQuZGlyUmVjb3JkKTtcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIHN0cmVhbWVkIGZpbGUsIHdlIHB1dCBkYXRhIGRlc2NyaXB0b3JzXG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMoc3RyZWFtSW5mbyksXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGVudCB3YXNuJ3Qgc3RyZWFtZWQsIHdlIG5lZWQgdG8gcHVzaCBldmVyeXRoaW5nIG5vd1xuICAgICAgICAvLyBmaXJzdCB0aGUgZmlsZSByZWNvcmQsIHRoZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUodGhpcy5jb250ZW50QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxvY2FsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHRoaXMuZGlyUmVjb3Jkc1tpXSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgY2VudHJhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuIC0gbG9jYWxEaXJMZW5ndGg7XG5cbiAgICB2YXIgZGlyRW5kID0gZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kKHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCB0aGlzLnppcENvbW1lbnQsIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGRpckVuZCxcbiAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgbmV4dCBzb3VyY2UgdG8gYmUgcmVhZC5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHJlcGFyZU5leHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuX3NvdXJjZXMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlZ2lzdGVyUHJldmlvdXNcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVnaXN0ZXJQcmV2aW91cyA9IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgIHRoaXMuX3NvdXJjZXMucHVzaChwcmV2aW91cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJldmlvdXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkU291cmNlKHNlbGYucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgICAgIGlmKHNlbGYuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgdGhpcy5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmICF0aGlzLl9zb3VyY2VzLmxlbmd0aCAmJiAhdGhpcy5nZW5lcmF0ZWRFcnJvcikge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5lcnJvclxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvdXJjZXNbaV0uZXJyb3IoZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gdGhlIGBlcnJvcmAgZXhwbG9kZWQsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmxvY2tcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5sb2NrLmNhbGwodGhpcyk7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbaV0ubG9jaygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwRmlsZVdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4uL2NvbXByZXNzaW9ucycpO1xudmFyIFppcEZpbGVXb3JrZXIgPSByZXF1aXJlKCcuL1ppcEZpbGVXb3JrZXInKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb21wcmVzc2lvbiB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZUNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBmaWxlIGxldmVsLCBpZiBhbnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gemlwQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGxvYWQoKSBsZXZlbC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gKi9cbnZhciBnZXRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWxlQ29tcHJlc3Npb24sIHppcENvbXByZXNzaW9uKSB7XG5cbiAgICB2YXIgY29tcHJlc3Npb25OYW1lID0gZmlsZUNvbXByZXNzaW9uIHx8IHppcENvbXByZXNzaW9uO1xuICAgIHZhciBjb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uc1tjb21wcmVzc2lvbk5hbWVdO1xuICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXByZXNzaW9uTmFtZSArIFwiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcHJlc3Npb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0byBnZW5lcmF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtKU1ppcH0gemlwIHRoZSBKU1ppcCBpbnN0YW5jZSBhdCB0aGUgcmlnaHQgcm9vdCBsZXZlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZVdvcmtlciA9IGZ1bmN0aW9uICh6aXAsIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIHZhciB6aXBGaWxlV29ya2VyID0gbmV3IFppcEZpbGVXb3JrZXIob3B0aW9ucy5zdHJlYW1GaWxlcywgY29tbWVudCwgb3B0aW9ucy5wbGF0Zm9ybSwgb3B0aW9ucy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IDA7XG4gICAgdHJ5IHtcblxuICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICBlbnRyaWVzQ291bnQrKztcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uKGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbiwgb3B0aW9ucy5jb21wcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb25PcHRpb25zID0gZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkaXIgPSBmaWxlLmRpciwgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuICAgICAgICAgICAgZmlsZS5fY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucylcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImZpbGVcIiwge1xuICAgICAgICAgICAgICAgIG5hbWUgOiByZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgICAgICAgZGlyIDogZGlyLFxuICAgICAgICAgICAgICAgIGRhdGUgOiBkYXRlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBmaWxlLmNvbW1lbnQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBmaWxlLnVuaXhQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9ucyA6IGZpbGUuZG9zUGVybWlzc2lvbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZSh6aXBGaWxlV29ya2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZW50cmllc0NvdW50ID0gZW50cmllc0NvdW50O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gemlwRmlsZVdvcmtlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gYSBvZiB6aXAgZmlsZSBpbiBqc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEpTWmlwKCkge1xuICAgIC8vIGlmIHRoaXMgY29uc3RydWN0b3IgaXPCoHVzZWQgd2l0aG91dMKgYG5ld2AsIGl0wqBhZGRzIGBuZXdgIGJlZm9yZcKgaXRzZWxmOlxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIEpTWmlwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEpTWmlwKCk7XG4gICAgfVxuXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH1cblxuICAgIC8vIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyA6XG4gICAgLy8ge1xuICAgIC8vICAgXCJmb2xkZXIvXCIgOiB7Li4ufSxcbiAgICAvLyAgIFwiZm9sZGVyL2RhdGEudHh0XCIgOiB7Li4ufVxuICAgIC8vIH1cbiAgICB0aGlzLmZpbGVzID0ge307XG5cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLy8gV2hlcmUgd2UgYXJlIGluIHRoZSBoaWVyYXJjaHlcbiAgICB0aGlzLnJvb3QgPSBcIlwiO1xuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gdGhpc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH07XG59XG5KU1ppcC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL29iamVjdCcpO1xuSlNaaXAucHJvdG90eXBlLmxvYWRBc3luYyA9IHJlcXVpcmUoJy4vbG9hZCcpO1xuSlNaaXAuc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuSlNaaXAuZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8vIFRPRE8gZmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMgdmVyc2lvbixcbi8vIGEgcmVxdWlyZSgncGFja2FnZS5qc29uJykudmVyc2lvbiBkb2Vzbid0IHdvcmsgd2l0aCB3ZWJwYWNrLCBzZWUgIzMyN1xuSlNaaXAudmVyc2lvbiA9IFwiMy41LjBcIjtcblxuSlNaaXAubG9hZEFzeW5jID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpTWmlwKCkubG9hZEFzeW5jKGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuSlNaaXAuZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbm1vZHVsZS5leHBvcnRzID0gSlNaaXA7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgWmlwRW50cmllcyA9IHJlcXVpcmUoJy4vemlwRW50cmllcycpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcblxuLyoqXG4gKiBDaGVjayB0aGUgQ1JDMzIgb2YgYW4gZW50cnkuXG4gKiBAcGFyYW0ge1ppcEVudHJ5fSB6aXBFbnRyeSB0aGUgemlwIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFbnRyeUNSQzMyKHppcEVudHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHppcEVudHJ5LmRlY29tcHJlc3NlZC5nZXRDb250ZW50V29ya2VyKCkucGlwZShuZXcgQ3JjMzJQcm9iZSgpKTtcbiAgICAgICAgd29ya2VyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3b3JrZXIuc3RyZWFtSW5mby5jcmMzMiAhPT0gemlwRW50cnkuZGVjb21wcmVzc2VkLmNyYzMyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgemlwID0gdGhpcztcbiAgICBvcHRpb25zID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICAgICAgY2hlY2tDUkMzMjogZmFsc2UsXG4gICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogZmFsc2UsXG4gICAgICAgIGNyZWF0ZUZvbGRlcnM6IGZhbHNlLFxuICAgICAgICBkZWNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZGVjb2RlXG4gICAgfSk7XG5cbiAgICBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJKU1ppcCBjYW4ndCBhY2NlcHQgYSBzdHJlYW0gd2hlbiBsb2FkaW5nIGEgemlwIGZpbGUuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMucHJlcGFyZUNvbnRlbnQoXCJ0aGUgbG9hZGVkIHppcCBmaWxlXCIsIGRhdGEsIHRydWUsIG9wdGlvbnMub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvcHRpb25zLmJhc2U2NClcbiAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gbmV3IFppcEVudHJpZXMob3B0aW9ucyk7XG4gICAgICAgIHppcEVudHJpZXMubG9hZChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHppcEVudHJpZXM7XG4gICAgfSkudGhlbihmdW5jdGlvbiBjaGVja0NSQzMyKHppcEVudHJpZXMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW2V4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBFbnRyaWVzKV07XG4gICAgICAgIHZhciBmaWxlcyA9IHppcEVudHJpZXMuZmlsZXM7XG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrQ1JDMzIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoZWNrRW50cnlDUkMzMihmaWxlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiBhZGRGaWxlcyhyZXN1bHRzKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gcmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIHppcC5maWxlKGlucHV0LmZpbGVOYW1lU3RyLCBpbnB1dC5kZWNvbXByZXNzZWQsIHtcbiAgICAgICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0LmRhdGUsXG4gICAgICAgICAgICAgICAgZGlyOiBpbnB1dC5kaXIsXG4gICAgICAgICAgICAgICAgY29tbWVudCA6IGlucHV0LmZpbGVDb21tZW50U3RyLmxlbmd0aCA/IGlucHV0LmZpbGVDb21tZW50U3RyIDogbnVsbCxcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBpbnB1dC51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBpbnB1dC5kb3NQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBvcHRpb25zLmNyZWF0ZUZvbGRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6aXBFbnRyaWVzLnppcENvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB6aXAuY29tbWVudCA9IHppcEVudHJpZXMuemlwQ29tbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB6aXA7XG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCB1c2UgYSBub2RlanMgc3RyZWFtIGFzIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGVudHJ5IGZvciB0aGlzIHN0cmVhbS5cbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSB0aGUgbm9kZWpzIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKGZpbGVuYW1lLCBzdHJlYW0pIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJOb2RlanMgc3RyZWFtIGlucHV0IGFkYXB0ZXIgZm9yIFwiICsgZmlsZW5hbWUpO1xuICAgIHRoaXMuX3Vwc3RyZWFtRW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9iaW5kU3RyZWFtKHN0cmVhbSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgc3RyZWFtIGFuZCBiaW5kIHRoZSBjYWxsYmFja3Mgb24gaXQuXG4gKiBEbyB0aGlzIEFTQVAgb24gbm9kZSAwLjEwICEgQSBsYXp5IGJpbmRpbmcgZG9lc24ndCBhbHdheXMgd29yay5cbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0gdG8gdXNlLlxuICovXG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLl9iaW5kU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgc3RyZWFtXG4gICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdXBzdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucGF1c2UuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbS5wYXVzZSgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy5fdXBzdHJlYW1FbmRlZCkge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIsIFJlYWRhYmxlKTtcblxuLyoqXG4qIEEgbm9kZWpzIHN0cmVhbSB1c2luZyBhIHdvcmtlciBhcyBzb3VyY2UuXG4qIEBzZWUgdGhlIFNvdXJjZVdyYXBwZXIgaW4gaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgd3JhcHBpbmcgdGhlIHdvcmtlclxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgbm9kZWpzIHN0cmVhbSBvcHRpb25zXG4qIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4qL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcihoZWxwZXIsIG9wdGlvbnMsIHVwZGF0ZUNiKSB7XG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9oZWxwZXIgPSBoZWxwZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaGVscGVyLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICBpZiAoIXNlbGYucHVzaChkYXRhKSkge1xuICAgICAgICAgICAgc2VsZi5faGVscGVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodXBkYXRlQ2IpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNiKG1ldGEpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICB9KTtcbn1cblxuXG5Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hlbHBlci5yZXN1bWUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGlzIGlzIHJ1bm5pbmcgaW4gTm9kZWpzLCB3aWxsIGJlIHVuZGVmaW5lZCBpbiBhIGJyb3dzZXIuXG4gICAgICogSW4gYSBicm93c2VyLCBicm93c2VyaWZ5IHdvbid0IGluY2x1ZGUgdGhpcyBmaWxlIGFuZCB0aGUgd2hvbGUgbW9kdWxlXG4gICAgICogd2lsbCBiZSByZXNvbHZlZCBhbiBlbXB0eSBvYmplY3QuXG4gICAgICovXG4gICAgaXNOb2RlIDogdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlciBmcm9tIGFuIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgdGhlIGRhdGEgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgbmV3QnVmZmVyRnJvbTogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBTYWZlZ3VhcmQgZm9yIG9sZCBOb2RlLmpzIHZlcnNpb25zLiBPbiBuZXdlciB2ZXJzaW9ucyxcbiAgICAgICAgICAgICAgICAvLyBCdWZmZXIuZnJvbShudW1iZXIpIC8gQnVmZmVyKG51bWJlciwgZW5jb2RpbmcpIGFscmVhZHkgdGhyb3cuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFxcXCJkYXRhXFxcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzaXplIHRoZSBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgYWxsb2NCdWZmZXI6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmIChCdWZmZXIuYWxsb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCBvdXQgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBCdWZmZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0J1ZmZlciA6IGZ1bmN0aW9uKGIpe1xuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGIpO1xuICAgIH0sXG5cbiAgICBpc1N0cmVhbSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5vbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnBhdXNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoucmVzdW1lID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcbnZhciBTdHJlYW1IZWxwZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9TdHJlYW1IZWxwZXInKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgWmlwT2JqZWN0ID0gcmVxdWlyZSgnLi96aXBPYmplY3QnKTtcbnZhciBnZW5lcmF0ZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlXCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG52YXIgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyID0gcmVxdWlyZShcIi4vbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlclwiKTtcblxuXG4vKipcbiAqIEFkZCBhIGZpbGUgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgZGF0YSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsT3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZpbGUuXG4gKi9cbnZhciBmaWxlQWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgLy8gYmUgc3VyZSBzdWIgZm9sZGVycyBleGlzdFxuICAgIHZhciBkYXRhVHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKSxcbiAgICAgICAgcGFyZW50O1xuXG5cbiAgICAvKlxuICAgICAqIENvcnJlY3Qgb3B0aW9ucy5cbiAgICAgKi9cblxuICAgIHZhciBvID0gdXRpbHMuZXh0ZW5kKG9yaWdpbmFsT3B0aW9ucyB8fCB7fSwgZGVmYXVsdHMpO1xuICAgIG8uZGF0ZSA9IG8uZGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgIGlmIChvLmNvbXByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBvLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvLnVuaXhQZXJtaXNzaW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvLnVuaXhQZXJtaXNzaW9ucyA9IHBhcnNlSW50KG8udW5peFBlcm1pc3Npb25zLCA4KTtcbiAgICB9XG5cbiAgICAvLyBVTlhfSUZESVIgIDAwNDAwMDAgc2VlIHppcGluZm8uY1xuICAgIGlmIChvLnVuaXhQZXJtaXNzaW9ucyAmJiAoby51bml4UGVybWlzc2lvbnMgJiAweDQwMDApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQml0IDQgICAgRGlyZWN0b3J5XG4gICAgaWYgKG8uZG9zUGVybWlzc2lvbnMgJiYgKG8uZG9zUGVybWlzc2lvbnMgJiAweDAwMTApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoby5kaXIpIHtcbiAgICAgICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcbiAgICB9XG4gICAgaWYgKG8uY3JlYXRlRm9sZGVycyAmJiAocGFyZW50ID0gcGFyZW50Rm9sZGVyKG5hbWUpKSkge1xuICAgICAgICBmb2xkZXJBZGQuY2FsbCh0aGlzLCBwYXJlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSBkYXRhVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBvLmJpbmFyeSA9PT0gZmFsc2UgJiYgby5iYXNlNjQgPT09IGZhbHNlO1xuICAgIGlmICghb3JpZ2luYWxPcHRpb25zIHx8IHR5cGVvZiBvcmlnaW5hbE9wdGlvbnMuYmluYXJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG8uYmluYXJ5ID0gIWlzVW5pY29kZVN0cmluZztcbiAgICB9XG5cblxuICAgIHZhciBpc0NvbXByZXNzZWRFbXB0eSA9IChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCkgJiYgZGF0YS51bmNvbXByZXNzZWRTaXplID09PSAwO1xuXG4gICAgaWYgKGlzQ29tcHJlc3NlZEVtcHR5IHx8IG8uZGlyIHx8ICFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG8uYmFzZTY0ID0gZmFsc2U7XG4gICAgICAgIG8uYmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgZGF0YSA9IFwiXCI7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBcIlNUT1JFXCI7XG4gICAgICAgIGRhdGFUeXBlID0gXCJzdHJpbmdcIjtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvbnZlcnQgY29udGVudCB0byBmaXQuXG4gICAgICovXG5cbiAgICB2YXIgemlwT2JqZWN0Q29udGVudCA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0IHx8IGRhdGEgaW5zdGFuY2VvZiBHZW5lcmljV29ya2VyKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBuZXcgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKG5hbWUsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSB1dGlscy5wcmVwYXJlQ29udGVudChuYW1lLCBkYXRhLCBvLmJpbmFyeSwgby5vcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIG8uYmFzZTY0KTtcbiAgICB9XG5cbiAgICB2YXIgb2JqZWN0ID0gbmV3IFppcE9iamVjdChuYW1lLCB6aXBPYmplY3RDb250ZW50LCBvKTtcbiAgICB0aGlzLmZpbGVzW25hbWVdID0gb2JqZWN0O1xuICAgIC8qXG4gICAgVE9ETzogd2UgY2FuJ3QgdGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBhc3luYyBwcm9taXNlc1xuICAgICh3ZSBjYW4gaGF2ZSBhIHByb21pc2Ugb2YgYSBEYXRlKCkgZm9yIGV4YW1wbGUpIGJ1dCByZXR1cm5pbmcgYVxuICAgIHByb21pc2UgaXMgdXNlbGVzcyBiZWNhdXNlIGZpbGUobmFtZSwgZGF0YSkgcmV0dXJucyB0aGUgSlNaaXBcbiAgICBvYmplY3QgZm9yIGNoYWluaW5nLiBTaG91bGQgd2UgYnJlYWsgdGhhdCB0byBhbGxvdyB0aGUgdXNlclxuICAgIHRvIGNhdGNoIHRoZSBlcnJvciA/XG5cbiAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHppcE9iamVjdENvbnRlbnQpXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuICAgICovXG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHBhcmVudCBmb2xkZXIgb2YgdGhlIHBhdGguXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gdXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBwYXJlbnQgZm9sZGVyLCBvciBcIlwiXG4gKi9cbnZhciBwYXJlbnRGb2xkZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHJldHVybiAobGFzdFNsYXNoID4gMCkgPyBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpIDogXCJcIjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGF0aCB3aXRoIGEgc2xhc2ggYXQgdGhlIGVuZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHBhdGggd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICovXG52YXIgZm9yY2VUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIENoZWNrIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC9cbiAgICBpZiAocGF0aC5zbGljZSgtMSkgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggKz0gXCIvXCI7IC8vIElFIGRvZXNuJ3QgbGlrZSBzdWJzdHIoLTEpXG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLyoqXG4gKiBBZGQgYSAoc3ViKSBmb2xkZXIgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBmb2xkZXIncyBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBbY3JlYXRlRm9sZGVyc10gSWYgdHJ1ZSwgYXV0b21hdGljYWxseSBjcmVhdGUgc3ViXG4gKiAgZm9sZGVycy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZm9sZGVyLlxuICovXG52YXIgZm9sZGVyQWRkID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlRm9sZGVycykge1xuICAgIGNyZWF0ZUZvbGRlcnMgPSAodHlwZW9mIGNyZWF0ZUZvbGRlcnMgIT09ICd1bmRlZmluZWQnKSA/IGNyZWF0ZUZvbGRlcnMgOiBkZWZhdWx0cy5jcmVhdGVGb2xkZXJzO1xuXG4gICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcblxuICAgIC8vIERvZXMgdGhpcyBmb2xkZXIgYWxyZWFkeSBleGlzdD9cbiAgICBpZiAoIXRoaXMuZmlsZXNbbmFtZV0pIHtcbiAgICAgICAgZmlsZUFkZC5jYWxsKHRoaXMsIG5hbWUsIG51bGwsIHtcbiAgICAgICAgICAgIGRpcjogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IGNyZWF0ZUZvbGRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbGVzW25hbWVdO1xufTtcblxuLyoqXG4qIENyb3NzLXdpbmRvdywgY3Jvc3MtTm9kZS1jb250ZXh0IHJlZ3VsYXIgZXhwcmVzc2lvbiBkZXRlY3Rpb25cbiogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0IEFueXRoaW5nXG4qIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sXG4qIGZhbHNlIG90aGVyd2lzZVxuKi9cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn1cblxuLy8gcmV0dXJuIHRoZSBhY3R1YWwgcHJvdG90eXBlIG9mIEpTWmlwXG52YXIgb3V0ID0ge1xuICAgIC8qKlxuICAgICAqIEBzZWUgbG9hZEFzeW5jXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBlbnRyeSBhdCB0aGlzIGZvbGRlciBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgY2FsbGJhY2sgZnVuY3Rpb246XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjYikge1xuICAgICAgICB2YXIgZmlsZW5hbWUsIHJlbGF0aXZlUGF0aCwgZmlsZTtcbiAgICAgICAgZm9yIChmaWxlbmFtZSBpbiB0aGlzLmZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tmaWxlbmFtZV07XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBmaWxlbmFtZS5zbGljZSh0aGlzLnJvb3QubGVuZ3RoLCBmaWxlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aCAmJiBmaWxlbmFtZS5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoKSA9PT0gdGhpcy5yb290KSB7IC8vIHRoZSBmaWxlIGlzIGluIHRoZSBjdXJyZW50IHJvb3RcbiAgICAgICAgICAgICAgICBjYihyZWxhdGl2ZVBhdGgsIGZpbGUpOyAvLyBUT0RPIHJldmVyc2UgdGhlIHBhcmFtZXRlcnMgPyBuZWVkIHRvIGJlIGNsZWFuIEFORCBjb25zaXN0ZW50IHdpdGggdGhlIGZpbHRlciBzZWFyY2ggZm4uLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgbmVzdGVkIGZpbGVzL2ZvbGRlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlYXJjaCB0aGUgcHJlZGljYXRlIHRvIHVzZSA6XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbihzZWFyY2gpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2gocmVsYXRpdmVQYXRoLCBlbnRyeSkpIHsgLy8gdGhlIGZpbGUgbWF0Y2hlcyB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGZpbGUgdG8gdGhlIHppcCBmaWxlLCBvciBzZWFyY2ggYSBmaWxlLlxuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd8UmVnRXhwfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGFkZCAoaWYgZGF0YSBpcyBkZWZpbmVkKSxcbiAgICAgKiB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBmaW5kIChpZiBubyBkYXRhKSBvciBhIHJlZ2V4IHRvIG1hdGNoIGZpbGVzLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgIFRoZSBmaWxlIGRhdGEsIGVpdGhlciByYXcgb3IgYmFzZTY0IGVuY29kZWRcbiAgICAgKiBAcGFyYW0gICB7T2JqZWN0fSBvICAgICBGaWxlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuICB7SlNaaXB8T2JqZWN0fEFycmF5fSB0aGlzIEpTWmlwIG9iamVjdCAod2hlbiBhZGRpbmcgYSBmaWxlKSxcbiAgICAgKiBhIGZpbGUgKHdoZW4gc2VhcmNoaW5nIGJ5IHN0cmluZykgb3IgYW4gYXJyYXkgb2YgZmlsZXMgKHdoZW4gc2VhcmNoaW5nIGJ5IHJlZ2V4KS5cbiAgICAgKi9cbiAgICBmaWxlOiBmdW5jdGlvbihuYW1lLCBkYXRhLCBvKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNSZWdFeHAobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZmlsZS5kaXIgJiYgcmVnZXhwLnRlc3QocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB0ZXh0XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZmlsZXNbdGhpcy5yb290ICsgbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiAhb2JqLmRpcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gbW9yZSB0aGFuIG9uZSBhcmd1bWVudCA6IHdlIGhhdmUgZGF0YSAhXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5yb290ICsgbmFtZTtcbiAgICAgICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBkYXRhLCBvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZGlyZWN0b3J5IHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8UmVnRXhwfSBhcmcgVGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSB0byBhZGQsIG9yIGEgcmVnZXggdG8gc2VhcmNoIGZvbGRlcnMuXG4gICAgICogQHJldHVybiAge0pTWmlwfSBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IGRpcmVjdG9yeSBhcyB0aGUgcm9vdCwgb3IgYW4gYXJyYXkgY29udGFpbmluZyBtYXRjaGluZyBmb2xkZXJzLlxuICAgICAqL1xuICAgIGZvbGRlcjogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1JlZ0V4cChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuZGlyICYmIGFyZy50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2UsIG5hbWUgaXMgYSBuZXcgZm9sZGVyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5yb290ICsgYXJnO1xuICAgICAgICB2YXIgbmV3Rm9sZGVyID0gZm9sZGVyQWRkLmNhbGwodGhpcywgbmFtZSk7XG5cbiAgICAgICAgLy8gQWxsb3cgY2hhaW5pbmcgYnkgcmV0dXJuaW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoaXMgZm9sZGVyIGFzIHRoZSByb290XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJldC5yb290ID0gbmV3Rm9sZGVyLm5hbWU7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbGUsIG9yIGEgZGlyZWN0b3J5IGFuZCBhbGwgc3ViLWZpbGVzLCBmcm9tIHRoZSB6aXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBkZWxldGVcbiAgICAgKiBAcmV0dXJuIHtKU1ppcH0gdGhpcyBKU1ppcCBvYmplY3RcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBhbnkgZm9sZGVyc1xuICAgICAgICAgICAgaWYgKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlICYmICFmaWxlLmRpcikge1xuICAgICAgICAgICAgLy8gZmlsZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYXliZSBhIGZvbGRlciwgZGVsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICB2YXIga2lkcyA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLm5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGgpID09PSBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1traWRzW2ldLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSB6aXAgZmlsZVxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXMgYW4gaW50ZXJuYWwgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgc3RyZWFtZWQgemlwIGZpbGUuXG4gICAgICovXG4gICAgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHdvcmtlciwgb3B0cyA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBvcHRzID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgICAgc3RyZWFtRmlsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbjogXCJTVE9SRVwiLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBudWxsLFxuICAgICAgICAgICAgICB0eXBlOiBcIlwiLFxuICAgICAgICAgICAgICBwbGF0Zm9ybTogXCJET1NcIixcbiAgICAgICAgICAgICAgY29tbWVudDogbnVsbCxcbiAgICAgICAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICAgICAgICAgICBlbmNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZW5jb2RlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBvcHRzLnR5cGUgPSBvcHRzLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBvcHRzLmNvbXByZXNzaW9uID0gb3B0cy5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgLy8gXCJiaW5hcnlzdHJpbmdcIiBpcyBwcmVmZXJyZWQgYnV0IHRoZSBpbnRlcm5hbHMgdXNlIFwic3RyaW5nXCIuXG4gICAgICAgICAgaWYob3B0cy50eXBlID09PSBcImJpbmFyeXN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRzLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb3B0cy50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChvcHRzLnR5cGUpO1xuXG4gICAgICAgICAgLy8gYWNjZXB0IG5vZGVqcyBgcHJvY2Vzcy5wbGF0Zm9ybWBcbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdsaW51eCcgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ3N1bm9zJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJVTklYXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIkRPU1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb21tZW50ID0gb3B0cy5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICAgIHdvcmtlciA9IGdlbmVyYXRlLmdlbmVyYXRlV29ya2VyKHRoaXMsIG9wdHMsIGNvbW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB3b3JrZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcih3b3JrZXIsIG9wdHMudHlwZSB8fCBcInN0cmluZ1wiLCBvcHRzLm1pbWVUeXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFzeW5jOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLmFjY3VtdWxhdGUob25VcGRhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlTm9kZVN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBcIm5vZGVidWZmZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBvdXQ7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgYnkgbW9kdWxlIGJ1bmRsZXJzIChicm93c2VyaWZ5L3dlYnBhY2svZXRjKSB3aGVuXG4gKiBpbmNsdWRpbmcgYSBzdHJlYW0gaW1wbGVtZW50YXRpb24uIFdlIHVzZSBcInJlYWRhYmxlLXN0cmVhbVwiIHRvIGdldCBhXG4gKiBjb25zaXN0ZW50IGJlaGF2aW9yIGJldHdlZW4gbm9kZWpzIHZlcnNpb25zIGJ1dCBidW5kbGVycyBvZnRlbiBoYXZlIGEgc2hpbVxuICogZm9yIFwic3RyZWFtXCIuIFVzaW5nIHRoaXMgc2hpbSBncmVhdGx5IGltcHJvdmUgdGhlIGNvbXBhdGliaWxpdHkgYW5kIGdyZWF0bHlcbiAqIHJlZHVjZSB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVuZGxlIChvbmx5IG9uZSBzdHJlYW0gaW1wbGVtZW50YXRpb24sIG5vdFxuICogdHdvKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRkYXRhW2ldID0gZGF0YVtpXSAmIDB4RkY7XG5cdH1cbn1cbnV0aWxzLmluaGVyaXRzKEFycmF5UmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvICsgaV07XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSA0OyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09PSBzaWcwICYmIHRoaXMuZGF0YVtpICsgMV0gPT09IHNpZzEgJiYgdGhpcy5kYXRhW2kgKyAyXSA9PT0gc2lnMiAmJiB0aGlzLmRhdGFbaSArIDNdID09PSBzaWczKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpLFxuICAgICAgICBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnMCA9PT0gZGF0YVswXSAmJiBzaWcxID09PSBkYXRhWzFdICYmIHNpZzIgPT09IGRhdGFbMl0gJiYgc2lnMyA9PT0gZGF0YVszXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIERhdGFSZWFkZXIoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7IC8vIHR5cGUgOiBzZWUgaW1wbGVtZW50YXRpb25cbiAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuemVybyA9IDA7XG59XG5EYXRhUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBvZmZzZXQgd2lsbCBub3QgZ28gdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0IHRoZSBhZGRpdGlvbmFsIG9mZnNldCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuaW5kZXggKyBvZmZzZXQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHdpbGwgbm90IGJlIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0luZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy56ZXJvICsgbmV3SW5kZXggfHwgbmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmQgb2YgZGF0YSByZWFjaGVkIChkYXRhIGxlbmd0aCA9IFwiICsgdGhpcy5sZW5ndGggKyBcIiwgYXNrZWQgaW5kZXggPSBcIiArIChuZXdJbmRleCkgKyBcIikuIENvcnJ1cHRlZCB6aXAgP1wiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggVGhlIG5ldyBpbmRleC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleChuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXdJbmRleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNraXAgdGhlIG5leHQgbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNraXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLmluZGV4ICsgbik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSB0aGUgaW5kZXggdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYSBieXRlLlxuICAgICAqL1xuICAgIGJ5dGVBdDogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgbnVtYmVyIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlYWRJbnQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmluZGV4ICsgc2l6ZSAtIDE7IGkgPj0gdGhpcy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpICsgdGhpcy5ieXRlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHN0cmluZyB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLnJlYWREYXRhKHNpemUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSB3aXRob3V0IGNvbnZlcnNpb24sIDxzaXplPiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcmF3IGRhdGEsIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAqL1xuICAgIHJlYWREYXRhOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhIHppcCBzaWduYXR1cmUgKDQgYnl0ZXMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIHNpZ25hdHVyZSB0byBmaW5kLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2UsIC0xIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsYXN0SW5kZXhPZlNpZ25hdHVyZTogZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHNpZ25hdHVyZSAoNCBieXRlcykgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIGNvbXBhcmUgaXQgd2l0aCBzaWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZWFkQW5kQ2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgZGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkRGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb3N0aW1lID0gdGhpcy5yZWFkSW50KDQpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoXG4gICAgICAgICgoZG9zdGltZSA+PiAyNSkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcbiAgICAgICAgKChkb3N0aW1lID4+IDIxKSAmIDB4MGYpIC0gMSwgLy8gbW9udGhcbiAgICAgICAgKGRvc3RpbWUgPj4gMTYpICYgMHgxZiwgLy8gZGF5XG4gICAgICAgIChkb3N0aW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJcbiAgICAgICAgKGRvc3RpbWUgPj4gNSkgJiAweDNmLCAvLyBtaW51dGVcbiAgICAgICAgKGRvc3RpbWUgJiAweDFmKSA8PCAxKSk7IC8vIHNlY29uZFxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gTm9kZUJ1ZmZlclJlYWRlcihkYXRhKSB7XG4gICAgVWludDhBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoTm9kZUJ1ZmZlclJlYWRlciwgVWludDhBcnJheVJlYWRlcik7XG5cbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbk5vZGVCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlQnVmZmVyUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoU3RyaW5nUmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy56ZXJvICsgaSk7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiB0aGlzLmRhdGEubGFzdEluZGV4T2Yoc2lnKSAtIHRoaXMuemVybztcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcgPT09IGRhdGE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIC8vIHRoaXMgd2lsbCB3b3JrIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdGhlIFwiJiAweGZmXCIgbWFzay5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1JlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vQXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFVpbnQ4QXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIEFycmF5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhVaW50OEFycmF5UmVhZGVyLCBBcnJheVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5VaW50OEFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgLy8gaW4gSUUxMCwgd2hlbiB1c2luZyBzdWJhcnJheShpZHgsIGlkeCksIHdlIGdldCB0aGUgYXJyYXkgWzB4MDBdIGluc3RlYWQgb2YgW10uXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5UmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0Jyk7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgU3RyaW5nUmVhZGVyID0gcmVxdWlyZSgnLi9TdHJpbmdSZWFkZXInKTtcbnZhciBOb2RlQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9Ob2RlQnVmZmVyUmVhZGVyJyk7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlYWRlciBhZGFwdGVkIHRvIHRoZSBkYXRhLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgdG8gcmVhZC5cbiAqIEByZXR1cm4ge0RhdGFSZWFkZXJ9IHRoZSBkYXRhIHJlYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgIHV0aWxzLmNoZWNrU3VwcG9ydCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlcIiwgZGF0YSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMuTE9DQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDNcXHgwNFwiO1xuZXhwb3J0cy5DRU5UUkFMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAxXFx4MDJcIjtcbmV4cG9ydHMuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA1XFx4MDZcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiA9IFwiUEtcXHgwNlxceDA3XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNlxceDA2XCI7XG5leHBvcnRzLkRBVEFfREVTQ1JJUFRPUiA9IFwiUEtcXHgwN1xceDA4XCI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNvbnZlcnQgY2h1bmtzIHRvIGEgc3BlY2lmaWVkIHR5cGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0VHlwZSB0aGUgZGVzdGluYXRpb24gdHlwZS5cbiAqL1xuZnVuY3Rpb24gQ29udmVydFdvcmtlcihkZXN0VHlwZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkNvbnZlcnRXb3JrZXIgdG8gXCIgKyBkZXN0VHlwZSk7XG4gICAgdGhpcy5kZXN0VHlwZSA9IGRlc3RUeXBlO1xufVxudXRpbHMuaW5oZXJpdHMoQ29udmVydFdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5Db252ZXJ0V29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogdXRpbHMudHJhbnNmb3JtVG8odGhpcy5kZXN0VHlwZSwgY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXJ0V29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSBjcmMzMiBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ3JjMzJQcm9iZSgpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDcmMzMlByb2JlXCIpO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKENyYzMyUHJvYmUsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ3JjMzJQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5zdHJlYW1JbmZvLmNyYzMyID0gY3JjMzIoY2h1bmsuZGF0YSwgdGhpcy5zdHJlYW1JbmZvLmNyYzMyIHx8IDApO1xuICAgIHRoaXMucHVzaChjaHVuayk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDcmMzMlByb2JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjYWxjdWxhdGUgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSB0aGUgbmFtZSB1c2VkIHRvIGV4cG9zZSB0aGUgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIERhdGFMZW5ndGhQcm9iZShwcm9wTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkRhdGFMZW5ndGhQcm9iZSBmb3IgXCIgKyBwcm9wTmFtZSk7XG4gICAgdGhpcy5wcm9wTmFtZSA9IHByb3BOYW1lO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8ocHJvcE5hbWUsIDApO1xufVxudXRpbHMuaW5oZXJpdHMoRGF0YUxlbmd0aFByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkRhdGFMZW5ndGhQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYoY2h1bmspIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSB8fCAwO1xuICAgICAgICB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gPSBsZW5ndGggKyBjaHVuay5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rLmNhbGwodGhpcywgY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YUxlbmd0aFByb2JlO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xuXG4vLyB0aGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGNodW5rc1xuLy8gVE9ETyBleHBvc2UgdGhpcyBhcyBhIHB1YmxpYyB2YXJpYWJsZVxudmFyIERFRkFVTFRfQkxPQ0tfU0laRSA9IDE2ICogMTAyNDtcblxuLyoqXG4gKiBBIHdvcmtlciB0aGF0IHJlYWRzIGEgY29udGVudCBhbmQgZW1pdHMgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb21pc2V9IGRhdGFQIHRoZSBwcm9taXNlIG9mIHRoZSBkYXRhIHRvIHNwbGl0XG4gKi9cbmZ1bmN0aW9uIERhdGFXb3JrZXIoZGF0YVApIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhV29ya2VyXCIpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRhdGFJc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5tYXggPSAwO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcblxuICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIGRhdGFQLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5kYXRhSXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubWF4ID0gZGF0YSAmJiBkYXRhLmxlbmd0aCB8fCAwO1xuICAgICAgICBzZWxmLnR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSk7XG4gICAgICAgIGlmKCFzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBzZWxmLl90aWNrQW5kUmVwZWF0KCk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgIH0pO1xufVxuXG51dGlscy5pbmhlcml0cyhEYXRhV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVzdW1lXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGlja1NjaGVkdWxlZCAmJiB0aGlzLmRhdGFJc1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgdGljayBhIHNjaGVkdWxlIGFuIG90aGVyIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2tBbmRSZXBlYXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aWNrKCk7XG4gICAgaWYoIXRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcHVzaCBhIGNodW5rLlxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gREVGQVVMVF9CTE9DS19TSVpFO1xuICAgIHZhciBkYXRhID0gbnVsbCwgbmV4dEluZGV4ID0gTWF0aC5taW4odGhpcy5tYXgsIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLm1heCkge1xuICAgICAgICAvLyBFT0ZcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IHRoaXMubWF4ID8gdGhpcy5pbmRleCAvIHRoaXMubWF4ICogMTAwIDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHBhc3NpbmcgY2h1bmtzIHRvIHRoZSBuZXh0IG9uZS4gVGhpcyBpcyBsaWtlXG4gKiBhIG5vZGVqcyBzdHJlYW0gYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlcy4gT24gdGhlIGdvb2Qgc2lkZSA6XG4gKiAtIGl0IHdvcmtzIG9uIElFIDYtOSB3aXRob3V0IGFueSBpc3N1ZSAvIHBvbHlmaWxsXG4gKiAtIGl0IHdlaWdodHMgbGVzcyB0aGFuIHRoZSBmdWxsIGRlcGVuZGVuY2llcyBidW5kbGVkIHdpdGggYnJvd3NlcmlmeVxuICogLSBpdCBmb3J3YXJkcyBlcnJvcnMgKG5vIG5lZWQgdG8gZGVjbGFyZSBhbiBlcnJvciBoYW5kbGVyIEVWRVJZV0hFUkUpXG4gKlxuICogQSBjaHVuayBpcyBhbiBvYmplY3Qgd2l0aCAyIGF0dHJpYnV0ZXMgOiBgbWV0YWAgYW5kIGBkYXRhYC4gVGhlIGZvcm1lciBpcyBhblxuICogb2JqZWN0IGNvbnRhaW5pbmcgYW55dGhpbmcgKGBwZXJjZW50YCBmb3IgZXhhbXBsZSksIHNlZSBlYWNoIHdvcmtlciBmb3IgbW9yZVxuICogZGV0YWlscy4gVGhlIGxhdHRlciBpcyB0aGUgcmVhbCBkYXRhIChTdHJpbmcsIFVpbnQ4QXJyYXksIGV0YykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtIChtYWlubHkgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5mdW5jdGlvbiBHZW5lcmljV29ya2VyKG5hbWUpIHtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgd29ya2VyXG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAvLyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCB0aGUgd29ya2VycyBjaGFpblxuICAgIHRoaXMuc3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIGFuIGVycm9yIHdoaWNoIGhhcHBlbmVkIHdoZW4gdGhlIHdvcmtlciB3YXMgcGF1c2VkXG4gICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IG51bGw7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgdG8gYmUgbWVyZ2VkIGJ5IHRoaXMgd29ya2VyIGludG8gdGhlIGdlbmVyYWwgbWV0YWRhdGFcbiAgICB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBwYXVzZWQgKGFuZCBzaG91bGQgbm90IGRvIGFueXRoaW5nKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBsb2NrZWQgdG8gcHJldmVudCBmdXJ0aGVyIHN0cnVjdHVyZSB1cGRhdGVzIChwaXBlKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICAgICdkYXRhJzpbXSxcbiAgICAgICAgJ2VuZCc6W10sXG4gICAgICAgICdlcnJvcic6W11cbiAgICB9O1xuICAgIC8vIHRoZSBwcmV2aW91cyB3b3JrZXIsIGlmIGFueVxuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xufVxuXG5HZW5lcmljV29ya2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBQdXNoIGEgY2h1bmsgdG8gdGhlIG5leHQgd29ya2Vycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmsgdGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKi9cbiAgICBwdXNoIDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgZW5kZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZSB0aGUgZXJyb3Igd2hpY2ggY2F1c2VkIHRoZSBwcmVtYXR1cmUgZW5kLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIgd2l0aCBhbiBlcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVycm9yIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIHdvcmtlcnMgY2hhaW4gZXhwbG9kZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2hhaW4sXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgd2lsbCBnbyBkb3dud2FyZCBidXQgd2UgYWxzbyBuZWVkIHRvIG5vdGlmeVxuICAgICAgICAgICAgLy8gd29ya2VycyB1cHdhcmQgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIG9uIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhbiBhbnkgcmVmZXJlbmNlcyB3aGVuIGEgd29ya2VyIGlzIGVuZGluZy5cbiAgICAgKi9cbiAgICBjbGVhblVwIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSB0aGlzLmdlbmVyYXRlZEVycm9yID0gdGhpcy5leHRyYVN0cmVhbUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnQuIFRoaXMgd2lsbCBjYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYXJnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIHRoZSBhcmd1bWVudCB0byBjYWxsIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgICAqL1xuICAgIGVtaXQgOiBmdW5jdGlvbiAobmFtZSwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV1baV0uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFpbiBhIHdvcmtlciB3aXRoIGFuIG90aGVyLlxuICAgICAqIEBwYXJhbSB7V29ya2VyfSBuZXh0IHRoZSB3b3JrZXIgcmVjZWl2aW5nIGV2ZW50cyBmcm9tIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKiBAcmV0dXJuIHt3b3JrZXJ9IHRoZSBuZXh0IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcGlwZSA6IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXh0LnJlZ2lzdGVyUHJldmlvdXModGhpcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBwaXBlYCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgICAqIFVzaW5nIGFuIEFQSSB3aXRoIGBwaXBlKG5leHQpYCBpcyB2ZXJ5IGVhc3kuXG4gICAgICogSW1wbGVtZW50aW5nIHRoZSBBUEkgd2l0aCB0aGUgcG9pbnQgb2YgdmlldyBvZiB0aGUgbmV4dCBvbmUgcmVnaXN0ZXJpbmdcbiAgICAgKiBhIHNvdXJjZSBpcyBlYXNpZXIsIHNlZSB0aGUgWmlwRmlsZVdvcmtlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gcHJldmlvdXMgdGhlIHByZXZpb3VzIHdvcmtlciwgc2VuZGluZyBldmVudHMgdG8gdGhpcyBvbmVcbiAgICAgKiBAcmV0dXJuIHtXb3JrZXJ9IHRoZSBjdXJyZW50IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmV2aW91cyA6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFyaW5nIHRoZSBzdHJlYW1JbmZvLi4uXG4gICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHByZXZpb3VzLnN0cmVhbUluZm87XG4gICAgICAgIC8vIC4uLiBhbmQgYWRkaW5nIG91ciBvd24gYml0c1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gIHByZXZpb3VzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtIHNvIGl0IGRvZXNuJ3Qgc2VuZCBldmVudHMgYW55bW9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBwYXVzZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSBhIHBhdXNlZCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcmVzdW1lZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgdHJ1ZSwgdGhlIHdvcmtlciB0cmllZCB0byByZXN1bWUgYnV0IGZhaWxlZFxuICAgICAgICB2YXIgd2l0aEVycm9yID0gZmFsc2U7XG4gICAgICAgIGlmKHRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvcik7XG4gICAgICAgICAgICB3aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXdpdGhFcnJvcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZsdXNoIGFueSByZW1haW5pbmcgYnl0ZXMgYXMgdGhlIHN0cmVhbSBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgZmx1c2ggOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgY2h1bmsuIFRoaXMgaXMgdXN1YWxseSB0aGUgbWV0aG9kIG92ZXJyaWRkZW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIHByb2Nlc3NDaHVuayA6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBrZXkvdmFsdWUgdG8gYmUgYWRkZWQgaW4gdGhlIHdvcmtlcnMgY2hhaW4gc3RyZWFtSW5mbyBvbmNlIGFjdGl2YXRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgdG8gdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHdpdGhTdHJlYW1JbmZvIDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoaXMgd29ya2VyJ3Mgc3RyZWFtSW5mbyBpbnRvIHRoZSBjaGFpbidzIHN0cmVhbUluZm8uXG4gICAgICovXG4gICAgbWVyZ2VTdHJlYW1JbmZvIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmV4dHJhU3RyZWFtSW5mbykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4dHJhU3RyZWFtSW5mby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUluZm9ba2V5XSA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgc3RyZWFtIHRvIHByZXZlbnQgZnVydGhlciB1cGRhdGVzIG9uIHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFsbCBjYWxscyB0byBwaXBlIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBsb2NrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIiArIHRoaXMgKyBcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMubG9jaygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJldHR5IHByaW50IHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWUgPSBcIldvcmtlciBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzICsgXCIgLT4gXCIgKyBtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY1dvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBDb252ZXJ0V29ya2VyID0gcmVxdWlyZSgnLi9Db252ZXJ0V29ya2VyJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4uL2Jhc2U2NCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi4vc3VwcG9ydFwiKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9leHRlcm5hbFwiKTtcblxudmFyIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSBudWxsO1xuaWYgKHN1cHBvcnQubm9kZXN0cmVhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSByZXF1aXJlKCcuLi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcicpO1xuICAgIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgZmluYWwgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGRhdGEuIElmIHRoZSB1c2VyIHdhbnRzIGEgQmxvYiBmb3JcbiAqIGV4YW1wbGUsIGl0J3MgZWFzaWVyIHRvIHdvcmsgd2l0aCBhbiBVOGludEFycmF5IGFuZCBmaW5hbGx5IGRvIHRoZVxuICogQXJyYXlCdWZmZXIvQmxvYiBjb252ZXJzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWUgb2YgdGhlIGZpbmFsIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSBjb250ZW50IHRoZSBjb250ZW50IHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIGNvbnRlbnQgaW4gdGhlIHJpZ2h0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtWmlwT3V0cHV0KHR5cGUsIGNvbnRlbnQsIG1pbWVUeXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIiA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMubmV3QmxvYih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5YnVmZmVyXCIsIGNvbnRlbnQpLCBtaW1lVHlwZSk7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIiA6XG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0LmVuY29kZShjb250ZW50KTtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8odHlwZSwgY29udGVudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGFycmF5IG9mIGRhdGEgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgY2h1bmtzIHRvIGNvbmNhdGVuYXRlXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBjb25jYXRlbmF0ZWQgZGF0YVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYXNrZWQgdHlwZSBpcyB1bnN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBjb25jYXQgKHR5cGUsIGRhdGFBcnJheSkge1xuICAgIHZhciBpLCBpbmRleCA9IDAsIHJlcyA9IG51bGwsIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFBcnJheS5qb2luKFwiXCIpO1xuICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGRhdGFBcnJheSk7XG4gICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICByZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0KGRhdGFBcnJheVtpXSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoZGF0YUFycmF5KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmNhdCA6IHVuc3VwcG9ydGVkIHR5cGUgJ1wiICArIHR5cGUgKyBcIidcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gKiBjb21wbGV0ZSBibG9jay5cbiAqIEBwYXJhbSB7U3RyZWFtSGVscGVyfSBoZWxwZXIgdGhlIGhlbHBlciB0byB1c2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYWxsYmFjayBhIGNhbGxiYWNrIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZS4gQ2FsbGVkXG4gKiB3aXRoIG9uZSBhcmcgOlxuICogLSB0aGUgbWV0YWRhdGEgbGlua2VkIHRvIHRoZSB1cGRhdGUgcmVjZWl2ZWQuXG4gKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoaGVscGVyLCB1cGRhdGVDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgY2h1bmtUeXBlID0gaGVscGVyLl9pbnRlcm5hbFR5cGUsXG4gICAgICAgICAgICByZXN1bHRUeXBlID0gaGVscGVyLl9vdXRwdXRUeXBlLFxuICAgICAgICAgICAgbWltZVR5cGUgPSBoZWxwZXIuX21pbWVUeXBlO1xuICAgICAgICBoZWxwZXJcbiAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDYWxsYmFjayhtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVppcE91dHB1dChyZXN1bHRUeXBlLCBjb25jYXQoY2h1bmtUeXBlLCBkYXRhQXJyYXkpLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB9KVxuICAgICAgICAucmVzdW1lKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIHRvIGVhc2lseSB1c2Ugd29ya2VycyBvdXRzaWRlIG9mIEpTWmlwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmtlcn0gd29ya2VyIHRoZSB3b3JrZXIgdG8gd3JhcFxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIHR5cGUgb2YgZGF0YSBleHBlY3RlZCBieSB0aGUgdXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gU3RyZWFtSGVscGVyKHdvcmtlciwgb3V0cHV0VHlwZSwgbWltZVR5cGUpIHtcbiAgICB2YXIgaW50ZXJuYWxUeXBlID0gb3V0cHV0VHlwZTtcbiAgICBzd2l0Y2gob3V0cHV0VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwidWludDhhcnJheVwiO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCBpbnRlcm5hbGx5XG4gICAgICAgIHRoaXMuX2ludGVybmFsVHlwZSA9IGludGVybmFsVHlwZTtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCB0byBvdXRwdXQgcmVzdWx0c1xuICAgICAgICB0aGlzLl9vdXRwdXRUeXBlID0gb3V0cHV0VHlwZTtcbiAgICAgICAgLy8gdGhlIG1pbWUgdHlwZVxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQoaW50ZXJuYWxUeXBlKTtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyLnBpcGUobmV3IENvbnZlcnRXb3JrZXIoaW50ZXJuYWxUeXBlKSk7XG4gICAgICAgIC8vIHRoZSBsYXN0IHdvcmtlcnMgY2FuIGJlIHJld2lyZWQgd2l0aG91dCBpc3N1ZXMgYnV0IHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcHJldmVudCBhbnkgdXBkYXRlcyBvbiBwcmV2aW91cyB3b3JrZXJzLlxuICAgICAgICB3b3JrZXIubG9jaygpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB0aGlzLl93b3JrZXIuZXJyb3IoZSk7XG4gICAgfVxufVxuXG5TdHJlYW1IZWxwZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gICAgICogY29tcGxldGUgYmxvY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gICAgICovXG4gICAgYWNjdW11bGF0ZSA6IGZ1bmN0aW9uICh1cGRhdGVDYikge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0ZSh0aGlzLCB1cGRhdGVDYik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBvbiBhbiBldmVudCB0cmlnZ2VyZWQgb24gYSBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dCB0aGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChldnQsIGZuKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZihldnQgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHNlbGYsIGNodW5rLmRhdGEsIGNodW5rLm1ldGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMuZGVsYXkoZm4sIGFyZ3VtZW50cywgc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl93b3JrZXIucmVzdW1lLCBbXSwgdGhpcy5fd29ya2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcGF1c2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5vZGVqcyBzdHJlYW0gZm9yIHRoaXMgaGVscGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7Tm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcn0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gICAgICovXG4gICAgdG9Ob2RlanNTdHJlYW0gOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KFwibm9kZXN0cmVhbVwiKTtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgc3RyZWFtIGNvbnRhaW5pbmcgYmxvYi9hcnJheWJ1ZmZlci91aW50OGFycmF5L3N0cmluZ1xuICAgICAgICAgICAgLy8gaXMgc3RyYW5nZSBhbmQgSSBkb24ndCBrbm93IGlmIGl0IHdvdWxkIGJlIHVzZWZ1bC5cbiAgICAgICAgICAgIC8vIEkgeW91IGZpbmQgdGhpcyBjb21tZW50IGFuZCBoYXZlIGEgZ29vZCB1c2VjYXNlLCBwbGVhc2Ugb3BlbiBhXG4gICAgICAgICAgICAvLyBidWcgcmVwb3J0ICFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9vdXRwdXRUeXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcih0aGlzLCB7XG4gICAgICAgICAgICBvYmplY3RNb2RlIDogdGhpcy5fb3V0cHV0VHlwZSAhPT0gXCJub2RlYnVmZmVyXCJcbiAgICAgICAgfSwgdXBkYXRlQ2IpO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1IZWxwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYmFzZTY0ID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXkgPSB0cnVlO1xuZXhwb3J0cy5zdHJpbmcgPSB0cnVlO1xuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydHMubm9kZWJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG4vLyBjb250YWlucyB0cnVlIGlmIEpTWmlwIGNhbiByZWFkL2dlbmVyYXRlIFVpbnQ4QXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbmV4cG9ydHMudWludDhhcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5pZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG59XG5lbHNlIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIHRyeSB7XG4gICAgICAgIGV4cG9ydHMuYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiXG4gICAgICAgIH0pLnNpemUgPT09IDA7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBidWlsZGVyLmdldEJsb2IoJ2FwcGxpY2F0aW9uL3ppcCcpLnNpemUgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG50cnkge1xuICAgIGV4cG9ydHMubm9kZXN0cmVhbSA9ICEhcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG59IGNhdGNoKGUpIHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSBmYWxzZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3V0aWxzL3N0cmluZ3NcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgX3V0ZjhsZW5baV0gPSAoaSA+PSAyNTIgPyA2IDogaSA+PSAyNDggPyA1IDogaSA+PSAyNDAgPyA0IDogaSA+PSAyMjQgPyAzIDogaSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdPV91dGY4bGVuWzI1NF09MTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAgIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gICAgfVxuXG4gICAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQXJyYXkoYnVmX2xlbik7XG4gICAgfVxuXG4gICAgLy8gY29udmVydFxuICAgIGZvciAoaT0wLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xufTtcblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHtcbiAgICB2YXIgcG9zO1xuXG4gICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gICAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gICAgcG9zID0gbWF4LTE7XG4gICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gICAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gICAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gICAgLy8gcmV0dXJuIG1heCB0b28uXG4gICAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xudmFyIGJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIHN0ciwgaSwgb3V0LCBjLCBjX2xlbjtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICAgIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4qMik7XG5cbiAgICBmb3IgKG91dD0wLCBpPTA7IGk8bGVuOykge1xuICAgICAgICBjID0gYnVmW2krK107XG4gICAgICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAgICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuLTE7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAgICAgLy8gam9pbiB0aGUgcmVzdFxuICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgICAgICAgY19sZW4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICAgICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2hyaW5rQnVmKHV0ZjE2YnVmLCBvdXQpXG4gICAgaWYgKHV0ZjE2YnVmLmxlbmd0aCAhPT0gb3V0KSB7XG4gICAgICAgIGlmKHV0ZjE2YnVmLnN1YmFycmF5KSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZiA9IHV0ZjE2YnVmLnN1YmFycmF5KDAsIG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGYxNmJ1Zi5sZW5ndGggPSBvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGYxNmJ1Zik7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5RnJvbUNoYXJDb2RlKHV0ZjE2YnVmKTtcbn07XG5cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgamF2YXNjcmlwdCBzdHJpbmcgaW50byBhbiBhcnJheSAodHlwZWQgaWYgcG9zc2libGUpIG9mIGJ5dGVzLFxuICogVVRGLTggZW5jb2RlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgVVRGLTggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGVuY29kZSA9IGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShzdHIsIFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZzJidWYoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBieXRlcyBhcnJheSAob3IgYSByZXByZXNlbnRhdGlvbikgcmVwcmVzZW50aW5nIGFuIFVURi04IGVuY29kZWRcbiAqIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSBidWYgdGhlIGRhdGEgZGUgZGVjb2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZGVjb2RlID0gZnVuY3Rpb24gdXRmOGRlY29kZShidWYpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcIm5vZGVidWZmZXJcIiwgYnVmKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIGJ1ZiA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBidWYpO1xuXG4gICAgcmV0dXJuIGJ1ZjJzdHJpbmcoYnVmKTtcbn07XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZGVjb2RlIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzIGludG8gc3RyaW5nIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RGVjb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGRlY29kZVwiKTtcbiAgICAvLyB0aGUgbGFzdCBieXRlcyBpZiBhIGNodW5rIGRpZG4ndCBlbmQgd2l0aCBhIGNvbXBsZXRlIGNvZGVwb2ludC5cbiAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhEZWNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgZGF0YSA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBjaHVuay5kYXRhKTtcblxuICAgIC8vIDFzdCBzdGVwLCByZS11c2Ugd2hhdCdzIGxlZnQgb2YgdGhlIHByZXZpb3VzIGNodW5rXG4gICAgaWYgKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgaWYoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShwcmV2aW91c0RhdGEubGVuZ3RoICsgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5zZXQodGhpcy5sZWZ0T3ZlciwgMCk7XG4gICAgICAgICAgICBkYXRhLnNldChwcmV2aW91c0RhdGEsIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxlZnRPdmVyLmNvbmNhdChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEJvdW5kYXJ5ID0gdXRmOGJvcmRlcihkYXRhKTtcbiAgICB2YXIgdXNhYmxlRGF0YSA9IGRhdGE7XG4gICAgaWYgKG5leHRCb3VuZGFyeSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc3ViYXJyYXkoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnN1YmFycmF5KG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc2xpY2UoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnNsaWNlKG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh1c2FibGVEYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodGhpcy5sZWZ0T3ZlciksXG4gICAgICAgICAgICBtZXRhIDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLlV0ZjhEZWNvZGVXb3JrZXIgPSBVdGY4RGVjb2RlV29ya2VyO1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGVuZGNvZGUgc3RyaW5nIGNodW5rcyBpbnRvIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhFbmNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZW5jb2RlXCIpO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOEVuY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RW5jb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZW5jb2RlKGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbmV4cG9ydHMuVXRmOEVuY29kZVdvcmtlciA9IFV0ZjhFbmNvZGVXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdzZXQtaW1tZWRpYXRlLXNoaW0nKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0aGF0IHBhc3MgYXMgYSBcImJpbmFyeSBzdHJpbmdcIjogaXQgc2hvdWxkIHJlcHJlc2VudCBhIGJ5dGVcbiAqIGFycmF5IGJ1dCBtYXkgaGF2ZSA+IDI1NSBjaGFyIGNvZGVzLiBCZSBzdXJlIHRvIHRha2Ugb25seSB0aGUgZmlyc3QgYnl0ZVxuICogYW5kIHJldHVybnMgdGhlIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheX0gdGhlIHN0cmluZyBpbiBhIGJpbmFyeSBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZzJiaW5hcnkoc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgcmVzdWx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmxvYiB3aXRoIHRoZSBnaXZlbiBjb250ZW50IGFuZCB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfSBwYXJ0IHRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgYmxvYi4gRE8gTk9UIHVzZVxuICogYW4gVWludDhBcnJheSBiZWNhdXNlIHRoZSBzdG9jayBicm93c2VyIG9mIGFuZHJvaWQgNCB3b24ndCBhY2NlcHQgaXQgKGl0XG4gKiB3aWxsIGJlIHNpbGVudGx5IGNvbnZlcnRlZCB0byBhIHN0cmluZywgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpLlxuICpcbiAqIFVzZSBvbmx5IE9ORSBwYXJ0IHRvIGJ1aWxkIHRoZSBibG9iIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW4gSUUxMSAvIEVkZ2U6XG4gKiB3aGVuIGEgbGFyZ2UgYW1vdW50IG9mIEFycmF5IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBCbG9iLCB0aGUgYW1vdW50IG9mXG4gKiBtZW1vcnkgY29uc3VtZWQgaXMgbmVhcmx5IDEwMCB0aW1lcyB0aGUgb3JpZ2luYWwgZGF0YSBhbW91bnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgYmxvYi5cbiAqIEByZXR1cm4ge0Jsb2J9IHRoZSBjcmVhdGVkIGJsb2IuXG4gKi9cbmV4cG9ydHMubmV3QmxvYiA9IGZ1bmN0aW9uKHBhcnQsIHR5cGUpIHtcbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChcImJsb2JcIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBCbG9iIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbcGFydF0sIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGJyb3dzZXIgb25seSwgb2xkIHdheVxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmdldEJsb2IodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gd2VsbCwgZnVjayA/IVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogY2FuJ3QgY29uc3RydWN0IHRoZSBCbG9iLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2FtZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogRmlsbCBpbiBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byBmaWxsIGluICh3aWxsIGJlIG11dGF0ZWQpLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIHRoZSBmdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAqIFRoaXMgY29udGFpbnMgc3RhdGljIGluZm9ybWF0aW9uIGFuZCBmdW5jdGlvbnMgdGhhdFxuICogY2FuIGJlIG9wdGltaXplZCBieSB0aGUgYnJvd3NlciBKSVQgY29tcGlsZXIuXG4gKi9cbnZhciBhcnJheVRvU3RyaW5nSGVscGVyID0ge1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBpbnQgaW50byBhIHN0cmluZywgY2h1bmsgYnkgY2h1bmsuXG4gICAgICogU2VlIHRoZSBwZXJmb3JtYW5jZXMgbm90ZXMgb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBjaHVuayB0aGUgY2h1bmsgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNodW5rIGlzIHRvbyBiaWcgZm9yIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNodW5rOiBmdW5jdGlvbihhcnJheSwgdHlwZSwgY2h1bmspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBrID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAvLyBzaG9ydGN1dFxuICAgICAgICBpZiAobGVuIDw9IGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnNsaWNlKGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc3ViYXJyYXkoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSBjaHVuaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gZXZlcnkgaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICogVGhpcyBpcyB0aGUgbmFpdmUgaW1wbGVtZW50YXRpb24sIHdoaWNoIGdlbmVyYXRlIEEgTE9UIG9mIGludGVybWVkaWF0ZSBzdHJpbmcuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIGV2ZXJ5dGhpbmcgZWxzZSBmYWlsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2hhcjogZnVuY3Rpb24oYXJyYXkpe1xuICAgICAgICB2YXIgcmVzdWx0U3RyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFN0cjtcbiAgICB9LFxuICAgIGFwcGx5Q2FuQmVVc2VkIDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIFVpbnQ4QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHVpbnQ4YXJyYXkgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC51aW50OGFycmF5ICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gbm9kZWpzIEJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIG5vZGVidWZmZXIgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC5ub2RlYnVmZmVyICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nKGFycmF5KSB7XG4gICAgLy8gUGVyZm9ybWFuY2VzIG5vdGVzIDpcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIGlzIHRoZSBmYXN0ZXN0LCBzZWVcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udmVydGluZy1hLXVpbnQ4YXJyYXktdG8tYS1zdHJpbmcvMlxuICAgIC8vIGJ1dCB0aGUgc3RhY2sgaXMgbGltaXRlZCAoYW5kIHdlIGNhbiBnZXQgaHVnZSBhcnJheXMgISkuXG4gICAgLy9cbiAgICAvLyByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7IGdlbmVyYXRlIHRvbyBtYW55IHN0cmluZ3MgIVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5YnVmZmVyLXRvLXN0cmluZy1hcHBseS1wZXJmb3JtYW5jZS8yXG4gICAgLy8gVE9ETyA6IHdlIG5vdyBoYXZlIHdvcmtlcnMgdGhhdCBzcGxpdCB0aGUgd29yay4gRG8gd2Ugc3RpbGwgbmVlZCB0aGF0ID9cbiAgICB2YXIgY2h1bmsgPSA2NTUzNixcbiAgICAgICAgdHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGFycmF5KSxcbiAgICAgICAgY2FuVXNlQXBwbHkgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSBcInVpbnQ4YXJyYXlcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQudWludDhhcnJheTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC5ub2RlYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChjYW5Vc2VBcHBseSkge1xuICAgICAgICB3aGlsZSAoY2h1bmsgPiAxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2h1bmsoYXJyYXksIHR5cGUsIGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoY2h1bmsgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGFwcGx5IG9yIGNodW5rIGVycm9yIDogc2xvdyBhbmQgcGFpbmZ1bCBhbGdvcml0aG1cbiAgICAvLyBkZWZhdWx0IGJyb3dzZXIgb24gYW5kcm9pZCA0LipcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNoYXIoYXJyYXkpO1xufVxuXG5leHBvcnRzLmFwcGx5RnJvbUNoYXJDb2RlID0gYXJyYXlMaWtlVG9TdHJpbmc7XG5cblxuLyoqXG4gKiBDb3B5IHRoZSBkYXRhIGZyb20gYW4gYXJyYXktbGlrZSB0byBhbiBvdGhlciBhcnJheS1saWtlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlGcm9tIHRoZSBvcmlnaW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheVRvIHRoZSBkZXN0aW5hdGlvbiBhcnJheSB3aGljaCB3aWxsIGJlIG11dGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgZGVzdGluYXRpb24gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvQXJyYXlMaWtlKGFycmF5RnJvbSwgYXJyYXlUbykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5VG9baV0gPSBhcnJheUZyb21baV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvO1xufVxuXG4vLyBhIG1hdHJpeCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB0cmFuc2Zvcm0gZXZlcnl0aGluZyBpbnRvIGV2ZXJ5dGhpbmcuXG52YXIgdHJhbnNmb3JtID0ge307XG5cbi8vIHN0cmluZyB0byA/XG50cmFuc2Zvcm1bXCJzdHJpbmdcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcInN0cmluZ1wiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoaW5wdXQubGVuZ3RoKSk7XG4gICAgfVxufTtcblxuLy8gYXJyYXkgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBpZGVudGl0eSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gYXJyYXlidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShuZXcgVWludDhBcnJheShpbnB1dCksIG5ldyBBcnJheShpbnB1dC5ieXRlTGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGlkZW50aXR5LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfVxufTtcblxuLy8gdWludDhhcnJheSB0byA/XG50cmFuc2Zvcm1bXCJ1aW50OGFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKGlucHV0KTtcbiAgICB9XG59O1xuXG4vLyBub2RlYnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBpZGVudGl0eVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW5wdXQgaW50byBhbnkgdHlwZS5cbiAqIFRoZSBzdXBwb3J0ZWQgb3V0cHV0IHR5cGUgYXJlIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIG5vZGVidWZmZXIuXG4gKiBJZiBubyBvdXRwdXQgdHlwZSBpcyBzcGVjaWZpZWQsIHRoZSB1bm1vZGlmaWVkIGlucHV0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0VHlwZSB0aGUgb3V0cHV0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gaW5wdXQgdGhlIGlucHV0IHRvIGNvbnZlcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgb3V0cHV0IHR5cGUuXG4gKi9cbmV4cG9ydHMudHJhbnNmb3JtVG8gPSBmdW5jdGlvbihvdXRwdXRUeXBlLCBpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkLCBudWxsLCBldGNcbiAgICAgICAgLy8gYW4gZW1wdHkgc3RyaW5nIHdvbid0IGhhcm0uXG4gICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFvdXRwdXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQob3V0cHV0VHlwZSk7XG4gICAgdmFyIGlucHV0VHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGlucHV0KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtW2lucHV0VHlwZV1bb3V0cHV0VHlwZV0oaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBUaGUgdHlwZSB3aWxsIGJlIGluIGEgZm9ybWF0IHZhbGlkIGZvciBKU1ppcC51dGlscy50cmFuc2Zvcm1UbyA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dCB0byBpZGVudGlmeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIChsb3dlcmNhc2UpIHR5cGUgb2YgdGhlIGlucHV0LlxuICovXG5leHBvcnRzLmdldFR5cGVPZiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyICYmIG5vZGVqc1V0aWxzLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gXCJub2RlYnVmZmVyXCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkgJiYgaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBcInVpbnQ4YXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQuYXJyYXlidWZmZXIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gXCJhcnJheWJ1ZmZlclwiO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSB0byBjaGVjay5cbiAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCB0eXBlLlxuICovXG5leHBvcnRzLmNoZWNrU3VwcG9ydCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgc3VwcG9ydGVkID0gc3VwcG9ydFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuTUFYX1ZBTFVFXzE2QklUUyA9IDY1NTM1O1xuZXhwb3J0cy5NQVhfVkFMVUVfMzJCSVRTID0gLTE7IC8vIHdlbGwsIFwiXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlwiIGlzIHBhcnNlZCBhcyAtMVxuXG4vKipcbiAqIFByZXR0aWZ5IGEgc3RyaW5nIHJlYWQgYXMgYmluYXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHByZXR0aWZ5LlxuICogQHJldHVybiB7c3RyaW5nfSBhIHByZXR0eSBzdHJpbmcuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIHJlcyA9ICcnLFxuICAgICAgICBjb2RlLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAoc3RyIHx8IFwiXCIpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgcmVzICs9ICdcXFxceCcgKyAoY29kZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIERlZmVyIHRoZSBjYWxsIG9mIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBhc3luY2hyb25vdXNseS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBnaXZlIHRvIHRoZSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0cy5kZWxheSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzLCBzZWxmKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiB8fCBudWxsLCBhcmdzIHx8IFtdKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRXh0ZW5kcyBhIHByb3RvdHlwZSB3aXRoIGFuIG90aGVyLCB3aXRob3V0IGNhbGxpbmcgYSBjb25zdHJ1Y3RvciB3aXRoXG4gKiBzaWRlIGVmZmVjdHMuIEluc3BpcmVkIGJ5IG5vZGVqcycgYHV0aWxzLmluaGVyaXRzYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3RvciB0aGUgY29uc3RydWN0b3IgdG8gYXVnbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDdG9yIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgdG8gdXNlXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgdmFyIE9iaiA9IGZ1bmN0aW9uKCkge307XG4gICAgT2JqLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgT2JqKCk7XG59O1xuXG4vKipcbiAqIE1lcmdlIHRoZSBvYmplY3RzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIGludG8gYSBuZXcgb25lLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBBbGwgb2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHdpdGggdGhlIGRhdGEgb2YgdGhlIG90aGVycy5cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGksIGF0dHI7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyAvLyBhcmd1bWVudHMgaXMgbm90IGVudW1lcmFibGUgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICBmb3IgKGF0dHIgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldLmhhc093blByb3BlcnR5KGF0dHIpICYmIHR5cGVvZiByZXN1bHRbYXR0cl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYXR0cl0gPSBhcmd1bWVudHNbaV1bYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFyYml0cmFyeSBjb250ZW50IGludG8gYSBQcm9taXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSBuYW1lIGZvciB0aGUgY29udGVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhIHRoZSBjb250ZW50IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IHRydWUgaWYgdGhlIGNvbnRlbnQgaXMgbm90IGFuIHVuaWNvZGUgc3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nIHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IG9ubHkgaGFzIG9uZSBieXRlIHBlciBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmFzZTY0IHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IGlzIGVuY29kZWQgd2l0aCBiYXNlNjQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgaW4gYSBmb3JtYXQgdXNhYmxlIGJ5IEpTWmlwLlxuICovXG5leHBvcnRzLnByZXBhcmVDb250ZW50ID0gZnVuY3Rpb24obmFtZSwgaW5wdXREYXRhLCBpc0JpbmFyeSwgaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIGlzQmFzZTY0KSB7XG5cbiAgICAvLyBpZiBpbnB1dERhdGEgaXMgYWxyZWFkeSBhIHByb21pc2UsIHRoaXMgZmxhdHRlbiBpdC5cbiAgICB2YXIgcHJvbWlzZSA9IGV4dGVybmFsLlByb21pc2UucmVzb2x2ZShpbnB1dERhdGEpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHZhciBpc0Jsb2IgPSBzdXBwb3J0LmJsb2IgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IFsnW29iamVjdCBGaWxlXScsICdbb2JqZWN0IEJsb2JdJ10uaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpICE9PSAtMSk7XG5cbiAgICAgICAgaWYgKGlzQmxvYiAmJiB0eXBlb2YgRmlsZVJlYWRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZS50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGRhdGEpO1xuXG4gICAgICAgIGlmICghZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHRoZSBkYXRhIG9mICdcIiArIG5hbWUgKyBcIicuIElzIGl0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbiBhIHN1cHBvcnRlZCBKYXZhU2NyaXB0IHR5cGUgKFN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIGV0YykgP1wiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgOiBpdCdzIHdheSBlYXNpZXIgdG8gd29yayB3aXRoIFVpbnQ4QXJyYXkgdGhhbiB3aXRoIEFycmF5QnVmZmVyXG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICBkYXRhID0gZXhwb3J0cy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0Jhc2U2NCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBiYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWRCaW5hcnlTdHJpbmcgPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgZmlsZSBoYXMgYWxyZWFkeSBiZWVuIGZpbHRlcmVkIHdpdGggYSAweEZGIG1hc2tcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHN0cmluZywgbm90IGluIGEgYmFzZTY0IGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmUgc3VyZSB0aGF0IHRoaXMgaXMgYSBjb3JyZWN0IFwiYmluYXJ5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzdHJpbmcyYmluYXJ5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc2lnID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbnZhciBaaXBFbnRyeSA9IHJlcXVpcmUoJy4vemlwRW50cnknKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gIGNsYXNzIFppcEVudHJpZXMge3t7XG4vKipcbiAqIEFsbCB0aGUgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJpZXMobG9hZE9wdGlvbnMpIHtcbiAgICB0aGlzLmZpbGVzID0gW107XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cmllcy5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgcmVhZGVyIGlzIG9uIHRoZSBzcGVjaWZpZWQgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFNpZ25hdHVyZSB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBhbiBvdGhlciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgY2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKGV4cGVjdGVkU2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuaW5kZXggLT0gNDtcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IHVuZXhwZWN0ZWQgc2lnbmF0dXJlIFwiICsgXCIoXCIgKyB1dGlscy5wcmV0dHkoc2lnbmF0dXJlKSArIFwiLCBleHBlY3RlZCBcIiArIHV0aWxzLnByZXR0eShleHBlY3RlZFNpZ25hdHVyZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBzaWduYXR1cmUgaXMgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhc2tlZEluZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byBleHBlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIGhlcmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1NpZ25hdHVyZTogZnVuY3Rpb24oYXNrZWRJbmRleCwgZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMucmVhZGVyLmluZGV4O1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChhc2tlZEluZGV4KTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzaWduYXR1cmUgPT09IGV4cGVjdGVkU2lnbmF0dXJlO1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChjdXJyZW50SW5kZXgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQmxvY2tFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgdGhpcy56aXBDb21tZW50TGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgLy8gd2FybmluZyA6IHRoZSBlbmNvZGluZyBkZXBlbmRzIG9mIHRoZSBzeXN0ZW0gbG9jYWxlXG4gICAgICAgIC8vIE9uIGEgbGludXggbWFjaGluZSB3aXRoIExBTkc9ZW5fVVMudXRmOCwgdGhpcyBmaWVsZCBpcyB1dGY4IGVuY29kZWQuXG4gICAgICAgIC8vIE9uIGEgd2luZG93cyBtYWNoaW5lLCB0aGlzIGZpZWxkIGlzIGVuY29kZWQgd2l0aCB0aGUgbG9jYWxpemVkIHdpbmRvd3MgY29kZSBwYWdlLlxuICAgICAgICB2YXIgemlwQ29tbWVudCA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHRoaXMuemlwQ29tbWVudExlbmd0aCk7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgLy8gVG8gZ2V0IGNvbnNpc3RlbnQgYmVoYXZpb3Igd2l0aCB0aGUgZ2VuZXJhdGlvbiBwYXJ0LCB3ZSB3aWxsIGFzc3VtZSB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgdXRmOCBlbmNvZGVkIHVubGVzcyBzcGVjaWZpZWQgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgZGVjb2RlQ29udGVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgemlwQ29tbWVudCk7XG4gICAgICAgIHRoaXMuemlwQ29tbWVudCA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZGVjb2RlQ29udGVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKiBOb3QgbWVyZ2VkIHdpdGggdGhlIG1ldGhvZCByZWFkRW5kT2ZDZW50cmFsIDpcbiAgICAgKiBUaGUgZW5kIG9mIGNlbnRyYWwgY2FuIGNvZXhpc3Qgd2l0aCBpdHMgWmlwNjQgYnJvdGhlcixcbiAgICAgKiBJIGRvbid0IHdhbnQgdG8gcmVhZCB0aGUgd3JvbmcgbnVtYmVyIG9mIGJ5dGVzICFcbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2tpcCg0KTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTWFkZUJ5ID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuXG4gICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YSA9IHt9O1xuICAgICAgICB2YXIgZXh0cmFEYXRhU2l6ZSA9IHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplIC0gNDQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBleHRyYURhdGFTaXplKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSB0aGlzLnJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YVtleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgWmlwIDY0IGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IuXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrV2l0aFppcDY0Q2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5kaXNrc0NvdW50ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgaWYgKHRoaXMuZGlza3NDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpLXZvbHVtZXMgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBmaWxlcywgYmFzZWQgb24gdGhlIG9mZnNldCByZWFkIGluIHRoZSBjZW50cmFsIHBhcnQuXG4gICAgICovXG4gICAgcmVhZExvY2FsRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZmlsZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoZmlsZS5sb2NhbEhlYWRlck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG4gICAgICAgICAgICBmaWxlLnJlYWRMb2NhbFBhcnQodGhpcy5yZWFkZXIpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGVVVEY4KCk7XG4gICAgICAgICAgICBmaWxlLnByb2Nlc3NBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsRGlyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpbGU7XG5cbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5jZW50cmFsRGlyT2Zmc2V0KTtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgIGZpbGUgPSBuZXcgWmlwRW50cnkoe1xuICAgICAgICAgICAgICAgIHppcDY0OiB0aGlzLnppcDY0XG4gICAgICAgICAgICB9LCB0aGlzLmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgIGZpbGUucmVhZENlbnRyYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSB0aGlzLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IDAgJiYgdGhpcy5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBleHBlY3RlZCBzb21lIHJlY29yZHMgYnV0IGNvdWxkbid0IGZpbmQgQU5ZLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IHN1c3BpY2lvdXMsIGFzIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiBleHBlY3RlZCBcIiArIHRoaXMuY2VudHJhbERpclJlY29yZHMgKyBcIiByZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3QgXCIgKyB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgcmVjb3JkcyBidXQgbm90IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmcgYnV0IHdlIGdvdCBzb21ldGhpbmcgZm9yIHRoZSB1c2VyOiBubyBlcnJvciBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcImV4cGVjdGVkXCIsIHRoaXMuY2VudHJhbERpclJlY29yZHMsIFwicmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290XCIsIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudCBpcyBhIHRydW5jYXRlZCB6aXAgb3IgY29tcGxldGUgZ2FyYmFnZS5cbiAgICAgICAgICAgIC8vIEEgXCJMT0NBTF9GSUxFX0hFQURFUlwiIGlzIG5vdCByZXF1aXJlZCBhdCB0aGUgYmVnaW5uaW5nIChhdXRvXG4gICAgICAgICAgICAvLyBleHRyYWN0aWJsZSB6aXAgZm9yIGV4YW1wbGUpIGJ1dCBpdCBjYW4gZ2l2ZSBhIGdvb2QgaGludC5cbiAgICAgICAgICAgIC8vIElmIGFuIGFqYXggcmVxdWVzdCB3YXMgdXNlZCB3aXRob3V0IHJlc3BvbnNlVHlwZSwgd2Ugd2lsbCBhbHNvXG4gICAgICAgICAgICAvLyBnZXQgdW5yZWFkYWJsZSBkYXRhLlxuICAgICAgICAgICAgdmFyIGlzR2FyYmFnZSA9ICF0aGlzLmlzU2lnbmF0dXJlKDAsIHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG5cbiAgICAgICAgICAgIGlmIChpc0dhcmJhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSA6IGlzIHRoaXMgYSB6aXAgZmlsZSA/IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZiBpdCBpcywgc2VlIGh0dHBzOi8vc3R1ay5naXRodWIuaW8vanN6aXAvZG9jdW1lbnRhdGlvbi9ob3d0by9yZWFkX3ppcC5odG1sXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgIHZhciBlbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIHRoaXMucmVhZEJsb2NrRW5kT2ZDZW50cmFsKCk7XG5cblxuICAgICAgICAvKiBleHRyYWN0IGZyb20gdGhlIHppcCBzcGVjIDpcbiAgICAgICAgICAgIDQpICBJZiBvbmUgb2YgdGhlIGZpZWxkcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgcmVjb3JkIGlzIHRvbyBzbWFsbCB0byBob2xkIHJlcXVpcmVkIGRhdGEsIHRoZSBmaWVsZFxuICAgICAgICAgICAgICAgIHNob3VsZCBiZSBzZXQgdG8gLTEgKDB4RkZGRiBvciAweEZGRkZGRkZGKSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWklQNjQgZm9ybWF0IHJlY29yZCBzaG91bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgICAgIDUpICBUaGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWmlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IgcmVjb3JkIG11c3RcbiAgICAgICAgICAgICAgICByZXNpZGUgb24gdGhlIHNhbWUgZGlzayB3aGVuIHNwbGl0dGluZyBvciBzcGFubmluZ1xuICAgICAgICAgICAgICAgIGFuIGFyY2hpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTIHx8IHRoaXMuY2VudHJhbERpck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy56aXA2NCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBXYXJuaW5nIDogdGhlIHppcDY0IGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQsIGJ1dCBPTkxZIGlmIHRoZSA2NGJpdHMgaW50ZWdlciByZWFkIGZyb21cbiAgICAgICAgICAgIHRoZSB6aXAgZmlsZSBjYW4gZml0IGludG8gYSAzMmJpdHMgaW50ZWdlci4gVGhpcyBjYW5ub3QgYmUgc29sdmVkIDogSmF2YVNjcmlwdCByZXByZXNlbnRzXG4gICAgICAgICAgICBhbGwgbnVtYmVycyBhcyA2NC1iaXQgZG91YmxlIHByZWNpc2lvbiBJRUVFIDc1NCBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxuICAgICAgICAgICAgU28sIHdlIGhhdmUgNTNiaXRzIGZvciBpbnRlZ2VycyBhbmQgYml0d2lzZSBvcGVyYXRpb25zIHRyZWF0IGV2ZXJ5dGhpbmcgYXMgMzJiaXRzLlxuICAgICAgICAgICAgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzXG4gICAgICAgICAgICBhbmQgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VDTUEtMjYyLnBkZiBzZWN0aW9uIDguNVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gc2hvdWxkIGxvb2sgZm9yIGEgemlwNjQgRU9DRCBsb2NhdG9yXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUik7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3IoKTtcblxuICAgICAgICAgICAgLy8gbm93IHRoZSB6aXA2NCBFT0NEIHJlY29yZFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2lnbmF0dXJlKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciwgc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgbm90IHdoZXJlIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgKyB0aGlzLmNlbnRyYWxEaXJTaXplO1xuICAgICAgICBpZiAodGhpcy56aXA2NCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMjA7IC8vIGVuZCBvZiBjZW50cmFsIGRpciA2NCBsb2NhdG9yXG4gICAgICAgICAgICBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCArPSAxMiAvKiBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxlYWRpbmcgMTIgYnl0ZXMgKi8gKyB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRyYUJ5dGVzID0gZW5kT2ZDZW50cmFsRGlyT2Zmc2V0IC0gZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oZXh0cmFCeXRlcywgXCJleHRyYSBieXRlcyBhdCBiZWdpbm5pbmcgb3Igd2l0aGluIHppcGZpbGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NpZ25hdHVyZShlbmRPZkNlbnRyYWxEaXJPZmZzZXQsIHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvZmZzZXRzIHNlZW0gd3JvbmcsIGJ1dCB3ZSBoYXZlIHNvbWV0aGluZyBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldC5cbiAgICAgICAgICAgICAgICAvLyBTb+KApiB3ZSBrZWVwIGl0LlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IGlzIHdyb25nLCB1cGRhdGUgdGhlIFwiemVyb1wiIG9mIHRoZSByZWFkZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaWYgZGF0YSBoYXMgYmVlbiBwcmVwZW5kZWQgKGNyeCBmaWxlcyBmb3IgZXhhbXBsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci56ZXJvID0gZXh0cmFCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogbWlzc2luZyBcIiArIE1hdGguYWJzKGV4dHJhQnl0ZXMpICsgXCIgYnl0ZXMuXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmVwYXJlUmVhZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyRm9yKGRhdGEpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHppcCBmaWxlIGFuZCBjcmVhdGUgWmlwRW50cmllcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgYmluYXJ5IHN0cmluZyByZXByZXNlbnRpbmcgYSB6aXAgZmlsZS5cbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlYWRlcihkYXRhKTtcbiAgICAgICAgdGhpcy5yZWFkRW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIHRoaXMucmVhZENlbnRyYWxEaXIoKTtcbiAgICAgICAgdGhpcy5yZWFkTG9jYWxGaWxlcygpO1xuICAgIH1cbn07XG4vLyB9fX0gZW5kIG9mIFppcEVudHJpZXNcbm1vZHVsZS5leHBvcnRzID0gWmlwRW50cmllcztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWFkZXJGb3IgPSByZXF1aXJlKCcuL3JlYWRlci9yZWFkZXJGb3InKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgY3JjMzJmbiA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgY29tcHJlc3Npb25zID0gcmVxdWlyZSgnLi9jb21wcmVzc2lvbnMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG5cbnZhciBNQURFX0JZX0RPUyA9IDB4MDA7XG52YXIgTUFERV9CWV9VTklYID0gMHgwMztcblxuLyoqXG4gKiBGaW5kIGEgY29tcHJlc3Npb24gcmVnaXN0ZXJlZCBpbiBKU1ppcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wcmVzc2lvbk1ldGhvZCB0aGUgbWV0aG9kIG1hZ2ljIHRvIGZpbmQuXG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gdGhlIEpTWmlwIGNvbXByZXNzaW9uIG9iamVjdCwgbnVsbCBpZiBub25lIGZvdW5kLlxuICovXG52YXIgZmluZENvbXByZXNzaW9uID0gZnVuY3Rpb24oY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gY29tcHJlc3Npb25zKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Npb25zLmhhc093blByb3BlcnR5KG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc2lvbnNbbWV0aG9kXS5tYWdpYyA9PT0gY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2lvbnNbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIGNsYXNzIFppcEVudHJ5IHt7e1xuLyoqXG4gKiBBbiBlbnRyeSBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2YgdGhlIGN1cnJlbnQgZmlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJ5KG9wdGlvbnMsIGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnM7XG59XG5aaXBFbnRyeS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRW5jcnlwdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDEgaXMgc2V0XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRGbGFnICYgMHgwMDAxKSA9PT0gMHgwMDAxO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGhhcyB1dGYtOCBmaWxlbmFtZS9jb21tZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZpbGVuYW1lL2NvbW1lbnQgaXMgaW4gdXRmLTgsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB1c2VVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDExIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRMb2NhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgY29tcHJlc3Npb24sIGxvY2FsRXh0cmFGaWVsZHNMZW5ndGg7XG5cbiAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IGV2ZXJ5dGhpbmcgZnJvbSB0aGUgY2VudHJhbCBkaXIgIVxuICAgICAgICAvLyBJZiB0aGUgY2VudHJhbCBkaXIgZGF0YSBhcmUgZmFsc2UsIHdlIGFyZSBkb29tZWQuXG4gICAgICAgIC8vIE9uIHRoZSBicmlnaHQgc2lkZSwgdGhlIGxvY2FsIHBhcnQgaXMgc2NhcnkgIDogemlwNjQsIGRhdGEgZGVzY3JpcHRvcnMsIGJvdGgsIGV0Yy5cbiAgICAgICAgLy8gVGhlIGxlc3MgZGF0YSB3ZSBnZXQgaGVyZSwgdGhlIG1vcmUgcmVsaWFibGUgdGhpcyBzaG91bGQgYmUuXG4gICAgICAgIC8vIExldCdzIHNraXAgdGhlIHdob2xlIGhlYWRlciBhbmQgZGFzaCB0byB0aGUgZGF0YSAhXG4gICAgICAgIHJlYWRlci5za2lwKDIyKTtcbiAgICAgICAgLy8gaW4gc29tZSB6aXAgY3JlYXRlZCBvbiB3aW5kb3dzLCB0aGUgZmlsZW5hbWUgc3RvcmVkIGluIHRoZSBjZW50cmFsIGRpciBjb250YWlucyBcXCBpbnN0ZWFkIG9mIC8uXG4gICAgICAgIC8vIFN0cmFuZ2VseSwgdGhlIGZpbGVuYW1lIGhlcmUgaXMgT0suXG4gICAgICAgIC8vIEkgd291bGQgbG92ZSB0byB0cmVhdCB0aGVzZSB6aXAgZmlsZXMgYXMgY29ycnVwdGVkIChzZWUgaHR0cDovL3d3dy5pbmZvLXppcC5vcmcvRkFRLmh0bWwjYmFja3NsYXNoZXNcbiAgICAgICAgLy8gb3IgQVBQTk9URSM0LjQuMTcuMSwgXCJBbGwgc2xhc2hlcyBNVVNUIGJlIGZvcndhcmQgc2xhc2hlcyAnLydcIikgYnV0IHRoZXJlIGFyZSBhIGxvdCBvZiBiYWQgemlwIGdlbmVyYXRvcnMuLi5cbiAgICAgICAgLy8gU2VhcmNoIFwidW56aXAgbWlzbWF0Y2hpbmcgXCJsb2NhbFwiIGZpbGVuYW1lIGNvbnRpbnVpbmcgd2l0aCBcImNlbnRyYWxcIiBmaWxlbmFtZSB2ZXJzaW9uXCIgb25cbiAgICAgICAgLy8gdGhlIGludGVybmV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJIHRoaW5rIEkgc2VlIHRoZSBsb2dpYyBoZXJlIDogdGhlIGNlbnRyYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZGlzcGxheVxuICAgICAgICAvLyBjb250ZW50IGFuZCB0aGUgbG9jYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZXh0cmFjdCB0aGUgZmlsZXMuIE1peGluZyAvIGFuZCBcXFxuICAgICAgICAvLyBtYXkgYmUgdXNlZCB0byBkaXNwbGF5IFxcIHRvIHdpbmRvd3MgdXNlcnMgYW5kIHVzZSAvIHdoZW4gZXh0cmFjdGluZyB0aGUgZmlsZXMuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgbGVhZCBhbHNvIHRvIHNvbWUgaXNzdWVzIDogaHR0cDovL3NlY2xpc3RzLm9yZy9mdWxsZGlzY2xvc3VyZS8yMDA5L1NlcC8zOTRcbiAgICAgICAgdGhpcy5maWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7IC8vIGNhbid0IGJlIHN1cmUgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBjZW50cmFsIGRpclxuICAgICAgICAvLyB0aGUgZmlsZU5hbWUgaXMgc3RvcmVkIGFzIGJpbmFyeSBkYXRhLCB0aGUgaGFuZGxlVVRGOCBtZXRob2Qgd2lsbCB0YWtlIGNhcmUgb2YgdGhlIGVuY29kaW5nLlxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICByZWFkZXIuc2tpcChsb2NhbEV4dHJhRmllbGRzTGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdGhpcy51bmNvbXByZXNzZWRTaXplID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIG9yIGNvcnJ1cHRlZCB6aXAgOiBkaWRuJ3QgZ2V0IGVub3VnaCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBcIiArIFwiKGNvbXByZXNzZWRTaXplID09PSAtMSB8fCB1bmNvbXByZXNzZWRTaXplID09PSAtMSlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wcmVzc2lvbiA9IGZpbmRDb21wcmVzc2lvbih0aGlzLmNvbXByZXNzaW9uTWV0aG9kKTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBudWxsKSB7IC8vIG5vIGNvbXByZXNzaW9uIGZvdW5kXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogY29tcHJlc3Npb24gXCIgKyB1dGlscy5wcmV0dHkodGhpcy5jb21wcmVzc2lvbk1ldGhvZCkgKyBcIiB1bmtub3duIChpbm5lciBmaWxlIDogXCIgKyB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLmZpbGVOYW1lKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY29tcHJlc3NlZCA9IG5ldyBDb21wcmVzc2VkT2JqZWN0KHRoaXMuY29tcHJlc3NlZFNpemUsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSwgdGhpcy5jcmMzMiwgY29tcHJlc3Npb24sIHJlYWRlci5yZWFkRGF0YSh0aGlzLmNvbXByZXNzZWRTaXplKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZENlbnRyYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uTWFkZUJ5ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHJlYWRlci5za2lwKDIpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25OZWVkZWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5iaXRGbGFnID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSByZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgdGhpcy5kYXRlID0gcmVhZGVyLnJlYWREYXRlKCk7XG4gICAgICAgIHRoaXMuY3JjMzIgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdmFyIGZpbGVOYW1lTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudExlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmludGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSByZWFkZXIucmVhZEludCg0KTtcblxuICAgICAgICBpZiAodGhpcy5pc0VuY3J5cHRlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0ZWQgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2lsbCBiZSByZWFkIGluIHRoZSBsb2NhbCBwYXJ0LCBzZWUgdGhlIGNvbW1lbnRzIHRoZXJlXG4gICAgICAgIHJlYWRlci5za2lwKGZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5yZWFkRXh0cmFGaWVsZHMocmVhZGVyKTtcbiAgICAgICAgdGhpcy5wYXJzZVpJUDY0RXh0cmFGaWVsZChyZWFkZXIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50ID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZUNvbW1lbnRMZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIGFuZCBnZXQgdGhlIHVuaXgvZG9zIHBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIHByb2Nlc3NBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBtYWRlQnkgPSB0aGlzLnZlcnNpb25NYWRlQnkgPj4gODtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRoZSBET1MgZGlyZWN0b3J5IGZsYWcgc2V0LlxuICAgICAgICAvLyBXZSBsb29rIGZvciBpdCBpbiB0aGUgRE9TIGFuZCBVTklYIHBlcm1pc3Npb25zXG4gICAgICAgIC8vIGJ1dCBzb21lIHVua25vd24gcGxhdGZvcm0gY291bGQgc2V0IGl0IGFzIGEgY29tcGF0aWJpbGl0eSBmbGFnLlxuICAgICAgICB0aGlzLmRpciA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4MDAxMCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfRE9TKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCA2IGJpdHMgKDAgdG8gNSlcbiAgICAgICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDNGO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX1VOSVgpIHtcbiAgICAgICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gKHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA+PiAxNikgJiAweEZGRkY7XG4gICAgICAgICAgICAvLyB0aGUgb2N0YWwgcGVybWlzc2lvbnMgYXJlIGluICh0aGlzLnVuaXhQZXJtaXNzaW9ucyAmIDB4MDFGRikudG9TdHJpbmcoOCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmYWlsIHNhZmUgOiBpZiB0aGUgbmFtZSBlbmRzIHdpdGggYSAvIGl0IHByb2JhYmx5IG1lYW5zIGEgZm9sZGVyXG4gICAgICAgIGlmICghdGhpcy5kaXIgJiYgdGhpcy5maWxlTmFtZVN0ci5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICAgICAgdGhpcy5kaXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBaSVA2NCBleHRyYSBmaWVsZCBhbmQgbWVyZ2UgdGhlIGluZm8gaW4gdGhlIGN1cnJlbnQgWmlwRW50cnkuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcGFyc2VaSVA2NEV4dHJhRmllbGQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkc1sweDAwMDFdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG91bGQgYmUgc29tZXRoaW5nLCBwcmVwYXJpbmcgdGhlIGV4dHJhIHJlYWRlclxuICAgICAgICB2YXIgZXh0cmFSZWFkZXIgPSByZWFkZXJGb3IodGhpcy5leHRyYUZpZWxkc1sweDAwMDFdLnZhbHVlKTtcblxuICAgICAgICAvLyBJIHJlYWxseSBob3BlIHRoYXQgdGhlc2UgNjRiaXRzIGludGVnZXIgY2FuIGZpdCBpbiAzMiBiaXRzIGludGVnZXIsIGJlY2F1c2UganNcbiAgICAgICAgLy8gd29uJ3QgbGV0IHVzIGhhdmUgbW9yZS5cbiAgICAgICAgaWYgKHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2tOdW1iZXJTdGFydCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSBleHRyYVJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRFeHRyYUZpZWxkczogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHZhciBlbmQgPSByZWFkZXIuaW5kZXggKyB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyZWFkZXIuaW5kZXggKyA0IDwgZW5kKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcblxuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkc1tleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZWFkZXIuc2V0SW5kZXgoZW5kKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFwcGx5IGFuIFVURjggdHJhbnNmb3JtYXRpb24gaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIGhhbmRsZVVURjg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIGlmICh0aGlzLnVzZVVURjgoKSkge1xuICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHV0ZjgudXRmOGRlY29kZSh0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBhdGggPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh1cGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1cGF0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWVCeXRlQXJyYXkgPSAgdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShmaWxlTmFtZUJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1Y29tbWVudCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCgpO1xuICAgICAgICAgICAgaWYgKHVjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHVjb21tZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBU0NJSSB0ZXh0IG9yIHVuc3VwcG9ydGVkIGNvZGUgcGFnZVxuICAgICAgICAgICAgICAgIHZhciBjb21tZW50Qnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoY29tbWVudEJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBwYXRoIGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgcGF0aCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cGF0aEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDcwNzVdO1xuICAgICAgICBpZiAodXBhdGhGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVwYXRoRmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBmaWxlbmFtZSBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlTmFtZSkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1cGF0aEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBjb21tZW50IGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgY29tbWVudCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1Y29tbWVudEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDYzNzVdO1xuICAgICAgICBpZiAodWNvbW1lbnRGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVjb21tZW50RmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBjb21tZW50IGNoYW5nZWQsIHRoaXMgZmllbGQgaXMgb3V0IG9mIGRhdGUuXG4gICAgICAgICAgICBpZiAoY3JjMzJmbih0aGlzLmZpbGVDb21tZW50KSAhPT0gZXh0cmFSZWFkZXIucmVhZEludCg0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRmOC51dGY4ZGVjb2RlKGV4dHJhUmVhZGVyLnJlYWREYXRhKHVjb21tZW50RmllbGQubGVuZ3RoIC0gNSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFXb3JrZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSBzaW1wbGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGZpbGUgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKi9cbnZhciBaaXBPYmplY3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRpciA9IG9wdGlvbnMuZGlyO1xuICAgIHRoaXMuZGF0ZSA9IG9wdGlvbnMuZGF0ZTtcbiAgICB0aGlzLmNvbW1lbnQgPSBvcHRpb25zLmNvbW1lbnQ7XG4gICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBvcHRpb25zLnVuaXhQZXJtaXNzaW9ucztcbiAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gb3B0aW9ucy5kb3NQZXJtaXNzaW9ucztcblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuX2RhdGFCaW5hcnkgPSBvcHRpb25zLmJpbmFyeTtcbiAgICAvLyBrZWVwIG9ubHkgdGhlIGNvbXByZXNzaW9uXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBjb21wcmVzc2lvbiA6IG9wdGlvbnMuY29tcHJlc3Npb24sXG4gICAgICAgIGNvbXByZXNzaW9uT3B0aW9ucyA6IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zXG4gICAgfTtcbn07XG5cblppcE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGludGVybmFsIHN0cmVhbSBmb3IgdGhlIGNvbnRlbnQgb2YgdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcmV0dXJuIFN0cmVhbUhlbHBlciB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGludGVybmFsU3RyZWFtOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCwgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBhc2tVbmljb2RlU3RyaW5nID0gb3V0cHV0VHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIjtcbiAgICAgICAgICAgIGlmIChvdXRwdXRUeXBlID09PSBcImJpbmFyeXN0cmluZ1wiIHx8IG91dHB1dFR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG5cbiAgICAgICAgICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSAhdGhpcy5fZGF0YUJpbmFyeTtcblxuICAgICAgICAgICAgaWYgKGlzVW5pY29kZVN0cmluZyAmJiAhYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVW5pY29kZVN0cmluZyAmJiBhc2tVbmljb2RlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOERlY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHJlc3VsdCwgb3V0cHV0VHlwZSwgXCJcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgaW4gdGhlIGFza2VkIHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIG9mIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmM6IGZ1bmN0aW9uICh0eXBlLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0cmVhbSh0eXBlKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgY29udGVudCBhcyBhIG5vZGVqcyBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBTdHJlYW0gdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBub2RlU3RyZWFtOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSB8fCBcIm5vZGVidWZmZXJcIikudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB3b3JrZXIgZm9yIHRoZSBjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9jb21wcmVzc1dvcmtlcjogZnVuY3Rpb24gKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgJiZcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29tcHJlc3Npb24ubWFnaWMgPT09IGNvbXByZXNzaW9uLm1hZ2ljXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0Q29tcHJlc3NlZFdvcmtlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlY29tcHJlc3NXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9kYXRhQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOEVuY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20ocmVzdWx0LCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgZGVjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9kZWNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbnRlbnRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIodGhpcy5fZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcmVtb3ZlZE1ldGhvZHMgPSBbXCJhc1RleHRcIiwgXCJhc0JpbmFyeVwiLCBcImFzTm9kZUJ1ZmZlclwiLCBcImFzVWludDhBcnJheVwiLCBcImFzQXJyYXlCdWZmZXJcIl07XG52YXIgcmVtb3ZlZEZuID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xufTtcblxuZm9yKHZhciBpID0gMDsgaSA8IHJlbW92ZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgWmlwT2JqZWN0LnByb3RvdHlwZVtyZW1vdmVkTWV0aG9kc1tpXV0gPSByZW1vdmVkRm47XG59XG5tb2R1bGUuZXhwb3J0cyA9IFppcE9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSByZXF1aXJlKCdpbW1lZGlhdGUnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIElOVEVSTkFMKCkge31cblxudmFyIGhhbmRsZXJzID0ge307XG5cbnZhciBSRUpFQ1RFRCA9IFsnUkVKRUNURUQnXTtcbnZhciBGVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xudmFyIFBFTkRJTkcgPSBbJ1BFTkRJTkcnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm91dGNvbWUgPSB2b2lkIDA7XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUodGhpcywgcmVzb2x2ZXIpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdGhpcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIHllcyAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbih5ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICBmdW5jdGlvbiBubyAoKSB7XG4gICAgICB0aHJvdyByZWFzb247XG4gICAgfVxuICAgIHJldHVybiBwLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihubyk7XG4gIH1cbn07XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgIT09ICdmdW5jdGlvbicgJiYgdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEIHx8XG4gICAgdHlwZW9mIG9uUmVqZWN0ZWQgIT09ICdmdW5jdGlvbicgJiYgdGhpcy5zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKElOVEVSTkFMKTtcbiAgaWYgKHRoaXMuc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICB2YXIgcmVzb2x2ZXIgPSB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgPyBvbkZ1bGZpbGxlZCA6IG9uUmVqZWN0ZWQ7XG4gICAgdW53cmFwKHByb21pc2UsIHJlc29sdmVyLCB0aGlzLm91dGNvbWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucXVldWUucHVzaChuZXcgUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5mdW5jdGlvbiBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZDtcbiAgICB0aGlzLmNhbGxGdWxmaWxsZWQgPSB0aGlzLm90aGVyQ2FsbEZ1bGZpbGxlZDtcbiAgfVxuICBpZiAodHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSBvblJlamVjdGVkO1xuICAgIHRoaXMuY2FsbFJlamVjdGVkID0gdGhpcy5vdGhlckNhbGxSZWplY3RlZDtcbiAgfVxufVxuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlc29sdmUodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vbkZ1bGZpbGxlZCwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlamVjdCh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25SZWplY3RlZCwgdmFsdWUpO1xufTtcblxuZnVuY3Rpb24gdW53cmFwKHByb21pc2UsIGZ1bmMsIHZhbHVlKSB7XG4gIGltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGZ1bmModmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZSk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gcHJvbWlzZSkge1xuICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmhhbmRsZXJzLnJlc29sdmUgPSBmdW5jdGlvbiAoc2VsZiwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKGdldFRoZW4sIHZhbHVlKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHNlbGYsIHJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgdmFyIHRoZW5hYmxlID0gcmVzdWx0LnZhbHVlO1xuXG4gIGlmICh0aGVuYWJsZSkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICBzZWxmLm91dGNvbWUgPSB2YWx1ZTtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBzZWxmLnF1ZXVlW2ldLmNhbGxGdWxmaWxsZWQodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5oYW5kbGVycy5yZWplY3QgPSBmdW5jdGlvbiAoc2VsZiwgZXJyb3IpIHtcbiAgc2VsZi5zdGF0ZSA9IFJFSkVDVEVEO1xuICBzZWxmLm91dGNvbWUgPSBlcnJvcjtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgc2VsZi5xdWV1ZVtpXS5jYWxsUmVqZWN0ZWQoZXJyb3IpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufTtcblxuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgLy8gTWFrZSBzdXJlIHdlIG9ubHkgYWNjZXNzIHRoZSBhY2Nlc3NvciBvbmNlIGFzIHJlcXVpcmVkIGJ5IHRoZSBzcGVjXG4gIHZhciB0aGVuID0gb2JqICYmIG9iai50aGVuO1xuICBpZiAob2JqICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmdW5jdGlvbiBhcHB5VGhlbigpIHtcbiAgICAgIHRoZW4uYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHNlbGYsIHRoZW5hYmxlKSB7XG4gIC8vIEVpdGhlciBmdWxmaWxsLCByZWplY3Qgb3IgcmVqZWN0IHdpdGggZXJyb3JcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbkVycm9yKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlamVjdChzZWxmLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblN1Y2Nlc3ModmFsdWUpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgaGFuZGxlcnMucmVzb2x2ZShzZWxmLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlUb1Vud3JhcCgpIHtcbiAgICB0aGVuYWJsZShvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRyeVRvVW53cmFwKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICBvbkVycm9yKHJlc3VsdC52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goZnVuYywgdmFsdWUpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB0cnkge1xuICAgIG91dC52YWx1ZSA9IGZ1bmModmFsdWUpO1xuICAgIG91dC5zdGF0dXMgPSAnc3VjY2Vzcyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvdXQuc3RhdHVzID0gJ2Vycm9yJztcbiAgICBvdXQudmFsdWUgPSBlO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cblByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG5mdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHRoaXMpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXJzLnJlc29sdmUobmV3IHRoaXMoSU5URVJOQUwpLCB2YWx1ZSk7XG59XG5cblByb21pc2UucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcbiAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCByZWFzb24pO1xufVxuXG5Qcm9taXNlLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gIHZhciByZXNvbHZlZCA9IDA7XG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhbGxSZXNvbHZlcihpdGVyYWJsZVtpXSwgaSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIGFsbFJlc29sdmVyKHZhbHVlLCBpKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmVGcm9tQWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZyb21BbGwob3V0VmFsdWUpIHtcbiAgICAgIHZhbHVlc1tpXSA9IG91dFZhbHVlO1xuICAgICAgaWYgKCsrcmVzb2x2ZWQgPT09IGxlbiAmJiAhY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUHJvbWlzZS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHJlc29sdmVyKGl0ZXJhYmxlW2ldKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gcmVzb2x2ZXIodmFsdWUpIHtcbiAgICBzZWxmLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgPyBzZXRJbW1lZGlhdGUgOlxuXHRmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHRcdGFyZ3Muc3BsaWNlKDEsIDAsIDApO1xuXHRcdHNldFRpbWVvdXQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsImltcG9ydCBKU1ppcCBmcm9tIFwianN6aXBcIjtcbmltcG9ydCB7SXVwbG9hZGZpbGVMaXN0fSBmcm9tIFwiLi9JQ29tbW9uXCI7XG5pbXBvcnQge2dldEJpbmFyeUNvbnRlbnR9IGZyb20gXCIuL2NvbW1vbi9tZXRob2RcIlxuXG5cbmV4cG9ydCBjbGFzcyBIYW5kbGVaaXB7XG4gICAgdXBsb2FkRmlsZTpGaWxlOyBcbiAgICB3b3JrQm9vazpKU1ppcDsgXG4gICAgXG4gICAgY29uc3RydWN0b3IoZmlsZTpGaWxlIHwgdm9pZCl7XG4gICAgICAgIGlmKGZpbGUgaW5zdGFuY2VvZiBGaWxlKXtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZSA9IGZpbGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1bnppcEZpbGUoc3VjY2Vzc0Z1bmM6KGZpbGU6SXVwbG9hZGZpbGVMaXN0KT0+dm9pZCwgZXJyb3JGdW5jOihlcnI6RXJyb3IpPT52b2lkKTp2b2lkIHsgXG4gICAgICAgIC8vIHZhciBuZXdfemlwOkpTWmlwID0gbmV3IEpTWmlwKCk7XG4gICAgICAgIEpTWmlwLmxvYWRBc3luYyh0aGlzLnVwbG9hZEZpbGUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxKSByZWFkIHRoZSBCbG9iXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHppcDphbnkpIHtcbiAgICAgICAgICAgIGxldCBmaWxlTGlzdDpJdXBsb2FkZmlsZUxpc3QgPSA8SXVwbG9hZGZpbGVMaXN0Pnt9LCBsYXN0SW5kZXg6bnVtYmVyID0gT2JqZWN0LmtleXMoemlwLmZpbGVzKS5sZW5ndGgsIGluZGV4Om51bWJlcj0wO1xuICAgICAgICAgICAgemlwLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aDphbnksIHppcEVudHJ5OmFueSkgeyAgLy8gMikgcHJpbnQgZW50cmllc1xuICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IHppcEVudHJ5Lm5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lQXJyID0gZmlsZU5hbWUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSBmaWxlTmFtZUFycltmaWxlTmFtZUFyci5sZW5ndGgtMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBsZXQgZmlsZVR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgICAgIGlmKHN1ZmZpeCBpbiB7XCJwbmdcIjoxLCBcImpwZWdcIjoxLCBcImpwZ1wiOjEsIFwiZ2lmXCI6MSxcImJtcFwiOjEsXCJ0aWZcIjoxLFwid2VicFwiOjEsfSl7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlID0gXCJiYXNlNjRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdWZmaXg9PVwiZW1mXCIpe1xuICAgICAgICAgICAgICAgICAgICBmaWxlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgemlwRW50cnkuYXN5bmMoZmlsZVR5cGUpLnRoZW4oZnVuY3Rpb24gKGRhdGE6c3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGZpbGVUeXBlPT1cImJhc2U2NFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBcImRhdGE6aW1hZ2UvXCIrIHN1ZmZpeCArXCI7YmFzZTY0LFwiICsgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaWxlTGlzdFt6aXBFbnRyeS5uYW1lXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZihsYXN0SW5kZXg9PWluZGV4KzEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0Z1bmMoZmlsZUxpc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICB9LCBmdW5jdGlvbiAoZTpFcnJvcikge1xuICAgICAgICAgICAgZXJyb3JGdW5jKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1bnppcEZpbGVCeVVybCh1cmw6c3RyaW5nLHN1Y2Nlc3NGdW5jOihmaWxlOkl1cGxvYWRmaWxlTGlzdCk9PnZvaWQsIGVycm9yRnVuYzooZXJyOkVycm9yKT0+dm9pZCk6dm9pZCB7IFxuICAgICAgICB2YXIgbmV3X3ppcDpKU1ppcCA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBnZXRCaW5hcnlDb250ZW50KHVybCwgZnVuY3Rpb24oZXJyOmFueSwgZGF0YTphbnkpIHtcbiAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjsgLy8gb3IgaGFuZGxlIGVyclxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIEpTWmlwLmxvYWRBc3luYyhkYXRhKS50aGVuKGZ1bmN0aW9uKHppcDphbnkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlsZUxpc3Q6SXVwbG9hZGZpbGVMaXN0ID0gPEl1cGxvYWRmaWxlTGlzdD57fSwgbGFzdEluZGV4Om51bWJlciA9IE9iamVjdC5rZXlzKHppcC5maWxlcykubGVuZ3RoLCBpbmRleDpudW1iZXI9MDtcbiAgICAgICAgICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoOmFueSwgemlwRW50cnk6YW55KSB7ICAvLyAyKSBwcmludCBlbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IHppcEVudHJ5Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZUFyciA9IGZpbGVOYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGZpbGVOYW1lQXJyW2ZpbGVOYW1lQXJyLmxlbmd0aC0xXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZVR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBpZihzdWZmaXggaW4ge1wicG5nXCI6MSwgXCJqcGVnXCI6MSwgXCJqcGdcIjoxLCBcImdpZlwiOjEsXCJibXBcIjoxLFwidGlmXCI6MSxcIndlYnBcIjoxLH0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVR5cGUgPSBcImJhc2U2NFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3VmZml4PT1cImVtZlwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHppcEVudHJ5LmFzeW5jKGZpbGVUeXBlKS50aGVuKGZ1bmN0aW9uIChkYXRhOmFueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmlsZVR5cGU9PVwiYmFzZTY0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBcImRhdGE6aW1hZ2UvXCIrIHN1ZmZpeCArXCI7YmFzZTY0LFwiICsgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVMaXN0W3ppcEVudHJ5Lm5hbWVdID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobGFzdEluZGV4PT1pbmRleCsxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzRnVuYyhmaWxlTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlOkVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JGdW5jKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBuZXdaaXBGaWxlKCk6dm9pZCB7IFxuICAgICAgICB2YXIgemlwID0gbmV3IEpTWmlwKCk7XG4gICAgICAgIHRoaXMud29ya0Jvb2sgPSAgemlwO1xuICAgIH1cblxuICAgIC8vdGl0bGU6XCJuZXN0ZWQvaGVsbG8udHh0XCIsIGNvbnRlbnQ6XCJIZWxsbyBXb3JsZGFzZGZhc2Zhc2RmYXNmYXNmYXNmYXNmYXNkZmFzXCJcbiAgICBhZGRUb1ppcEZpbGUodGl0bGU6c3RyaW5nLGNvbnRlbnQ6c3RyaW5nKTp2b2lkIHsgXG4gICAgICAgIGlmKHRoaXMud29ya0Jvb2s9PW51bGwpe1xuICAgICAgICAgICAgdmFyIHppcCA9IG5ldyBKU1ppcCgpO1xuICAgICAgICAgICAgdGhpcy53b3JrQm9vayA9ICB6aXA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53b3JrQm9vay5maWxlKHRpdGxlLCBjb250ZW50KTtcbiAgICB9XG59IiwiaW1wb3J0IHsgSUx1Y2t5RmlsZSwgSUx1Y2t5RmlsZUluZm8sSWx1Y2t5U2hlZXQsSWx1Y2t5U2hlZXRDZWxsZGF0YSxJbHVja3lTaGVldENvbmZpZyxJbHVja3lTaGVldENlbGxkYXRhVmFsdWUsSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlTWVyZ2UsSUx1Y2t5U2hlZXRDZWxsRm9ybWF0LElsdWNreVNoZWV0Q29uZmlnTWVyZ2VzLElsdWNreVNoZWV0Q29uZmlnTWVyZ2UsSU1hcGx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWUsSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGUsSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxJbHVja3lTaGVldFJvd0FuZENvbHVtbkxlbixJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlbixJbHVja3lTaGVldFNlbGVjdGlvbixJbHVja3lzaGVldEZyb3plbixJbHVja3lTaGVldENoYXJ0LElsdWNreVNoZWV0UGl2b3RUYWJsZSxJbHVja3lzaGVldENvbmRpdGlvbkZvcm1hdCxJbHVja3lzaGVldENhbGNDaGFpbixJTHVja3lJbmxpbmVTdHJpbmcsSWx1Y2t5SW1hZ2UsSWx1Y2t5SW1hZ2VCb3JkZXIsSWx1Y2t5SW1hZ2VDcm9wLElsdWNreUltYWdlRGVmYXVsdCxJbHVja3lJbWFnZXN9IGZyb20gXCIuL0lMdWNrXCI7XG5cblxuXG5leHBvcnQgY2xhc3MgTHVja3lGaWxlQmFzZSBpbXBsZW1lbnRzIElMdWNreUZpbGUge1xuICAgIGluZm86SUx1Y2t5RmlsZUluZm9cbiAgICBzaGVldHM6SWx1Y2t5U2hlZXRbXVxufVxuXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldEJhc2UgaW1wbGVtZW50cyBJbHVja3lTaGVldHtcbiAgICBuYW1lOnN0cmluZ1xuICAgIGNvbG9yOnN0cmluZ1xuICAgIGNvbmZpZzpJbHVja3lTaGVldENvbmZpZ1xuICAgIGluZGV4OnN0cmluZ1xuICAgIHN0YXR1czpzdHJpbmdcbiAgICBvcmRlcjpzdHJpbmdcbiAgICByb3c6bnVtYmVyXG4gICAgY29sdW1uOm51bWJlclxuICAgIGx1Y2t5c2hlZXRfc2VsZWN0X3NhdmU6SWx1Y2t5U2hlZXRTZWxlY3Rpb25bXVxuICAgIHNjcm9sbExlZnQ6bnVtYmVyXG4gICAgc2Nyb2xsVG9wOm51bWJlclxuICAgIHpvb21SYXRpbzpudW1iZXJcbiAgICBzaG93R3JpZExpbmVzOnN0cmluZ1xuICAgIGRlZmF1bHRDb2xXaWR0aDpudW1iZXJcbiAgICBkZWZhdWx0Um93SGVpZ2h0Om51bWJlclxuXG4gICAgY2VsbGRhdGE6SWx1Y2t5U2hlZXRDZWxsZGF0YVtdXG4gICAgY2hhcnQ6SWx1Y2t5U2hlZXRDaGFydFtdXG5cbiAgICBpc1Bpdm90VGFibGU6Ym9vbGVhblxuICAgIHBpdm90VGFibGU6SWx1Y2t5U2hlZXRQaXZvdFRhYmxlXG5cbiAgICBsdWNreXNoZWV0X2NvbmRpdGlvbmZvcm1hdF9zYXZlOklsdWNreXNoZWV0Q29uZGl0aW9uRm9ybWF0W11cbiAgICBmcmVlemVuOklsdWNreXNoZWV0RnJvemVuXG5cbiAgICBjYWxjQ2hhaW46SWx1Y2t5c2hlZXRDYWxjQ2hhaW5bXVxuXG4gICAgaW1hZ2VzOklsdWNreUltYWdlc1xufVxuXG5leHBvcnQgY2xhc3MgTHVja3lGaWxlSW5mbyBpbXBsZW1lbnRzIElMdWNreUZpbGVJbmZve1xuICAgIG5hbWU6c3RyaW5nXG4gICAgY3JlYXRvcjpzdHJpbmdcbiAgICBsYXN0bW9kaWZpZWRieTpzdHJpbmdcbiAgICBjcmVhdGVkVGltZTpzdHJpbmdcbiAgICBtb2RpZmllZFRpbWU6c3RyaW5nXG4gICAgY29tcGFueTpzdHJpbmdcbiAgICBhcHB2ZXJzaW9uOnN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldENlbGxkYXRhQmFzZSBpbXBsZW1lbnRzIElsdWNreVNoZWV0Q2VsbGRhdGF7XG4gICAgcjpudW1iZXJcbiAgICBjOm51bWJlclxuICAgIHY6SWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlIHwgc3RyaW5nIHwgbnVsbFxufVxuXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldENlbGxkYXRhVmFsdWUgaW1wbGVtZW50cyBJbHVja3lTaGVldENlbGxkYXRhVmFsdWV7XG4gICAgY3Q6IEx1Y2t5U2hlZXRDZWxsRm9ybWF0IHwgdW5kZWZpbmVkIC8vY2VsbHR5cGUsQ2VsbCB2YWx1ZSBmb3JtYXQ6IHRleHQsIHRpbWUsIGV0Yy4gbnVtZm10c1xuICAgIGJnOiBzdHJpbmcgfCB1bmRlZmluZWQvL2JhY2tncm91bmQsI2ZmZjAwMCxcdGZpbGxcbiAgICBmZjogc3RyaW5nIHwgdW5kZWZpbmVkLy9mb250ZmFtaWx5LCBmb250c1xuICAgIGZjOiBzdHJpbmcgfCB1bmRlZmluZWQvL2ZvbnRjb2xvciBmb250c1xuICAgIGJsOiBudW1iZXIgfCB1bmRlZmluZWQvL0JvbGQsIGZvbnRzXG4gICAgaXQ6IG51bWJlciB8IHVuZGVmaW5lZC8vaXRhbGljLCBmb250c1xuICAgIGZzOiBudW1iZXIgfCB1bmRlZmluZWQvL2ZvbnQgc2l6ZSwgZm9udHNcbiAgICBjbDogbnVtYmVyIHwgdW5kZWZpbmVkLy9zdHJpa2UsIDAgUmVndWxhciwgMSBzdHJpa2VzLCBmb250c1xuICAgIHVuOiBudW1iZXIgfCB1bmRlZmluZWQvL3VuZGVybGluZSwgMCBSZWd1bGFyLCAxIHVuZGVybGluZXMsIGZvbnRzXG4gICAgdnQ6IG51bWJlciB8IHVuZGVmaW5lZC8vVmVydGljYWwgYWxpZ25tZW50LCAwIG1pZGRsZSwgMSB1cCwgMiBkb3duLCBhbGlnbm1lbnRcbiAgICBodDogbnVtYmVyIHwgdW5kZWZpbmVkLy9Ib3Jpem9udGFsIGFsaWdubWVudCwwIGNlbnRlciwgMSBsZWZ0LCAyIHJpZ2h0LCBhbGlnbm1lbnRcbiAgICBtYzogSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlTWVyZ2UgfCB1bmRlZmluZWQgLy9NZXJnZSBDZWxscywgbWVyZ2VDZWxsc1xuICAgIHRyOiBudW1iZXIgfCB1bmRlZmluZWQgLy9UZXh0IHJvdGF0aW9uLDA6IDDjgIEzIFZlcnRpY2FsIHRleHQgYWxpZ25tZW50XG4gICAgdGI6IG51bWJlciB8IHVuZGVmaW5lZCAvL1RleHQgd3JhcCwwIHRydW5jYXRpb24sIDEgb3ZlcmZsb3csIDIgd29yZCB3cmFwLCBhbGlnbm1lbnRcbiAgICB2OiBzdHJpbmcgfCB1bmRlZmluZWQgLy9PcmlnaW5hbCB2YWx1ZSwgdlxuICAgIG06IHN0cmluZyB8IHVuZGVmaW5lZCAvL0Rpc3BsYXkgdmFsdWUsIHZcbiAgICBmOiBzdHJpbmcgfCB1bmRlZmluZWQgLy9mb3JtdWxhLCBmXG4gICAgcnQ6bnVtYmVyIHwgdW5kZWZpbmVkIC8vdGV4dCByb3RhdGlvbiBhbmdsZSAwLTE4MCBhbGlnbm1lbnRcbiAgICBxcDpudW1iZXIgfCB1bmRlZmluZWQgLy9xdW90ZVByZWZpeCwgc2hvdyBudW1iZXIgYXMgc3RyaW5nXG59XG5cblxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRDZWxsRm9ybWF0IGltcGxlbWVudHMgSUx1Y2t5U2hlZXRDZWxsRm9ybWF0IHtcbiAgICBmYTpzdHJpbmdcbiAgICB0OnN0cmluZ1xuICAgIHM6THVja3lJbmxpbmVTdHJpbmdbXSB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgY2xhc3MgTHVja3lJbmxpbmVTdHJpbmcgaW1wbGVtZW50cyBJTHVja3lJbmxpbmVTdHJpbmcge1xuICAgIGZmOnN0cmluZyB8IHVuZGVmaW5lZCAvL2ZvbnQgZmFtaWx5XG4gICAgZmM6c3RyaW5nIHwgdW5kZWZpbmVkLy9mb250IGNvbG9yXG4gICAgZnM6bnVtYmVyIHwgdW5kZWZpbmVkLy9mb250IHNpemVcbiAgICBjbDpudW1iZXIgfCB1bmRlZmluZWQvL3N0cmlrZVxuICAgIHVuOm51bWJlciB8IHVuZGVmaW5lZC8vdW5kZXJsaW5lXG4gICAgYmw6bnVtYmVyIHwgdW5kZWZpbmVkLy9ibG9kXG4gICAgaXQ6bnVtYmVyIHwgdW5kZWZpbmVkLy9pdGFsaWNcbiAgICB2YTpudW1iZXIgfCB1bmRlZmluZWQvLzFzdWIgYW5kIDJzdXBlciBhbmQgMG5vbmVcbiAgICB2OnN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgY2xhc3MgTHVja3lDb25maWcgaW1wbGVtZW50cyBJbHVja3lTaGVldENvbmZpZ3tcbiAgICBtZXJnZTpJbHVja3lTaGVldENvbmZpZ01lcmdlc1xuICAgIGJvcmRlckluZm86SWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcFtdXG4gICAgLy8gX2JvcmRlckluZm86IElNYXBsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXBcbiAgICByb3dsZW46SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5MZW5cbiAgICBjb2x1bW5sZW46SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5MZW5cbiAgICByb3doaWRkZW46SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5IaWRkZW5cbiAgICBjb2xoaWRkZW46SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5IaWRkZW5cblxuICAgIGN1c3RvbUhlaWdodDpJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlblxuICAgIGN1c3RvbVdpZHRoOklsdWNreVNoZWV0Um93QW5kQ29sdW1uSGlkZGVuXG59XG5cbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXAgaW1wbGVtZW50cyBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1we1xuICAgIHJhbmdlVHlwZTpzdHJpbmdcbiAgICAvLyBjZWxsczpzdHJpbmdbXVxuICAgIHZhbHVlOklsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVxufVxuXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWUgaW1wbGVtZW50cyBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWV7XG4gICAgcm93X2luZGV4OiBudW1iZXJcbiAgICBjb2xfaW5kZXg6IG51bWJlclxuICAgIGw6IElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlXG4gICAgcjogSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGVcbiAgICB0OiBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZVxuICAgIGI6IElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlXG59XG5cbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGV7XG4gICAgXCJzdHlsZVwiOiBudW1iZXJcbiAgICBcImNvbG9yXCI6IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldENvbmZpZ01lcmdlIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRDb25maWdNZXJnZXtcbiAgICByOiBudW1iZXJcbiAgICBjOiBudW1iZXJcbiAgICByczogbnVtYmVyXG4gICAgY3M6IG51bWJlclxufVxuXG5leHBvcnQgY2xhc3MgTHVja3lzaGVldENhbGNDaGFpbiBpbXBsZW1lbnRzIElsdWNreXNoZWV0Q2FsY0NoYWlue1xuICAgIHI6bnVtYmVyXG4gICAgYzpudW1iZXJcbiAgICBpbmRleDpzdHJpbmcgfCB1bmRlZmluZWRcbn1cblxuXG5leHBvcnQgY2xhc3MgTHVja3lJbWFnZUJhc2UgaW1wbGVtZW50cyBJbHVja3lJbWFnZXtcbiAgICBib3JkZXI6IElsdWNreUltYWdlQm9yZGVyXG4gICAgY3JvcDogSWx1Y2t5SW1hZ2VDcm9wXG4gICAgZGVmYXVsdDogSWx1Y2t5SW1hZ2VEZWZhdWx0XG5cbiAgICBmaXhlZExlZnQ6IG51bWJlclxuICAgIGZpeGVkVG9wOiBudW1iZXJcbiAgICBpc0ZpeGVkUG9zOiBCb29sZWFuXG4gICAgb3JpZ2luSGVpZ2h0OiBudW1iZXJcbiAgICBvcmlnaW5XaWR0aDogbnVtYmVyXG4gICAgc3JjOiBzdHJpbmdcbiAgICB0eXBlOiBzdHJpbmdcbn0iLCJpbXBvcnQgeyBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wLElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSxJbHVja3lTaGVldENlbGxkYXRhVmFsdWVNZXJnZSxJTHVja3lTaGVldENlbGxGb3JtYXQgfSBmcm9tIFwiLi9JTHVja1wiO1xuaW1wb3J0IHsgUmVhZFhtbCwgRWxlbWVudCwgSVN0eWxlQ29sbGVjdGlvbnMsZ2V0Q29sb3IsZ2V0bGluZVN0cmluZ0F0dHIgfSBmcm9tIFwiLi9SZWFkWG1sXCI7XG5pbXBvcnQge2dldFhtbEF0dGlidXRlLCBnZXRDb2x1bW5XaWR0aFBpeGVsLCBnZXRSb3dIZWlnaHRQaXhlbCxnZXRjZWxscmFuZ2UsIGVzY2FwZUNoYXJhY3RlciwgaXNDaGluZXNlLCBpc0phcGFuZXNlLCBpc0tvZXJhLGlzQ29udGFpbk11bHRpVHlwZX0gZnJvbSBcIi4uL2NvbW1vbi9tZXRob2RcIjtcbmltcG9ydCB7IFNUX0NlbGxUeXBlLCBpbmRleGVkQ29sb3JzLCBPRU1fQ0hBUlNFVCxib3JkZXJUeXBlcyxmb250RmFtaWx5cyB9IGZyb20gXCIuLi9jb21tb24vY29uc3RhbnRcIlxuaW1wb3J0IHsgSWF0dHJpYnV0ZUxpc3QsIHN0cmluZ1RvTnVtIH0gZnJvbSBcIi4uL0lDb21tb25cIjtcbmltcG9ydCB7IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGUsTHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wLEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlLEx1Y2t5U2hlZXRDZWxsZGF0YUJhc2UsTHVja3lTaGVldENlbGxkYXRhVmFsdWUsTHVja3lTaGVldENlbGxGb3JtYXQsTHVja3lJbmxpbmVTdHJpbmcgfSBmcm9tIFwiLi9MdWNreUJhc2VcIjtcblxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRDZWxsZGF0YSBleHRlbmRzIEx1Y2t5U2hlZXRDZWxsZGF0YUJhc2V7XG4gICAgX2JvcmRlck9iamVjdDpJbHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wXG4gICAgX2ZvbXVsYVJlZjpzdHJpbmdcbiAgICBfZm9ybXVsYVNpOnN0cmluZ1xuICAgIF9mb3JtdWxhVHlwZTpzdHJpbmdcblxuICAgIHByaXZhdGUgc2hlZXRGaWxlOnN0cmluZ1xuICAgIHByaXZhdGUgcmVhZFhtbDpSZWFkWG1sXG4gICAgcHJpdmF0ZSBjZWxsOkVsZW1lbnRcbiAgICBwcml2YXRlIHN0eWxlczpJU3R5bGVDb2xsZWN0aW9uc1xuICAgIHByaXZhdGUgc2hhcmVkU3RyaW5nczpFbGVtZW50W11cbiAgICBwcml2YXRlIG1lcmdlQ2VsbHM6RWxlbWVudFtdXG5cbiAgICBjb25zdHJ1Y3RvcihjZWxsOkVsZW1lbnQsIHN0eWxlczpJU3R5bGVDb2xsZWN0aW9ucywgc2hhcmVkU3RyaW5nczpFbGVtZW50W10sIG1lcmdlQ2VsbHM6RWxlbWVudFtdLCBzaGVldEZpbGU6c3RyaW5nLCBSZWFkWG1sOlJlYWRYbWwpe1xuICAgICAgICAvL1ByaXZhdGVcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICAgICAgdGhpcy5zaGVldEZpbGUgPSBzaGVldEZpbGU7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB0aGlzLnNoYXJlZFN0cmluZ3MgPSBzaGFyZWRTdHJpbmdzO1xuICAgICAgICB0aGlzLnJlYWRYbWwgPSBSZWFkWG1sO1xuICAgICAgICB0aGlzLm1lcmdlQ2VsbHMgPSBtZXJnZUNlbGxzO1xuXG4gICAgICAgIGxldCBhdHRyTGlzdCA9IGNlbGwuYXR0cmlidXRlTGlzdDtcbiAgICAgICAgbGV0IHIgPSBhdHRyTGlzdC5yLCBzID0gYXR0ckxpc3QucywgdCA9IGF0dHJMaXN0LnQ7XG4gICAgICAgIGxldCByYW5nZSA9IGdldGNlbGxyYW5nZShyKTtcblxuICAgICAgICB0aGlzLnIgPSByYW5nZS5yb3dbMF07XG4gICAgICAgIHRoaXMuYyA9IHJhbmdlLmNvbHVtblswXTtcbiAgICAgICAgdGhpcy52ID0gdGhpcy5nZW5lcmF0ZVZhbHVlKHMsIHQpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0gcyBTdHlsZSBpbmRleCAsc3RhcnQgMVxuICAgICogQHBhcmFtIHQgQ2VsbCB0eXBlLCBPcHRpb25hbCB2YWx1ZSBpcyBTVF9DZWxsVHlwZSwgaXQncyBmb3VuZCBhdCBjb25zdGF0LnRzXG4gICAgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlVmFsdWUoczpzdHJpbmcsIHQ6c3RyaW5nKXtcbiAgICAgICAgbGV0IHYgPSB0aGlzLmNlbGwuZ2V0SW5uZXJFbGVtZW50cyhcInZcIik7XG4gICAgICAgIGxldCBmID0gdGhpcy5jZWxsLmdldElubmVyRWxlbWVudHMoXCJmXCIpO1xuXG4gICAgICAgIGlmKHY9PW51bGwpe1xuICAgICAgICAgICAgdiA9IHRoaXMuY2VsbC5nZXRJbm5lckVsZW1lbnRzKFwidFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjZWxsWGZzID0gdGhpcy5zdHlsZXNbXCJjZWxsWGZzXCJdIGFzIEVsZW1lbnRbXTtcbiAgICAgICAgbGV0IGNlbGxTdHlsZVhmcyA9IHRoaXMuc3R5bGVzW1wiY2VsbFN0eWxlWGZzXCJdIGFzIEVsZW1lbnRbXTtcbiAgICAgICAgbGV0IGNlbGxTdHlsZXMgPSB0aGlzLnN0eWxlc1tcImNlbGxTdHlsZXNcIl0gYXMgRWxlbWVudFtdO1xuICAgICAgICBsZXQgZm9udHMgPSB0aGlzLnN0eWxlc1tcImZvbnRzXCJdIGFzIEVsZW1lbnRbXTtcbiAgICAgICAgbGV0IGZpbGxzID0gdGhpcy5zdHlsZXNbXCJmaWxsc1wiXSBhcyBFbGVtZW50W107XG4gICAgICAgIGxldCBib3JkZXJzID0gdGhpcy5zdHlsZXNbXCJib3JkZXJzXCJdIGFzIEVsZW1lbnRbXTtcbiAgICAgICAgbGV0IG51bWZtdHMgPSB0aGlzLnN0eWxlc1tcIm51bWZtdHNcIl0gYXMgSWF0dHJpYnV0ZUxpc3Q7XG4gICAgICAgIGxldCBjbHJTY2hlbWUgPSB0aGlzLnN0eWxlc1tcImNsclNjaGVtZVwiXSBhcyBFbGVtZW50W107XG5cbiAgICAgICAgbGV0IHNoYXJlZFN0cmluZ3MgPSB0aGlzLnNoYXJlZFN0cmluZ3M7XG4gICAgICAgIGxldCBjZWxsVmFsdWUgPSBuZXcgTHVja3lTaGVldENlbGxkYXRhVmFsdWUoKTtcblxuICAgICAgICBpZihmIT1udWxsKXtcbiAgICAgICAgICAgIGxldCBmb3JtdWxhID0gZlswXSwgYXR0ckxpc3QgPSBmb3JtdWxhLmF0dHJpYnV0ZUxpc3Q7XG4gICAgICAgICAgICBsZXQgdCA9IGF0dHJMaXN0LnQsIHJlZiA9IGF0dHJMaXN0LnJlZiwgc2kgPSBhdHRyTGlzdC5zaTtcbiAgICAgICAgICAgIGxldCBmb3JtdWxhVmFsdWUgPWZbMF0udmFsdWU7XG4gICAgICAgICAgICBpZih0PT1cInNoYXJlZFwiKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb211bGFSZWYgPSByZWY7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9ybXVsYVR5cGUgPSB0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm11bGFTaSA9IHNpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocmVmLCB0LCBzaSk7XG4gICAgICAgICAgICBpZihyZWYhPW51bGwgfHwgKGZvcm11bGFWYWx1ZSE9bnVsbCAmJiBmb3JtdWxhVmFsdWUubGVuZ3RoPjApKXtcbiAgICAgICAgICAgICAgICBmb3JtdWxhVmFsdWUgPSBlc2NhcGVDaGFyYWN0ZXIoZm9ybXVsYVZhbHVlKTtcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUuZiA9IFwiPVwiICsgZm9ybXVsYVZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmFtaWx5Rm9udCA9IG51bGw7XG4gICAgICAgIGxldCBxdW90ZVByZWZpeDtcbiAgICAgICAgaWYocyE9bnVsbCl7XG4gICAgICAgICAgICBsZXQgc051bSA9IHBhcnNlSW50KHMpO1xuICAgICAgICAgICAgbGV0IGNlbGxYZiA9IGNlbGxYZnNbc051bV07XG4gICAgICAgICAgICBsZXQgeGZJZCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LnhmSWQ7XG5cbiAgICAgICAgICAgIGxldCBudW1GbXRJZCxmb250SWQsZmlsbElkLGJvcmRlcklkO1xuICAgICAgICAgICAgbGV0IGhvcml6b250YWwsdmVydGljYWwsIHdyYXBUZXh0LCB0ZXh0Um90YXRpb24sIHNocmlua1RvRml0LCBpbmRlbnQsYXBwbHlQcm90ZWN0aW9uO1xuXG4gICAgICAgICAgICBpZih4ZklkIT1udWxsKXtcbiAgICAgICAgICAgICAgICBsZXQgY2VsbFN0eWxlWGYgPSBjZWxsU3R5bGVYZnNbcGFyc2VJbnQoeGZJZCldO1xuICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IGNlbGxTdHlsZVhmLmF0dHJpYnV0ZUxpc3Q7XG5cbiAgICAgICAgICAgICAgICBsZXQgYXBwbHlOdW1iZXJGb3JtYXQgPSBhdHRyTGlzdC5hcHBseU51bWJlckZvcm1hdDtcbiAgICAgICAgICAgICAgICBsZXQgYXBwbHlGb250ID0gYXR0ckxpc3QuYXBwbHlGb250O1xuICAgICAgICAgICAgICAgIGxldCBhcHBseUZpbGwgPSBhdHRyTGlzdC5hcHBseUZpbGw7XG4gICAgICAgICAgICAgICAgbGV0IGFwcGx5Qm9yZGVyID0gYXR0ckxpc3QuYXBwbHlCb3JkZXI7XG4gICAgICAgICAgICAgICAgbGV0IGFwcGx5QWxpZ25tZW50ID0gYXR0ckxpc3QuYXBwbHlBbGlnbm1lbnQ7XG4gICAgICAgICAgICAgICAgLy8gbGV0IGFwcGx5UHJvdGVjdGlvbiA9IGF0dHJMaXN0LmFwcGx5UHJvdGVjdGlvbjtcblxuICAgICAgICAgICAgICAgIGFwcGx5UHJvdGVjdGlvbiA9IGF0dHJMaXN0LmFwcGx5UHJvdGVjdGlvbjtcbiAgICAgICAgICAgICAgICBxdW90ZVByZWZpeCA9IGF0dHJMaXN0LnF1b3RlUHJlZml4O1xuXG4gICAgICAgICAgICAgICAgaWYoYXBwbHlOdW1iZXJGb3JtYXQhPVwiMFwiICYmIGF0dHJMaXN0Lm51bUZtdElkIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYoYXR0ckxpc3QubnVtRm10SWQhPVwiMFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bUZtdElkID0gYXR0ckxpc3QubnVtRm10SWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoYXBwbHlGb250IT1cIjBcIiAmJiBhdHRyTGlzdC5mb250SWQhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBmb250SWQgPSBhdHRyTGlzdC5mb250SWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGFwcGx5RmlsbCE9XCIwXCIgJiYgYXR0ckxpc3QuZmlsbElkIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgZmlsbElkID0gYXR0ckxpc3QuZmlsbElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihhcHBseUJvcmRlciE9XCIwXCIgJiYgYXR0ckxpc3QuYm9yZGVySWQhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJJZCA9IGF0dHJMaXN0LmJvcmRlcklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihhcHBseUFsaWdubWVudCE9bnVsbCAmJiBhcHBseUFsaWdubWVudCE9XCIwXCIpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gY2VsbFN0eWxlWGYuZ2V0SW5uZXJFbGVtZW50cyhcImFsaWdubWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoYWxpZ25tZW50IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IGFsaWdubWVudFswXS5hdHRyaWJ1dGVMaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QuaG9yaXpvbnRhbCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbCA9IGF0dHJMaXN0Lmhvcml6b250YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC52ZXJ0aWNhbCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWwgPSBhdHRyTGlzdC52ZXJ0aWNhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LndyYXBUZXh0IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwVGV4dCA9IGF0dHJMaXN0LndyYXBUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QudGV4dFJvdGF0aW9uIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Um90YXRpb24gPSBhdHRyTGlzdC50ZXh0Um90YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC5zaHJpbmtUb0ZpdCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rVG9GaXQgPSBhdHRyTGlzdC5zaHJpbmtUb0ZpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LmluZGVudCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gYXR0ckxpc3QuaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgYXBwbHlOdW1iZXJGb3JtYXQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5hcHBseU51bWJlckZvcm1hdDtcbiAgICAgICAgICAgIGxldCBhcHBseUZvbnQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5hcHBseUZvbnQ7XG4gICAgICAgICAgICBsZXQgYXBwbHlGaWxsID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlGaWxsO1xuICAgICAgICAgICAgbGV0IGFwcGx5Qm9yZGVyID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlCb3JkZXI7XG4gICAgICAgICAgICBsZXQgYXBwbHlBbGlnbm1lbnQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5hcHBseUFsaWdubWVudDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlQcm90ZWN0aW9uIT1udWxsKXtcbiAgICAgICAgICAgICAgICBhcHBseVByb3RlY3Rpb24gPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5hcHBseVByb3RlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGNlbGxYZi5hdHRyaWJ1dGVMaXN0LnF1b3RlUHJlZml4IT1udWxsKXtcbiAgICAgICAgICAgICAgICBxdW90ZVByZWZpeCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LnF1b3RlUHJlZml4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihhcHBseU51bWJlckZvcm1hdCE9XCIwXCIgJiYgY2VsbFhmLmF0dHJpYnV0ZUxpc3QubnVtRm10SWQhPW51bGwpe1xuICAgICAgICAgICAgICAgIG51bUZtdElkID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QubnVtRm10SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihhcHBseUZvbnQhPVwiMFwiKXtcbiAgICAgICAgICAgICAgICBmb250SWQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5mb250SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihhcHBseUZpbGwhPVwiMFwiKXtcbiAgICAgICAgICAgICAgICBmaWxsSWQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5maWxsSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihhcHBseUJvcmRlciE9XCIwXCIpe1xuICAgICAgICAgICAgICAgIGJvcmRlcklkID1jZWxsWGYuYXR0cmlidXRlTGlzdC5ib3JkZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGFwcGx5QWxpZ25tZW50IT1cIjBcIil7XG4gICAgICAgICAgICAgICAgbGV0IGFsaWdubWVudCA9IGNlbGxYZi5nZXRJbm5lckVsZW1lbnRzKFwiYWxpZ25tZW50XCIpO1xuICAgICAgICAgICAgICAgIGlmKGFsaWdubWVudCE9bnVsbCAmJiBhbGlnbm1lbnQubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBhbGlnbm1lbnRbMF0uYXR0cmlidXRlTGlzdDtcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QuaG9yaXpvbnRhbCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsID0gYXR0ckxpc3QuaG9yaXpvbnRhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC52ZXJ0aWNhbCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbCA9IGF0dHJMaXN0LnZlcnRpY2FsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LndyYXBUZXh0IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBUZXh0ID0gYXR0ckxpc3Qud3JhcFRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QudGV4dFJvdGF0aW9uIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRSb3RhdGlvbiA9IGF0dHJMaXN0LnRleHRSb3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC5zaHJpbmtUb0ZpdCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaHJpbmtUb0ZpdCA9IGF0dHJMaXN0LnNocmlua1RvRml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LmluZGVudCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBhdHRyTGlzdC5pbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZihudW1GbXRJZCE9dW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICBsZXQgbnVtZiA9IG51bWZtdHNbcGFyc2VJbnQobnVtRm10SWQpXTtcbiAgICAgICAgICAgICAgICBsZXQgY2VsbEZvcm1hdCA9IG5ldyBMdWNreVNoZWV0Q2VsbEZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQuZmEgPSBlc2NhcGVDaGFyYWN0ZXIobnVtZik7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobnVtZiwgbnVtRm10SWQsIHRoaXMudik7XG4gICAgICAgICAgICAgICAgY2VsbEZvcm1hdC50ID0gdDtcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUuY3QgPSBjZWxsRm9ybWF0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihmaWxsSWQhPXVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGxJZE51bSA9IHBhcnNlSW50KGZpbGxJZCk7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGwgID0gZmlsbHNbZmlsbElkTnVtXTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjZWxsVmFsdWUudik7XG4gICAgICAgICAgICAgICAgbGV0IGJnID0gdGhpcy5nZXRCYWNrZ3JvdW5kQnlGaWxsKGZpbGwsIGNsclNjaGVtZSk7XG4gICAgICAgICAgICAgICAgaWYoYmchPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuYmcgPSBiZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZm9udElkIT11bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIGxldCBmb250SWROdW0gPSBwYXJzZUludChmb250SWQpO1xuICAgICAgICAgICAgICAgIGxldCBmb250ID0gZm9udHNbZm9udElkTnVtXTtcbiAgICAgICAgICAgICAgICBpZihmb250IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN6ID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwic3pcIik7Ly9mb250IHNpemVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9ycyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcImNvbG9yXCIpOy8vZm9udCBjb2xvclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFtaWx5ID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwibmFtZVwiKTsvL2ZvbnQgZmFtaWx5XG4gICAgICAgICAgICAgICAgICAgIGxldCBmYW1pbHlPdmVycmlkZXMgPSBmb250LmdldElubmVyRWxlbWVudHMoXCJmYW1pbHlcIik7Ly9mb250IGZhbWlseSB3aWxsIGJlIG92ZXJyaWRlZCBieSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGFyc2V0ID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwiY2hhcnNldFwiKTsvL2ZvbnQgY2hhcnNldFxuICAgICAgICAgICAgICAgICAgICBsZXQgYm9sZHMgPSBmb250LmdldElubmVyRWxlbWVudHMoXCJiXCIpOy8vZm9udCBib2xkXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGFsaWNzID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwiaVwiKTsvL2ZvbnQgaXRhbGljXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHJpa2VzID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwic3RyaWtlXCIpOy8vZm9udCBpdGFsaWNcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuZGVybGluZXMgPSBmb250LmdldElubmVyRWxlbWVudHMoXCJ1XCIpOy8vZm9udCBpdGFsaWNcblxuICAgICAgICAgICAgICAgICAgICBpZihzeiE9bnVsbCAmJiBzei5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnMgPSBzelswXS5hdHRyaWJ1dGVMaXN0LnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZzIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuZnMgPSBwYXJzZUludChmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoY29sb3JzIT1udWxsICYmIGNvbG9ycy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBjb2xvcnNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmMgPSBnZXRDb2xvcihjb2xvciwgdGhpcy5zdHlsZXMsIFwidFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZjIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuZmMgPSBmYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihmYW1pbHlPdmVycmlkZXMhPW51bGwgJiYgZmFtaWx5T3ZlcnJpZGVzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBmYW1pbHlPdmVycmlkZXNbMF0uYXR0cmlidXRlTGlzdC52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWwhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbWlseUZvbnQgPSBmb250RmFtaWx5c1t2YWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZmFtaWx5IT1udWxsICYmIGZhbWlseS5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gZmFtaWx5WzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFsIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuZmYgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICBpZihib2xkcyE9bnVsbCAmJiBib2xkcy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm9sZCA9IGJvbGRzWzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYm9sZD09XCIwXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5ibCA9ICAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuYmwgPSAgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKGl0YWxpY3MhPW51bGwgJiYgaXRhbGljcy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRhbGljID0gaXRhbGljc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0YWxpYz09XCIwXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5pdCA9ICAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaXQgPSAgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHN0cmlrZXMhPW51bGwgJiYgc3RyaWtlcy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RyaWtlID0gc3RyaWtlc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0cmlrZT09XCIwXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jbCA9ICAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuY2wgPSAgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHVuZGVybGluZXMhPW51bGzCoCYmwqB1bmRlcmxpbmVzLmxlbmd0aD4wKXtcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGxldMKgdW5kZXJsaW5lwqA9wqB1bmRlcmxpbmVzWzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgaWYodW5kZXJsaW5lPT1cInNpbmdsZVwiKXtcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY2VsbFZhbHVlLnVuwqA9wqDCoDE7XG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBlbHNlwqBpZih1bmRlcmxpbmU9PVwiZG91YmxlXCIpe1xuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjZWxsVmFsdWUudW7CoD3CoMKgMjtcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGVsc2XCoGlmKHVuZGVybGluZT09XCJzaW5nbGVBY2NvdW50aW5nXCIpe1xuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjZWxsVmFsdWUudW7CoD3CoMKgMztcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGVsc2XCoGlmKHVuZGVybGluZT09XCJkb3VibGVBY2NvdW50aW5nXCIpe1xuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjZWxsVmFsdWUudW7CoD3CoMKgNDtcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGVsc2V7XG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNlbGxWYWx1ZS51bsKgPcKgwqAwO1xuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfVxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZ0OiBudW1iZXIgfCB1bmRlZmluZWQvL1ZlcnRpY2FsIGFsaWdubWVudCwgMCBtaWRkbGUsIDEgdXAsIDIgZG93biwgYWxpZ25tZW50XG4gICAgICAgICAgICAvLyBodDogbnVtYmVyIHwgdW5kZWZpbmVkLy9Ib3Jpem9udGFsIGFsaWdubWVudCwwIGNlbnRlciwgMSBsZWZ0LCAyIHJpZ2h0LCBhbGlnbm1lbnRcbiAgICAgICAgICAgIC8vIHRyOiBudW1iZXIgfCB1bmRlZmluZWQgLy9UZXh0IHJvdGF0aW9uLDA6IDDjgIExOiA0NSDjgIEyOiAtNDXjgIEzIFZlcnRpY2FsIHRleHTjgIE0OiA5MCDjgIE1OiAtOTAsIGFsaWdubWVudFxuICAgICAgICAgICAgLy8gdGI6IG51bWJlciB8IHVuZGVmaW5lZCAvL1RleHQgd3JhcCwwIHRydW5jYXRpb24sIDEgb3ZlcmZsb3csIDIgd29yZCB3cmFwLCBhbGlnbm1lbnRcblxuICAgICAgICAgICAgaWYoaG9yaXpvbnRhbCE9dW5kZWZpbmVkKXsvL0hvcml6b250YWwgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgaWYoaG9yaXpvbnRhbD09XCJjZW50ZXJcIil7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaG9yaXpvbnRhbD09XCJjZW50ZXJDb250aW51b3VzXCIpe1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAwOy8vbHVja3lzaGVldCB1bnN1cHBvcnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImxlZnRcIil7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaG9yaXpvbnRhbD09XCJyaWdodFwiKXtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImRpc3RyaWJ1dGVkXCIpe1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAwOy8vbHVja3lzaGVldCB1bnN1cHBvcnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImZpbGxcIil7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDE7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGhvcml6b250YWw9PVwiZ2VuZXJhbFwiKXtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMTsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaG9yaXpvbnRhbD09XCJqdXN0aWZ5XCIpe1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAwOy8vbHVja3lzaGVldCB1bnN1cHBvcnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHZlcnRpY2FsIT11bmRlZmluZWQpey8vVmVydGljYWwgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgaWYodmVydGljYWw9PVwiYm90dG9tXCIpe1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudnQgPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHZlcnRpY2FsPT1cImNlbnRlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZih2ZXJ0aWNhbD09XCJkaXN0cmlidXRlZFwiKXtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMDsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYodmVydGljYWw9PVwianVzdGlmeVwiKXtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMDsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYodmVydGljYWw9PVwidG9wXCIpe1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudnQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudnQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYod3JhcFRleHQhPXVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgaWYod3JhcFRleHQ9PVwiMVwiKXtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS50YiA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRleHRSb3RhdGlvbiE9dW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAvLyB0cjogbnVtYmVyIHwgdW5kZWZpbmVkIC8vVGV4dCByb3RhdGlvbiwwOiAw44CBMTogNDUg44CBMjogLTQ144CBMyBWZXJ0aWNhbCB0ZXh044CBNDogOTAg44CBNTogLTkwLCBhbGlnbm1lbnRcbiAgICAgICAgICAgICAgICBpZih0ZXh0Um90YXRpb249PVwiMjU1XCIpe1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudHIgPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbHNlIGlmKHRleHRSb3RhdGlvbj09XCI0NVwiKXtcbiAgICAgICAgICAgICAgICAvLyAgICAgY2VsbFZhbHVlLnRyID0gMTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZih0ZXh0Um90YXRpb249PVwiOTBcIil7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNlbGxWYWx1ZS50ciA9IDQ7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYodGV4dFJvdGF0aW9uPT1cIjEzNVwiKXtcbiAgICAgICAgICAgICAgICAvLyAgICAgY2VsbFZhbHVlLnRyID0gMjtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZih0ZXh0Um90YXRpb249PVwiMTgwXCIpe1xuICAgICAgICAgICAgICAgIC8vICAgICBjZWxsVmFsdWUudHIgPSA1O1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudHIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUucnQgPSAgcGFyc2VJbnQodGV4dFJvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2hyaW5rVG9GaXQhPXVuZGVmaW5lZCl7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpbmRlbnQhPXVuZGVmaW5lZCl7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihib3JkZXJJZCE9dW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICBsZXQgYm9yZGVySWROdW0gPSBwYXJzZUludChib3JkZXJJZCk7XG4gICAgICAgICAgICAgICAgbGV0IGJvcmRlciA9IGJvcmRlcnNbYm9yZGVySWROdW1dO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2JvcmRlcklkID0gYm9yZGVySWROdW07XG5cbiAgICAgICAgICAgICAgICBsZXQgYm9yZGVyT2JqZWN0ID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCgpO1xuICAgICAgICAgICAgICAgIGJvcmRlck9iamVjdC5yYW5nZVR5cGUgPSBcImNlbGxcIjtcbiAgICAgICAgICAgICAgICAvLyBib3JkZXJPYmplY3QuY2VsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgYm9yZGVyQ2VsbFZhbHVlID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlKCk7XG5cbiAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUucm93X2luZGV4ID0gdGhpcy5yO1xuICAgICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS5jb2xfaW5kZXggPSB0aGlzLmM7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGV0IGxlZnRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJsZWZ0XCIpO1xuICAgICAgICAgICAgICAgIGxldCByaWdodHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcInJpZ2h0XCIpO1xuICAgICAgICAgICAgICAgIGxldCB0b3BzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJ0b3BcIik7XG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbXMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImJvdHRvbVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZGlhZ29uYWxzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJkaWFnb25hbFwiKTtcblxuICAgICAgICAgICAgICAgIGxldCBzdGFydHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcInN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgIGxldCBlbmRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJlbmRcIik7XG5cbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhsZWZ0cyk7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5nZXRCb3JkZXJJbmZvKHJpZ2h0cyk7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyh0b3BzKTtcbiAgICAgICAgICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5nZXRCb3JkZXJJbmZvKGJvdHRvbXMpO1xuICAgICAgICAgICAgICAgIGxldCBkaWFnb25hbCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhkaWFnb25hbHMpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5nZXRCb3JkZXJJbmZvKHN0YXJ0cyk7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhlbmRzKTtcblxuICAgICAgICAgICAgICAgIGxldCBpc0FkZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYoc3RhcnQhPW51bGwgJiYgc3RhcnQuY29sb3IhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUubCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoZW5kIT1udWxsICYmIGVuZC5jb2xvciE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS5yID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYobGVmdCE9bnVsbCAmJiBsZWZ0LmNvbG9yIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLmwgPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYocmlnaHQhPW51bGwgJiYgcmlnaHQuY29sb3IhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUuciA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYodG9wIT1udWxsICYmIHRvcC5jb2xvciE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS50ID0gdG9wO1xuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoYm90dG9tIT1udWxsICYmIGJvdHRvbS5jb2xvciE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS5iID0gYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoaXNBZGQpe1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJPYmplY3QudmFsdWUgPSBib3JkZXJDZWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvW2JvcmRlcklkXSA9IGJvcmRlck9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9yZGVyT2JqZWN0ID0gYm9yZGVyT2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBjZWxsVmFsdWUudGIgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodiE9bnVsbCl7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPXZbMF0udmFsdWU7XG5cbiAgICAgICAgICAgIGlmKC8mI1xcZCs7Ly50ZXN0KHZhbHVlKSl7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmh0bWxEZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0PT1TVF9DZWxsVHlwZVtcIlNoYXJlZFN0cmluZ1wiXSl7XG4gICAgICAgICAgICAgICAgbGV0IHNpSW5kZXggPSBwYXJzZUludCh2WzBdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmVkU0kgPSBzaGFyZWRTdHJpbmdzW3NpSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgbGV0IHJGbGFnID0gc2hhcmVkU0kuZ2V0SW5uZXJFbGVtZW50cyhcInJcIik7XG4gICAgICAgICAgICAgICAgaWYockZsYWc9PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgdEZsYWcgPSBzaGFyZWRTSS5nZXRJbm5lckVsZW1lbnRzKFwidFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodEZsYWchPW51bGwpeyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRGbGFnLmZvckVhY2goKHQpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGVDaGFyYWN0ZXIodGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaXNDb250YWluTXVsdGlUeXBlKHRleHQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmYW1pbHlGb250PT1cIlJvbWFuXCIgJiYgdGV4dC5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHRBcnJheSA9IHRleHQuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZVdvcmRUeXBlOnN0cmluZyA9IG51bGwsIHdvcmRUZXh0PVwiXCIsIHByZVdob2xlZjpzdHJpbmc9bnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2hvbGVmID0gXCJUaW1lcyBOZXcgUm9tYW5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmYhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aG9sZWYgPSBjZWxsVmFsdWUuZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGxGb3JtYXQgPSBjZWxsVmFsdWUuY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbEZvcm1hdD09bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQgPSBuZXcgTHVja3lTaGVldENlbGxGb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsRm9ybWF0LnM9PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0ZXh0QXJyYXkubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3ID0gdGV4dEFycmF5W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZTpzdHJpbmcgPSBudWxsLCBmZj13aG9sZWY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNDaGluZXNlKHcpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmPVwi5a6L5L2TXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihpc0phcGFuZXNlKHcpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImpcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmPVwiWXUgR290aGljXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihpc0tvZXJhKHcpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmPVwiTWFsZ3VuIEdvdGhpY1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigodHlwZSE9cHJlV29yZFR5cGUgJiYgcHJlV29yZFR5cGUhPW51bGwpIHx8IGk9PXRleHRBcnJheS5sZW5ndGgtMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgSW5saW5lU3RyaW5nID0gbmV3IEx1Y2t5SW5saW5lU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mZiA9IHByZVdob2xlZjtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmMhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mYyA9IGNlbGxWYWx1ZS5mYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZzIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZnMgPSBjZWxsVmFsdWUuZnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmNsIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBjZWxsVmFsdWUuY2w7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLnVuIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBjZWxsVmFsdWUudW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmJsIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuYmwgPSBjZWxsVmFsdWUuYmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLml0IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuaXQgPSBjZWxsVmFsdWUuaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGk9PXRleHRBcnJheS5sZW5ndGgtMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZT09cHJlV29yZFR5cGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmYgPSBmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB3b3JkVGV4dCArIHc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mZiA9IHByZVdob2xlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB3b3JkVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEZvcm1hdC5zLnB1c2goSW5saW5lU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgSW5saW5lU3RyaW5nTGFzdCA9IG5ldyBMdWNreUlubGluZVN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0LmZmID0gZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZ0xhc3QudiA9IHc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5mYyE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0LmZjID0gY2VsbFZhbHVlLmZjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZnMhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5mcyA9IGNlbGxWYWx1ZS5mcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuY2whPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5jbCA9IGNlbGxWYWx1ZS5jbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUudW4hPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC51biA9IGNlbGxWYWx1ZS51bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuYmwhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5ibCA9IGNlbGxWYWx1ZS5ibDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuaXQhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5pdCA9IGNlbGxWYWx1ZS5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnMucHVzaChJbmxpbmVTdHJpbmdMYXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy52ID0gd29yZFRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEZvcm1hdC5zLnB1c2goSW5saW5lU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZFRleHQgPSB3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkVGV4dCArPSB3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVXb3JkVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZVdob2xlZiA9IGZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQudCA9IFwiaW5saW5lU3RyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2VsbEZvcm1hdC5zID0gW0lubGluZVN0cmluZ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmN0ID0gY2VsbEZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjZWxsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcblxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLnJlcGxhY2VTcGVjaWFsV3JhcCh0ZXh0KTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0ZXh0LmluZGV4T2YoXCJcXHJcXG5cIik+LTEgfHwgdGV4dC5pbmRleE9mKFwiXFxuXCIpPi0xKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IElubGluZVN0cmluZyA9IG5ldyBMdWNreUlubGluZVN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudiA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjZWxsRm9ybWF0ID0gY2VsbFZhbHVlLmN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsRm9ybWF0PT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQgPSBuZXcgTHVja3lTaGVldENlbGxGb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmYhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gY2VsbFZhbHVlLmZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5mYyE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5mcyE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZnMgPSBjZWxsVmFsdWUuZnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmNsIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5jbCA9IGNlbGxWYWx1ZS5jbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUudW4hPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnVuID0gY2VsbFZhbHVlLnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5ibCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuYmwgPSBjZWxsVmFsdWUuYmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLml0IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IGNlbGxWYWx1ZS5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnQgPSBcImlubGluZVN0clwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnMgPSBbSW5saW5lU3RyaW5nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmN0ID0gY2VsbEZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnYgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZVByZWZpeCA9IFwiMVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZXM6THVja3lJbmxpbmVTdHJpbmdbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByRmxhZy5mb3JFYWNoKChyKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRGbGFnID0gci5nZXRJbm5lckVsZW1lbnRzKFwidFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByUHIgPSByLmdldElubmVyRWxlbWVudHMoXCJyUHJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBJbmxpbmVTdHJpbmcgPSBuZXcgTHVja3lJbmxpbmVTdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodEZsYWchPW51bGwgJiYgdEZsYWcubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gdEZsYWdbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMucmVwbGFjZVNwZWNpYWxXcmFwKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGVDaGFyYWN0ZXIodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyUHIhPW51bGwgJiYgclByLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJwciA9IHJQclswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ogPSBnZXRsaW5lU3RyaW5nQXR0cihmcnByLFwic3pcIiksIHJGb250PWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJyRm9udFwiKSwgZmFtaWx5PWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJmYW1pbHlcIiksIGNoYXJzZXQ9Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcImNoYXJzZXRcIiksIHNjaGVtZT1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwic2NoZW1lXCIpLCBiPWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJiXCIpLCBpPWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJpXCIpLCB1PWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJ1XCIpLCBzdHJpa2U9Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcInN0cmlrZVwiKSwgdmVydEFsaWduPWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJ2ZXJ0QWxpZ25cIiksIGNvbG9yO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY0VsZSA9IGZycHIuZ2V0SW5uZXJFbGVtZW50cyhcImNvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNFbGUhPW51bGwgJiYgY0VsZS5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gZ2V0Q29sb3IoY0VsZVswXSx0aGlzLnN0eWxlcywgXCJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZihmYW1pbHkhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBmZiA9IGZvbnRGYW1pbHlzW2ZhbWlseV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJGb250IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmYgPSByRm9udDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmYhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmYgPSBmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZWxsVmFsdWUuZmYhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmYgPSBjZWxsVmFsdWUuZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29sb3IhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZWxsVmFsdWUuZmMhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN6IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZzID0gcGFyc2VJbnQoc3opO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS5mcyE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mcyA9IGNlbGxWYWx1ZS5mcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzdHJpa2UhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBwYXJzZUludChzdHJpa2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS5jbCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5jbCA9IGNlbGxWYWx1ZS5jbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih1IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnVuID0gcGFyc2VJbnQodSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2VsbFZhbHVlLnVuIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnVuID0gY2VsbFZhbHVlLnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuYmwgPSBwYXJzZUludChiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZWxsVmFsdWUuYmwhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuYmwgPSBjZWxsVmFsdWUuYmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaSE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IHBhcnNlSW50KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS5pdCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IGNlbGxWYWx1ZS5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2ZXJ0QWxpZ24hPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudmEgPSBwYXJzZUludCh2ZXJ0QWxpZ24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmY6c3RyaW5nIHwgdW5kZWZpbmVkIC8vZm9udCBmYW1pbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYzpzdHJpbmcgfCB1bmRlZmluZWQvL2ZvbnQgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmczpudW1iZXIgfCB1bmRlZmluZWQvL2ZvbnQgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsOm51bWJlciB8IHVuZGVmaW5lZC8vc3RyaWtlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW46bnVtYmVyIHwgdW5kZWZpbmVkLy91bmRlcmxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibDpudW1iZXIgfCB1bmRlZmluZWQvL2Jsb2RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdDpudW1iZXIgfCB1bmRlZmluZWQvL2l0YWxpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHY6c3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5mZj09bnVsbCAmJiBjZWxsVmFsdWUuZmYhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmYgPSBjZWxsVmFsdWUuZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5mYz09bnVsbCAmJiBjZWxsVmFsdWUuZmMhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5mcz09bnVsbCAmJiBjZWxsVmFsdWUuZnMhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZnMgPSBjZWxsVmFsdWUuZnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5jbD09bnVsbCAmJiBjZWxsVmFsdWUuY2whPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBjZWxsVmFsdWUuY2w7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy51bj09bnVsbCAmJiBjZWxsVmFsdWUudW4hPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBjZWxsVmFsdWUudW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5ibD09bnVsbCAmJiBjZWxsVmFsdWUuYmwhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuYmwgPSBjZWxsVmFsdWUuYmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5pdD09bnVsbCAmJiBjZWxsVmFsdWUuaXQhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuaXQgPSBjZWxsVmFsdWUuaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKElubGluZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsRm9ybWF0ID0gY2VsbFZhbHVlLmN0O1xuICAgICAgICAgICAgICAgICAgICBpZihjZWxsRm9ybWF0PT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQgPSBuZXcgTHVja3lTaGVldENlbGxGb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnQgPSBcImlubGluZVN0clwiO1xuICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnMgPSBzdHlsZXM7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jdCA9IGNlbGxGb3JtYXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBpZih0PT1TVF9DZWxsVHlwZVtcIklubGluZVN0cmluZ1wiXSAmJiB2IT1udWxsKXtcbiAgICBcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZXNjYXBlQ2hhcmFjdGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUudiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYocXVvdGVQcmVmaXghPW51bGwpe1xuICAgICAgICAgICAgY2VsbFZhbHVlLnFwID0gcGFyc2VJbnQocXVvdGVQcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlbGxWYWx1ZTtcbiAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlcGxhY2VTcGVjaWFsV3JhcCh0ZXh0OnN0cmluZyk6c3RyaW5ne1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9feDAwMERfL2csIFwiXCIpLnJlcGxhY2UoLyYjMTM7JiMxMDsvZywgXCJcXHJcXG5cIikucmVwbGFjZSgvJiMxMzsvZywgXCJcXHJcIikucmVwbGFjZSgvJiMxMDsvZywgXCJcXG5cIik7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBnZXRCYWNrZ3JvdW5kQnlGaWxsKGZpbGw6RWxlbWVudCwgY2xyU2NoZW1lOkVsZW1lbnRbXSk6c3RyaW5nfG51bGx7XG4gICAgICAgIGxldCBwYXR0ZXJuRmlsbHMgPSBmaWxsLmdldElubmVyRWxlbWVudHMoXCJwYXR0ZXJuRmlsbFwiKTtcbiAgICAgICAgaWYocGF0dGVybkZpbGxzIT1udWxsKXtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuRmlsbCA9IHBhdHRlcm5GaWxsc1swXTtcbiAgICAgICAgICAgIGxldCBmZ0NvbG9ycyA9IHBhdHRlcm5GaWxsLmdldElubmVyRWxlbWVudHMoXCJmZ0NvbG9yXCIpO1xuICAgICAgICAgICAgbGV0IGJnQ29sb3JzID0gcGF0dGVybkZpbGwuZ2V0SW5uZXJFbGVtZW50cyhcImJnQ29sb3JcIik7XG4gICAgICAgICAgICBsZXQgZmcsIGJnO1xuICAgICAgICAgICAgaWYoZmdDb2xvcnMhPW51bGwpe1xuICAgICAgICAgICAgICAgIGxldCBmZ0NvbG9yID0gZmdDb2xvcnNbMF07XG4gICAgICAgICAgICAgICAgZmcgPSBnZXRDb2xvcihmZ0NvbG9yLCB0aGlzLnN0eWxlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGJnQ29sb3JzIT1udWxsKXtcbiAgICAgICAgICAgICAgICBsZXQgYmdDb2xvciA9IGJnQ29sb3JzWzBdO1xuICAgICAgICAgICAgICAgIGJnID0gZ2V0Q29sb3IoYmdDb2xvciwgdGhpcy5zdHlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZmdDb2xvcnMsYmdDb2xvcnMsY2xyU2NoZW1lKTtcbiAgICAgICAgICAgIGlmKGZnIT1udWxsKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGJnIT1udWxsKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGxldCBncmFkaWVudGZpbGxzID0gZmlsbC5nZXRJbm5lckVsZW1lbnRzKFwiZ3JhZGllbnRGaWxsXCIpO1xuICAgICAgICAgICAgaWYoZ3JhZGllbnRmaWxscyE9bnVsbCl7XG4gICAgICAgICAgICAgICAgLy9ncmFpZW50IGNvbG9yIGZpbGwgaGFuZGxlclxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEJvcmRlckluZm8oYm9yZGVyczpFbGVtZW50W10pOkx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGV7XG4gICAgICAgIGlmKGJvcmRlcnM9PW51bGwpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYm9yZGVyID0gYm9yZGVyc1swXSwgYXR0ckxpc3QgPSBib3JkZXIuYXR0cmlidXRlTGlzdDtcbiAgICAgICAgbGV0IGNsclNjaGVtZSA9IHRoaXMuc3R5bGVzW1wiY2xyU2NoZW1lXCJdIGFzIEVsZW1lbnRbXTtcbiAgICAgICAgbGV0IHN0eWxlOnN0cmluZyA9IGF0dHJMaXN0LnN0eWxlO1xuICAgICAgICBpZihzdHlsZT09bnVsbCB8fCBzdHlsZT09XCJub25lXCIpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29sb3JzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJjb2xvclwiKTtcbiAgICAgICAgbGV0IGNvbG9yUmV0ID0gXCIjMDAwMDAwXCI7XG4gICAgICAgIGlmKGNvbG9ycyE9bnVsbCl7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBjb2xvcnNbMF07XG4gICAgICAgICAgICBjb2xvclJldCA9IGdldENvbG9yKGNvbG9yLCB0aGlzLnN0eWxlcywgXCJiXCIpO1xuICAgICAgICAgICAgaWYoY29sb3JSZXQ9PW51bGwpe1xuICAgICAgICAgICAgICAgIGNvbG9yUmV0ID0gXCIjMDAwMDAwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmV0ID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGUoKTtcbiAgICAgICAgcmV0LnN0eWxlID0gYm9yZGVyVHlwZXNbc3R5bGVdO1xuICAgICAgICByZXQuY29sb3IgPSBjb2xvclJldDtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgaHRtbERlY29kZSAoc3RyOnN0cmluZyk6c3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIyh4KT8oW14mXXsxLDV9KTs/L2csZnVuY3Rpb24oJCwkMSwkMikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoJDIgLCAkMSA/IDE2OjEwKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbn1cblxuIiwi77u/aW1wb3J0IHsgSUx1Y2t5RmlsZSxJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlbixJbHVja3lTaGVldFJvd0FuZENvbHVtbkxlbn0gZnJvbSBcIi4vSUx1Y2tcIjtcbmltcG9ydCB7IEx1Y2t5U2hlZXR9IGZyb20gXCIuL0x1Y2t5U2hlZXRcIjtcbmltcG9ydCB7SXVwbG9hZGZpbGVMaXN0LCBJYXR0cmlidXRlTGlzdH0gZnJvbSBcIi4uL0lDb21tb25cIjtcbmltcG9ydCB7d29ya0Jvb2tGaWxlLCBjb3JlRmlsZSwgYXBwRmlsZSwgc3R5bGVzRmlsZSwgc2hhcmVkU3RyaW5nc0ZpbGUsbnVtRm10RGVmYXVsdCx0aGVtZTFGaWxlLGNhbGNDaGFpbkZpbGUsd29ya2Jvb2tSZWxzfSBmcm9tIFwiLi4vY29tbW9uL2NvbnN0YW50XCI7XG5pbXBvcnQgeyBSZWFkWG1sLElTdHlsZUNvbGxlY3Rpb25zLEVsZW1lbnQgfSBmcm9tIFwiLi9SZWFkWG1sXCI7XG5pbXBvcnQge2dldFhtbEF0dGlidXRlfSBmcm9tIFwiLi4vY29tbW9uL21ldGhvZFwiO1xuaW1wb3J0IHsgTHVja3lGaWxlQmFzZSxMdWNreUZpbGVJbmZvLEx1Y2t5U2hlZXRCYXNlLEx1Y2t5U2hlZXRDZWxsZGF0YUJhc2UsTHVja3lTaGVldENlbGxkYXRhVmFsdWUsTHVja3lTaGVldENlbGxGb3JtYXQgfSBmcm9tIFwiLi9MdWNreUJhc2VcIjtcbmltcG9ydCB7SW1hZ2VMaXN0fSBmcm9tIFwiLi9MdWNreUltYWdlXCI7XG5cbmV4cG9ydCBjbGFzcyBMdWNreUZpbGUgZXh0ZW5kcyBMdWNreUZpbGVCYXNlIHtcblxuICAgIHByaXZhdGUgZmlsZXM6SXVwbG9hZGZpbGVMaXN0XG4gICAgcHJpdmF0ZSBzaGVldE5hbWVMaXN0OklhdHRyaWJ1dGVMaXN0XG4gICAgcHJpdmF0ZSByZWFkWG1sOlJlYWRYbWxcbiAgICBwcml2YXRlIGZpbGVOYW1lOnN0cmluZ1xuICAgIHByaXZhdGUgc3R5bGVzOklTdHlsZUNvbGxlY3Rpb25zXG4gICAgcHJpdmF0ZSBzaGFyZWRTdHJpbmdzOkVsZW1lbnRbXVxuICAgIHByaXZhdGUgY2FsY0NoYWluOkVsZW1lbnRbXVxuICAgIHByaXZhdGUgaW1hZ2VMaXN0OkltYWdlTGlzdFxuXG4gICAgY29uc3RydWN0b3IoZmlsZXM6SXVwbG9hZGZpbGVMaXN0LCBmaWxlTmFtZTpzdHJpbmcpIHsgXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmlsZXMgPSBmaWxlcztcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IGZpbGVOYW1lO1xuICAgICAgICB0aGlzLnJlYWRYbWwgPSBuZXcgUmVhZFhtbChmaWxlcyk7XG4gICAgICAgIHRoaXMuZ2V0U2hlZXROYW1lTGlzdCgpO1xuXG4gICAgICAgIHRoaXMuc2hhcmVkU3RyaW5ncyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNzdC9zaVwiLCBzaGFyZWRTdHJpbmdzRmlsZSk7XG4gICAgICAgIHRoaXMuY2FsY0NoYWluID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2FsY0NoYWluL2NcIiwgY2FsY0NoYWluRmlsZSk7XG4gICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICAgIHRoaXMuc3R5bGVzW1wiY2VsbFhmc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjZWxsWGZzL3hmXCIsIHN0eWxlc0ZpbGUpO1xuICAgICAgICB0aGlzLnN0eWxlc1tcImNlbGxTdHlsZVhmc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjZWxsU3R5bGVYZnMveGZcIiwgc3R5bGVzRmlsZSk7XG4gICAgICAgIHRoaXMuc3R5bGVzW1wiY2VsbFN0eWxlc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjZWxsU3R5bGVzL2NlbGxTdHlsZVwiLCBzdHlsZXNGaWxlKTtcbiAgICAgICAgdGhpcy5zdHlsZXNbXCJmb250c1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmb250cy9mb250XCIsIHN0eWxlc0ZpbGUpO1xuICAgICAgICB0aGlzLnN0eWxlc1tcImZpbGxzXCJdID0gIHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZpbGxzL2ZpbGxcIiwgc3R5bGVzRmlsZSk7XG4gICAgICAgIHRoaXMuc3R5bGVzW1wiYm9yZGVyc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib3JkZXJzL2JvcmRlclwiLCBzdHlsZXNGaWxlKTtcbiAgICAgICAgdGhpcy5zdHlsZXNbXCJjbHJTY2hlbWVcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYTpjbHJTY2hlbWUvYTpkazF8YTpsdDF8YTpkazJ8YTpsdDJ8YTphY2NlbnQxfGE6YWNjZW50MnxhOmFjY2VudDN8YTphY2NlbnQ0fGE6YWNjZW50NXxhOmFjY2VudDZ8YTpobGlua3xhOmZvbEhsaW5rXCIsIHRoZW1lMUZpbGUpO1xuICAgICAgICB0aGlzLnN0eWxlc1tcImluZGV4ZWRDb2xvcnNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29sb3JzL2luZGV4ZWRDb2xvcnMvcmdiQ29sb3JcIiwgc3R5bGVzRmlsZSk7XG4gICAgICAgIHRoaXMuc3R5bGVzW1wibXJ1Q29sb3JzXCJdID0gIHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvbG9ycy9tcnVDb2xvcnMvY29sb3JcIiwgc3R5bGVzRmlsZSk7XG5cbiAgICAgICAgdGhpcy5pbWFnZUxpc3QgPSBuZXcgSW1hZ2VMaXN0KGZpbGVzKTtcblxuICAgICAgICBsZXQgbnVtZm10cyA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJudW1GbXQvbnVtRm10XCIsIHN0eWxlc0ZpbGUpO1xuICAgICAgICBsZXQgbnVtRm10RGVmYXVsdEMgPSBudW1GbXREZWZhdWx0O1xuICAgICAgICBmb3IobGV0IGk9MDtpPG51bWZtdHMubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBudW1mbXRzW2ldLmF0dHJpYnV0ZUxpc3Q7XG4gICAgICAgICAgICBsZXQgbnVtZm10aWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJudW1GbXRJZFwiLCBcIjQ5XCIpO1xuICAgICAgICAgICAgbGV0IGZvcm1hdGNvZGUgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJmb3JtYXRDb2RlXCIsIFwiQFwiKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG51bWZtdGlkLCBmb3JtYXRjb2RlKTtcbiAgICAgICAgICAgIGlmKCEobnVtZm10aWQgaW4gbnVtRm10RGVmYXVsdCkpe1xuICAgICAgICAgICAgICAgIG51bUZtdERlZmF1bHRDW251bWZtdGlkXSA9IGZvcm1hdGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShudW1GbXREZWZhdWx0QyksIG51bWZtdHMpO1xuICAgICAgICB0aGlzLnN0eWxlc1tcIm51bWZtdHNcIl0gPSAgbnVtRm10RGVmYXVsdEM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIEFsbCBzaGVldCBuYW1lIG9mIHdvcmtib29rXG4gICAgKi9cbiAgICBwcml2YXRlIGdldFNoZWV0TmFtZUxpc3QoKXtcbiAgICAgICAgbGV0IHdvcmtib29rUmVsTGlzdCA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIlJlbGF0aW9uc2hpcHMvUmVsYXRpb25zaGlwXCIsIHdvcmtib29rUmVscyk7XG4gICAgICAgIGlmKHdvcmtib29rUmVsTGlzdD09bnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVnZXggPSBuZXcgUmVnRXhwKFwid29ya3NoZWV0cy9bXi9dKj8ueG1sXCIpO1xuICAgICAgICBsZXQgc2hlZXROYW1lczpJYXR0cmlidXRlTGlzdCA9IHt9O1xuICAgICAgICBmb3IobGV0IGk9MDtpPHdvcmtib29rUmVsTGlzdC5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgIGxldCByZWwgPSB3b3JrYm9va1JlbExpc3RbaV0sIGF0dHJMaXN0ID0gcmVsLmF0dHJpYnV0ZUxpc3Q7XG4gICAgICAgICAgICBsZXQgaWQgPSBhdHRyTGlzdFtcIklkXCJdLCB0YXJnZXQgPSBhdHRyTGlzdFtcIlRhcmdldFwiXTtcbiAgICAgICAgICAgIGlmKHJlZ2V4LnRlc3QodGFyZ2V0KSl7XG4gICAgICAgICAgICAgICAgc2hlZXROYW1lc1tpZF0gPSBcInhsL1wiICsgdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2hlZXROYW1lTGlzdCA9IHNoZWV0TmFtZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0gc2hlZXROYW1lIFdvcmtTaGVldCduYW1lIFxuICAgICogQHJldHVybiBzaGVldCBmaWxlIG5hbWUgYW5kIHBhdGggaW4gemlwXG4gICAgKi9cbiAgIHByaXZhdGUgZ2V0U2hlZXRGaWxlQnlzaGVldElkKHNoZWV0SWQ6c3RyaW5nKXtcbiAgICAgICAgLy8gZm9yKGxldCBpPTA7aTx0aGlzLnNoZWV0TmFtZUxpc3QubGVuZ3RoO2krKyl7XG4gICAgICAgIC8vICAgICBsZXQgc2hlZXRGaWxlTmFtZSA9IHRoaXMuc2hlZXROYW1lTGlzdFtpXTtcbiAgICAgICAgLy8gICAgIGlmKHNoZWV0RmlsZU5hbWUuaW5kZXhPZihcInNoZWV0XCIrc2hlZXRJZCk+LTEpe1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBzaGVldEZpbGVOYW1lO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiB0aGlzLnNoZWV0TmFtZUxpc3Rbc2hlZXRJZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHdvcmtCb29rIGluZm9ybWF0aW9uXG4gICAgKi9cbiAgICBnZXRXb3JrQm9va0luZm8oKXtcbiAgICAgICAgbGV0IENvbXBhbnkgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJDb21wYW55XCIsIGFwcEZpbGUpO1xuICAgICAgICBsZXQgQXBwVmVyc2lvbiA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkFwcFZlcnNpb25cIiwgYXBwRmlsZSk7XG4gICAgICAgIGxldCBjcmVhdG9yID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGM6Y3JlYXRvclwiLCBjb3JlRmlsZSk7XG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRCeSA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNwOmxhc3RNb2RpZmllZEJ5XCIsIGNvcmVGaWxlKTtcbiAgICAgICAgbGV0IGNyZWF0ZWQgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkY3Rlcm1zOmNyZWF0ZWRcIiwgY29yZUZpbGUpO1xuICAgICAgICBsZXQgbW9kaWZpZWQgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkY3Rlcm1zOm1vZGlmaWVkXCIsIGNvcmVGaWxlKTtcbiAgICAgICAgdGhpcy5pbmZvID0gbmV3IEx1Y2t5RmlsZUluZm8oKTtcbiAgICAgICAgdGhpcy5pbmZvLm5hbWUgPSB0aGlzLmZpbGVOYW1lO1xuICAgICAgICB0aGlzLmluZm8uY3JlYXRvciA9IGNyZWF0b3IubGVuZ3RoPjA/Y3JlYXRvclswXS52YWx1ZTpcIlwiO1xuICAgICAgICB0aGlzLmluZm8ubGFzdG1vZGlmaWVkYnkgPSBsYXN0TW9kaWZpZWRCeS5sZW5ndGg+MD9sYXN0TW9kaWZpZWRCeVswXS52YWx1ZTpcIlwiO1xuICAgICAgICB0aGlzLmluZm8uY3JlYXRlZFRpbWUgPSBjcmVhdGVkLmxlbmd0aD4wP2NyZWF0ZWRbMF0udmFsdWU6XCJcIjtcbiAgICAgICAgdGhpcy5pbmZvLm1vZGlmaWVkVGltZSA9IG1vZGlmaWVkLmxlbmd0aD4wP21vZGlmaWVkWzBdLnZhbHVlOlwiXCI7XG4gICAgICAgIHRoaXMuaW5mby5jb21wYW55ID0gQ29tcGFueS5sZW5ndGg+MD9Db21wYW55WzBdLnZhbHVlOlwiXCI7XG4gICAgICAgIHRoaXMuaW5mby5hcHB2ZXJzaW9uID0gQXBwVmVyc2lvbi5sZW5ndGg+MD9BcHBWZXJzaW9uWzBdLnZhbHVlOlwiXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIEFsbCBzaGVldCAsIGluY2x1ZGUgd2hvbGUgaW5mb3JtYXRpb25cbiAgICAqL1xuICAgIGdldFNoZWV0c0Z1bGwoaXNJbml0aWFsQ2VsbDpib29sZWFuPXRydWUpe1xuICAgICAgICBsZXQgc2hlZXRzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2hlZXRzL3NoZWV0XCIsIHdvcmtCb29rRmlsZSk7XG4gICAgICAgIGxldCBzaGVldExpc3Q6SWF0dHJpYnV0ZUxpc3QgPSB7fTtcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gc2hlZXRzKXtcbiAgICAgICAgICAgIGxldCBzaGVldCA9IHNoZWV0c1trZXldO1xuICAgICAgICAgICAgc2hlZXRMaXN0W3NoZWV0LmF0dHJpYnV0ZUxpc3QubmFtZV0gPSBzaGVldC5hdHRyaWJ1dGVMaXN0W1wic2hlZXRJZFwiXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoZWV0cyA9IFtdO1xuICAgICAgICBsZXQgb3JkZXIgPSAwO1xuICAgICAgICBmb3IobGV0IGtleSBpbiBzaGVldHMpe1xuICAgICAgICAgICAgbGV0IHNoZWV0ID0gc2hlZXRzW2tleV07XG4gICAgICAgICAgICBsZXQgc2hlZXROYW1lID0gc2hlZXQuYXR0cmlidXRlTGlzdC5uYW1lOyBcbiAgICAgICAgICAgIGxldCBzaGVldElkID0gc2hlZXQuYXR0cmlidXRlTGlzdFtcInNoZWV0SWRcIl07IFxuICAgICAgICAgICAgbGV0IHJpZCA9IHNoZWV0LmF0dHJpYnV0ZUxpc3RbXCJyOmlkXCJdOyBcbiAgICAgICAgICAgIGxldCBzaGVldEZpbGUgPSB0aGlzLmdldFNoZWV0RmlsZUJ5c2hlZXRJZChyaWQpO1xuXG4gICAgICAgICAgICBsZXQgZHJhd2luZyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIndvcmtzaGVldC9kcmF3aW5nXCIsIHNoZWV0RmlsZSksIGRyYXdpbmdGaWxlLCBkcmF3aW5nUmVsc0ZpbGU7XG4gICAgICAgICAgICBpZihkcmF3aW5nIT1udWxsICYmIGRyYXdpbmcubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IGRyYXdpbmdbMF0uYXR0cmlidXRlTGlzdDtcbiAgICAgICAgICAgICAgICBsZXQgcmlkID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwicjppZFwiLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZihyaWQhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBkcmF3aW5nRmlsZSA9IHRoaXMuZ2V0RHJhd2luZ0ZpbGUocmlkLCBzaGVldEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBkcmF3aW5nUmVsc0ZpbGUgPSB0aGlzLmdldERyYXdpbmdSZWxzRmlsZShkcmF3aW5nRmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIGlmKHNoZWV0RmlsZSE9bnVsbCl7XG4gICAgICAgICAgICAgICAgbGV0IHNoZWV0ID0gbmV3IEx1Y2t5U2hlZXQoc2hlZXROYW1lLCBzaGVldElkLCBvcmRlciwgaXNJbml0aWFsQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRGaWxlOnNoZWV0RmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRYbWw6dGhpcy5yZWFkWG1sLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0TGlzdDpzaGVldExpc3QsIFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOnRoaXMuc3R5bGVzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZFN0cmluZ3M6dGhpcy5zaGFyZWRTdHJpbmdzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNDaGFpbjp0aGlzLmNhbGNDaGFpbiwgXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUxpc3Q6dGhpcy5pbWFnZUxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3aW5nRmlsZTpkcmF3aW5nRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdpbmdSZWxzRmlsZTpkcmF3aW5nUmVsc0ZpbGUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbldpZHRoU2V0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dIZWlnaHRTZXQgPSBbXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VQb3NpdGlvbkNhY3VsYXRpb24oc2hlZXQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zaGVldHMucHVzaChzaGVldCk7XG4gICAgICAgICAgICAgICAgb3JkZXIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY29sdW1uV2lkdGhTZXQ6bnVtYmVyW10gPSBbXTtcbiAgICBwcml2YXRlIHJvd0hlaWdodFNldDpudW1iZXJbXSA9IFtdO1xuXG4gICAgcHJpdmF0ZSBleHRlbmRBcnJheShpbmRleDpudW1iZXIsIHNldHM6bnVtYmVyW10sZGVmOm51bWJlciwgaGlkZGVuOklsdWNreVNoZWV0Um93QW5kQ29sdW1uSGlkZGVuLCBsZW5zOklsdWNreVNoZWV0Um93QW5kQ29sdW1uTGVuKXtcbiAgICAgICAgaWYoaW5kZXg8c2V0cy5sZW5ndGgpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHNldHMubGVuZ3RoLCBlbmRJbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgYWxsR2FwID0gMDtcbiAgICAgICAgaWYoc3RhcnRJbmRleD4wKXtcbiAgICAgICAgICAgIGFsbEdhcCA9IHNldHNbc3RhcnRJbmRleC0xXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNle1xuICAgICAgICAvLyAgICAgc2V0cy5wdXNoKDApO1xuICAgICAgICAvLyB9XG4gICAgICAgIGZvcihsZXQgaT1zdGFydEluZGV4O2k8PWVuZEluZGV4O2krKyl7XG4gICAgICAgICAgICBsZXQgZ2FwID0gZGVmLCBpc3RyaW5nICA9IGkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmKGlzdHJpbmcgaW4gaGlkZGVuKXtcbiAgICAgICAgICAgICAgICBnYXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihpc3RyaW5nIGluIGxlbnMpe1xuICAgICAgICAgICAgICAgIGdhcCA9IGxlbnNbaXN0cmluZ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFsbEdhcCArPSBNYXRoLnJvdW5kKGdhcCArIDEpO1xuXG4gICAgICAgICAgICBzZXRzLnB1c2goYWxsR2FwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGltYWdlUG9zaXRpb25DYWN1bGF0aW9uKHNoZWV0Okx1Y2t5U2hlZXQpe1xuICAgICAgICBsZXQgaW1hZ2VzID0gc2hlZXQuaW1hZ2VzLCBkZWZhdWx0Q29sV2lkdGggPSBzaGVldC5kZWZhdWx0Q29sV2lkdGgsIGRlZmF1bHRSb3dIZWlnaHQgPSBzaGVldC5kZWZhdWx0Um93SGVpZ2h0O1xuICAgICAgICBsZXQgY29saGlkZGVuID0ge307XG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5jb2xoaWRkZW4pe1xuICAgICAgICAgICAgY29saGlkZGVuID0gc2hlZXQuY29uZmlnLmNvbGhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2x1bW5sZW4gPSB7fTtcbiAgICAgICAgaWYoc2hlZXQuY29uZmlnLmNvbHVtbmxlbil7XG4gICAgICAgICAgICBjb2x1bW5sZW4gPSBzaGVldC5jb25maWcuY29sdW1ubGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJvd2hpZGRlbiA9IHt9O1xuICAgICAgICBpZihzaGVldC5jb25maWcucm93aGlkZGVuKXtcbiAgICAgICAgICAgIHJvd2hpZGRlbiA9IHNoZWV0LmNvbmZpZy5yb3doaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcm93bGVuID0ge307XG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5yb3dsZW4pe1xuICAgICAgICAgICAgcm93bGVuID0gc2hlZXQuY29uZmlnLnJvd2xlbjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gaW1hZ2VzKXtcbiAgICAgICAgICAgIGxldCBpbWFnZU9iamVjdDphbnkgPSBpbWFnZXNba2V5XTsvL0ltYWdlLCBsdWNreUltYWdlXG4gICAgICAgICAgICBsZXQgZnJvbUNvbCA9IGltYWdlT2JqZWN0LmZyb21Db2w7XG4gICAgICAgICAgICBsZXQgZnJvbUNvbE9mZiA9IGltYWdlT2JqZWN0LmZyb21Db2xPZmY7XG4gICAgICAgICAgICBsZXQgZnJvbVJvdyA9IGltYWdlT2JqZWN0LmZyb21Sb3c7XG4gICAgICAgICAgICBsZXQgZnJvbVJvd09mZiA9IGltYWdlT2JqZWN0LmZyb21Sb3dPZmY7XG5cbiAgICAgICAgICAgIGxldCB0b0NvbCA9IGltYWdlT2JqZWN0LnRvQ29sO1xuICAgICAgICAgICAgbGV0IHRvQ29sT2ZmID0gaW1hZ2VPYmplY3QudG9Db2xPZmY7XG4gICAgICAgICAgICBsZXQgdG9Sb3cgPSBpbWFnZU9iamVjdC50b1JvdztcbiAgICAgICAgICAgIGxldCB0b1Jvd09mZiA9IGltYWdlT2JqZWN0LnRvUm93T2ZmO1xuXG4gICAgICAgICAgICBsZXQgeF9uID0wLHlfbiA9IDA7XG4gICAgICAgICAgICBsZXQgY3hfbiA9IDAsIGN5X24gPSAwOyBcblxuICAgICAgICAgICAgaWYoZnJvbUNvbD49dGhpcy5jb2x1bW5XaWR0aFNldC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kQXJyYXkoZnJvbUNvbCwgdGhpcy5jb2x1bW5XaWR0aFNldCwgZGVmYXVsdENvbFdpZHRoLCBjb2xoaWRkZW4sIGNvbHVtbmxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihmcm9tQ29sPT0wKXtcbiAgICAgICAgICAgICAgICB4X24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICB4X24gPSB0aGlzLmNvbHVtbldpZHRoU2V0W2Zyb21Db2wtMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4X24gPSB4X24gKyBmcm9tQ29sT2ZmO1xuXG4gICAgICAgICAgICBpZihmcm9tUm93Pj10aGlzLnJvd0hlaWdodFNldC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kQXJyYXkoZnJvbVJvdywgdGhpcy5yb3dIZWlnaHRTZXQsIGRlZmF1bHRSb3dIZWlnaHQsIHJvd2hpZGRlbiwgcm93bGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGZyb21Sb3c9PTApe1xuICAgICAgICAgICAgICAgIHlfbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHlfbiA9IHRoaXMucm93SGVpZ2h0U2V0W2Zyb21Sb3ctMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5X24gPSB5X24gKyBmcm9tUm93T2ZmO1xuXG5cbiAgICAgICAgICAgIGlmKHRvQ29sPj10aGlzLmNvbHVtbldpZHRoU2V0Lmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRBcnJheSh0b0NvbCwgdGhpcy5jb2x1bW5XaWR0aFNldCwgZGVmYXVsdENvbFdpZHRoLCBjb2xoaWRkZW4sIGNvbHVtbmxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0b0NvbD09MCl7XG4gICAgICAgICAgICAgICAgY3hfbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGN4X24gPSB0aGlzLmNvbHVtbldpZHRoU2V0W3RvQ29sLTFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3hfbiA9IGN4X24gKyB0b0NvbE9mZi0geF9uO1xuXG4gICAgICAgICAgICBpZih0b1Jvdz49dGhpcy5yb3dIZWlnaHRTZXQubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEFycmF5KHRvUm93LCB0aGlzLnJvd0hlaWdodFNldCwgZGVmYXVsdFJvd0hlaWdodCwgcm93aGlkZGVuLCByb3dsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodG9Sb3c9PTApe1xuICAgICAgICAgICAgICAgIGN5X24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBjeV9uID0gdGhpcy5yb3dIZWlnaHRTZXRbdG9Sb3ctMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN5X24gPSBjeV9uICsgdG9Sb3dPZmYgLSB5X247XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRlZmF1bHRDb2xXaWR0aCwgY29saGlkZGVuICwgY29sdW1ubGVuKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGZyb21Db2wsIHRoaXMuY29sdW1uV2lkdGhTZXRbZnJvbUNvbF0gLCBmcm9tQ29sT2ZmKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRvQ29sLCB0aGlzLmNvbHVtbldpZHRoU2V0W3RvQ29sXSAsIHRvQ29sT2ZmLCBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbHVtbldpZHRoU2V0KSk7XG5cbiAgICAgICAgICAgIGltYWdlT2JqZWN0Lm9yaWdpbldpZHRoID0gY3hfbjtcbiAgICAgICAgICAgIGltYWdlT2JqZWN0Lm9yaWdpbkhlaWdodCA9IGN5X247XG5cbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmNyb3AuaGVpZ2h0ID0gY3lfbjtcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmNyb3Aud2lkdGggPSBjeF9uO1xuXG4gICAgICAgICAgICBpbWFnZU9iamVjdC5kZWZhdWx0LmhlaWdodCA9IGN5X247XG4gICAgICAgICAgICBpbWFnZU9iamVjdC5kZWZhdWx0LmxlZnQgPSB4X247XG4gICAgICAgICAgICBpbWFnZU9iamVjdC5kZWZhdWx0LnRvcCA9IHlfbjtcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmRlZmF1bHQud2lkdGggPSBjeF9uO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2codGhpcy5jb2x1bW5XaWR0aFNldCwgdGhpcy5yb3dIZWlnaHRTZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiBkcmF3aW5nIGZpbGUgc3RyaW5nXG4gICAgKi9cbiAgIHByaXZhdGUgZ2V0RHJhd2luZ0ZpbGUocmlkOnN0cmluZywgc2hlZXRGaWxlOnN0cmluZyk6c3RyaW5ne1xuICAgICAgICBsZXQgc2hlZXRSZWxzUGF0aCA9IFwieGwvd29ya3NoZWV0cy9fcmVscy9cIjtcbiAgICAgICAgbGV0IHNoZWV0RmlsZUFyciA9IHNoZWV0RmlsZS5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBzaGVldFJlbHNOYW1lID0gc2hlZXRGaWxlQXJyW3NoZWV0RmlsZUFyci5sZW5ndGgtMV07XG5cbiAgICAgICAgbGV0IHNoZWV0UmVsc0ZpbGUgPSBzaGVldFJlbHNQYXRoICsgc2hlZXRSZWxzTmFtZSArIFwiLnJlbHNcIjtcblxuICAgICAgICBsZXQgZHJhd2luZyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIlJlbGF0aW9uc2hpcHMvUmVsYXRpb25zaGlwXCIsIHNoZWV0UmVsc0ZpbGUpO1xuICAgICAgICBpZihkcmF3aW5nLmxlbmd0aD4wKXtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8ZHJhd2luZy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgICAgICBsZXQgcmVsYXRpb25zaGlwID0gZHJhd2luZ1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSByZWxhdGlvbnNoaXAuYXR0cmlidXRlTGlzdDtcbiAgICAgICAgICAgICAgICBsZXQgcmVsYXRpb25zaGlwSWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJJZFwiLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZihyZWxhdGlvbnNoaXBJZD09cmlkKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIlRhcmdldFwiLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodGFyZ2V0IT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQucmVwbGFjZSgvXFwuXFwuXFwvL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgZ2V0RHJhd2luZ1JlbHNGaWxlKGRyYXdpbmdGaWxlOnN0cmluZyk6c3RyaW5ne1xuICAgICAgICBsZXQgZHJhd2luZ1JlbHNQYXRoID0gXCJ4bC9kcmF3aW5ncy9fcmVscy9cIjtcbiAgICAgICAgbGV0IGRyYXdpbmdGaWxlQXJyID0gZHJhd2luZ0ZpbGUuc3BsaXQoXCIvXCIpO1xuICAgICAgICBsZXQgZHJhd2luZ1JlbHNOYW1lID0gZHJhd2luZ0ZpbGVBcnJbZHJhd2luZ0ZpbGVBcnIubGVuZ3RoLTFdO1xuXG4gICAgICAgIGxldCBkcmF3aW5nUmVsc0ZpbGUgPSBkcmF3aW5nUmVsc1BhdGggKyBkcmF3aW5nUmVsc05hbWUgKyBcIi5yZWxzXCI7XG5cbiAgICAgICAgcmV0dXJuIGRyYXdpbmdSZWxzRmlsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4gQWxsIHNoZWV0IGJhc2UgaW5mb3JtYXRpb24gd2lkdGhvdXQgY2VsbCBhbmQgY29uZmlnXG4gICAgKi9cbiAgICBnZXRTaGVldHNXaXRob3V0Q2VsbCgpe1xuICAgICAgICB0aGlzLmdldFNoZWV0c0Z1bGwoZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAqIEByZXR1cm4gTHVja3lTaGVldCBmaWxlIGpzb25cbiAgICAqL1xuICAgIFBhcnNlKCk6c3RyaW5ne1xuICAgICAgICAvLyBsZXQgeG1sID0gdGhpcy5yZWFkWG1sO1xuICAgICAgICAvLyBmb3IobGV0IGtleSBpbiB0aGlzLnNoZWV0TmFtZUxpc3Qpe1xuICAgICAgICAvLyAgICAgbGV0IHNoZWV0TmFtZT10aGlzLnNoZWV0TmFtZUxpc3Rba2V5XTtcbiAgICAgICAgLy8gICAgIGxldCBzaGVldENvbHVtbnMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJyb3cvYy9mXCIsIHNoZWV0TmFtZSk7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhzaGVldENvbHVtbnMpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHJldHVybiBcIlwiO1xuXG4gICAgICAgIHRoaXMuZ2V0V29ya0Jvb2tJbmZvKCk7XG4gICAgICAgIHRoaXMuZ2V0U2hlZXRzRnVsbCgpO1xuXG4gICAgICAgIC8vIGZvcihsZXQgaT0wO2k8dGhpcy5zaGVldHMubGVuZ3RoO2krKyl7XG4gICAgICAgIC8vICAgICBsZXQgc2hlZXQgPSB0aGlzLnNoZWV0c1tpXTtcbiAgICAgICAgLy8gICAgIGxldCBfYm9yZGVySW5mbyA9IHNoZWV0LmNvbmZpZy5fYm9yZGVySW5mbztcbiAgICAgICAgLy8gICAgIGlmKF9ib3JkZXJJbmZvPT1udWxsKXtcbiAgICAgICAgLy8gICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIGxldCBfYm9yZGVySW5mb0tleXMgPSBPYmplY3Qua2V5cyhfYm9yZGVySW5mbyk7XG4gICAgICAgIC8vICAgICBfYm9yZGVySW5mb0tleXMuc29ydCgpO1xuICAgICAgICAvLyAgICAgZm9yKGxldCBhPTA7YTxfYm9yZGVySW5mb0tleXMubGVuZ3RoO2ErKyl7XG4gICAgICAgIC8vICAgICAgICAgbGV0IGtleSA9IHBhcnNlSW50KF9ib3JkZXJJbmZvS2V5c1thXSk7XG4gICAgICAgIC8vICAgICAgICAgbGV0IGIgPSBfYm9yZGVySW5mb1trZXldO1xuICAgICAgICAvLyAgICAgICAgIGlmKGIuY2VsbHMubGVuZ3RoPT0wKXtcbiAgICAgICAgLy8gICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgIGlmKHNoZWV0LmNvbmZpZy5ib3JkZXJJbmZvPT1udWxsKXtcbiAgICAgICAgLy8gICAgICAgICAgICAgc2hlZXQuY29uZmlnLmJvcmRlckluZm8gPSBbXTtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgc2hlZXQuY29uZmlnLmJvcmRlckluZm8ucHVzaChiKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRvSnNvblN0cmluZyh0aGlzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvSnNvblN0cmluZyhmaWxlOklMdWNreUZpbGUpOnN0cmluZ3tcbiAgICAgICAgbGV0IEx1Y2t5T3V0UHV0RmlsZSA9IG5ldyBMdWNreUZpbGVCYXNlKCk7XG4gICAgICAgIEx1Y2t5T3V0UHV0RmlsZS5pbmZvID0gZmlsZS5pbmZvO1xuICAgICAgICBMdWNreU91dFB1dEZpbGUuc2hlZXRzID0gW107XG5cbiAgICAgICAgZmlsZS5zaGVldHMuZm9yRWFjaCgoc2hlZXQpPT57XG4gICAgICAgICAgICBsZXQgc2hlZXRvdXQgPSBuZXcgTHVja3lTaGVldEJhc2UoKTtcbiAgICAgICAgICAgIC8vbGV0IGF0dHJOYW1lID0gW1wibmFtZVwiLFwiY29sb3JcIixcImNvbmZpZ1wiLFwiaW5kZXhcIixcInN0YXR1c1wiLFwib3JkZXJcIixcInJvd1wiLFwiY29sdW1uXCIsXCJsdWNreXNoZWV0X3NlbGVjdF9zYXZlXCIsXCJzY3JvbGxMZWZ0XCIsXCJzY3JvbGxUb3BcIixcInpvb21SYXRpb1wiLFwic2hvd0dyaWRMaW5lc1wiLFwiZGVmYXVsdENvbFdpZHRoXCIsXCJkZWZhdWx0Um93SGVpZ2h0XCIsXCJjZWxsZGF0YVwiLFwiY2hhcnRcIixcImlzUGl2b3RUYWJsZVwiLFwicGl2b3RUYWJsZVwiLFwibHVja3lzaGVldF9jb25kaXRpb25mb3JtYXRfc2F2ZVwiLFwiZnJlZXplblwiLFwiY2FsY0NoYWluXCJdO1xuXG4gICAgICAgICAgICBpZihzaGVldC5uYW1lIT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5uYW1lID0gc2hlZXQubmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2hlZXQuY29sb3IhPW51bGwpe1xuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmNvbG9yID0gc2hlZXQuY29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNoZWV0LmNvbmZpZyE9bnVsbCl7XG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuY29uZmlnID0gc2hlZXQuY29uZmlnO1xuICAgICAgICAgICAgICAgIC8vIGlmKHNoZWV0b3V0LmNvbmZpZy5fYm9yZGVySW5mbyE9bnVsbCl7XG4gICAgICAgICAgICAgICAgLy8gICAgIGRlbGV0ZSBzaGVldG91dC5jb25maWcuX2JvcmRlckluZm87XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzaGVldC5pbmRleCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuaW5kZXggPSBzaGVldC5pbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2hlZXQuc3RhdHVzIT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5zdGF0dXMgPSBzaGVldC5zdGF0dXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNoZWV0Lm9yZGVyIT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5vcmRlciA9IHNoZWV0Lm9yZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzaGVldC5yb3chPW51bGwpe1xuICAgICAgICAgICAgICAgIHNoZWV0b3V0LnJvdyA9IHNoZWV0LnJvdztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2hlZXQuY29sdW1uIT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jb2x1bW4gPSBzaGVldC5jb2x1bW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNoZWV0Lmx1Y2t5c2hlZXRfc2VsZWN0X3NhdmUhPW51bGwpe1xuICAgICAgICAgICAgICAgIHNoZWV0b3V0Lmx1Y2t5c2hlZXRfc2VsZWN0X3NhdmUgPSBzaGVldC5sdWNreXNoZWV0X3NlbGVjdF9zYXZlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzaGVldC5zY3JvbGxMZWZ0IT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5zY3JvbGxMZWZ0ID0gc2hlZXQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2hlZXQuc2Nyb2xsVG9wIT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5zY3JvbGxUb3AgPSBzaGVldC5zY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNoZWV0Lnpvb21SYXRpbyE9bnVsbCl7XG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuem9vbVJhdGlvID0gc2hlZXQuem9vbVJhdGlvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzaGVldC5zaG93R3JpZExpbmVzIT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5zaG93R3JpZExpbmVzID0gc2hlZXQuc2hvd0dyaWRMaW5lcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2hlZXQuZGVmYXVsdENvbFdpZHRoIT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5kZWZhdWx0Q29sV2lkdGggPSBzaGVldC5kZWZhdWx0Q29sV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNoZWV0LmRlZmF1bHRSb3dIZWlnaHQhPW51bGwpe1xuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmRlZmF1bHRSb3dIZWlnaHQgPSBzaGVldC5kZWZhdWx0Um93SGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzaGVldC5jZWxsZGF0YSE9bnVsbCl7XG4gICAgICAgICAgICAgICAgLy8gc2hlZXRvdXQuY2VsbGRhdGEgPSBzaGVldC5jZWxsZGF0YTtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jZWxsZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIHNoZWV0LmNlbGxkYXRhLmZvckVhY2goKGNlbGwpPT57XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsb3V0ID0gbmV3IEx1Y2t5U2hlZXRDZWxsZGF0YUJhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbG91dC5yID0gY2VsbC5yO1xuICAgICAgICAgICAgICAgICAgICBjZWxsb3V0LmMgPSBjZWxsLmM7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxvdXQudiA9IGNlbGwudjtcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRvdXQuY2VsbGRhdGEucHVzaChjZWxsb3V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2hlZXQuY2hhcnQhPW51bGwpe1xuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmNoYXJ0ID0gc2hlZXQuY2hhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNoZWV0LmlzUGl2b3RUYWJsZSE9bnVsbCl7XG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuaXNQaXZvdFRhYmxlID0gc2hlZXQuaXNQaXZvdFRhYmxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzaGVldC5waXZvdFRhYmxlIT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5waXZvdFRhYmxlID0gc2hlZXQucGl2b3RUYWJsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2hlZXQubHVja3lzaGVldF9jb25kaXRpb25mb3JtYXRfc2F2ZSE9bnVsbCl7XG4gICAgICAgICAgICAgICAgc2hlZXRvdXQubHVja3lzaGVldF9jb25kaXRpb25mb3JtYXRfc2F2ZSA9IHNoZWV0Lmx1Y2t5c2hlZXRfY29uZGl0aW9uZm9ybWF0X3NhdmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNoZWV0LmZyZWV6ZW4hPW51bGwpe1xuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmZyZWV6ZW4gPSBzaGVldC5mcmVlemVuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzaGVldC5jYWxjQ2hhaW4hPW51bGwpe1xuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmNhbGNDaGFpbiA9IHNoZWV0LmNhbGNDaGFpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2hlZXQuaW1hZ2VzIT1udWxsKXtcbiAgICAgICAgICAgICAgICBzaGVldG91dC5pbWFnZXMgPSBzaGVldC5pbWFnZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIEx1Y2t5T3V0UHV0RmlsZS5zaGVldHMucHVzaChzaGVldG91dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShMdWNreU91dFB1dEZpbGUpO1xuICAgIH1cblxuXG59IiwiaW1wb3J0IHsgSWx1Y2t5SW1hZ2UgfSBmcm9tIFwiLi9JTHVja1wiO1xuaW1wb3J0IHtMdWNreVNoZWV0Q2VsbGRhdGF9IGZyb20gXCIuL0x1Y2t5Q2VsbFwiO1xuaW1wb3J0IHsgSXVwbG9hZGZpbGVMaXN0LCBJYXR0cmlidXRlTGlzdCB9IGZyb20gXCIuLi9JQ29tbW9uXCI7XG5pbXBvcnQge2dldFhtbEF0dGlidXRlLCBnZXRDb2x1bW5XaWR0aFBpeGVsLCBmcm9tdWxhUmVmLGdldFJvd0hlaWdodFBpeGVsLGdldGNlbGxyYW5nZX0gZnJvbSBcIi4uL2NvbW1vbi9tZXRob2RcIjtcbmltcG9ydCB7Ym9yZGVyVHlwZXN9IGZyb20gXCIuLi9jb21tb24vY29uc3RhbnRcIjtcbmltcG9ydCB7IFJlYWRYbWwsIElTdHlsZUNvbGxlY3Rpb25zLCBFbGVtZW50LGdldENvbG9yIH0gZnJvbSBcIi4vUmVhZFhtbFwiO1xuaW1wb3J0IHsgTHVja3lJbWFnZUJhc2UgfSBmcm9tIFwiLi9MdWNreUJhc2VcIjtcbmltcG9ydCB7IFVET0MsRnJvbUVNRixUb0NvbnRleHQyRCAgfSBmcm9tIFwiLi4vY29tbW9uL2VtZlwiO1xuXG5cbmV4cG9ydCBjbGFzcyBJbWFnZUxpc3Qge1xuICAgIHByaXZhdGUgaW1hZ2VzOklhdHRyaWJ1dGVMaXN0XG4gICAgY29uc3RydWN0b3IoZmlsZXM6SXVwbG9hZGZpbGVMaXN0KSB7XG4gICAgICAgIGlmKGZpbGVzPT1udWxsKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgICAgICBmb3IobGV0IGZpbGVLZXkgaW4gZmlsZXMpe1xuICAgICAgICAgICAgLy8gbGV0IHJlZyA9IG5ldyBSZWdFeHAoXCJ4bC9tZWRpYS9pbWFnZTEucG5nXCIsIFwiZ1wiKTtcbiAgICAgICAgICAgIGlmKGZpbGVLZXkuaW5kZXhPZihcInhsL21lZGlhL1wiKT4tMSl7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lQXJyID0gZmlsZUtleS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGZpbGVOYW1lQXJyW2ZpbGVOYW1lQXJyLmxlbmd0aC0xXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmKHN1ZmZpeCBpbiB7XCJwbmdcIjoxLCBcImpwZWdcIjoxLCBcImpwZ1wiOjEsIFwiZ2lmXCI6MSxcImJtcFwiOjEsXCJ0aWZcIjoxLFwid2VicFwiOjEsXCJlbWZcIjoxfSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHN1ZmZpeD09XCJlbWZcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcE51bSAgPSAwOyAgLy8gbnVtYmVyIG9mIHRoZSBwYWdlLCB0aGF0IHlvdSB3YW50IHRvIHJlbmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gMTsgIC8vIHRoZSBzY2FsZSBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cnQgPSBuZXcgVG9Db250ZXh0MkQocE51bSwgc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucCwgb3V0LCBzdHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBGcm9tRU1GLksgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucCA9IEZyb21FTUYuQzsgICBvdXQgPSBGcm9tRU1GLks7ICAgc3R0PTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHAgaW4gaW5wKSBvdXRbaW5wW3BdXSA9IHAuc2xpY2Uoc3R0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEZyb21FTUYuUGFyc2UoZmlsZXNbZmlsZUtleV0sIHdydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlc1tmaWxlS2V5XSA9IHdydC5jYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlc1tmaWxlS2V5XSA9IGZpbGVzW2ZpbGVLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEltYWdlQnlOYW1lKHBhdGhOYW1lOnN0cmluZyk6SW1hZ2V7XG4gICAgICAgIGlmKHBhdGhOYW1lIGluIHRoaXMuaW1hZ2VzKXtcbiAgICAgICAgICAgIGxldCBiYXNlNjQgPSB0aGlzLmltYWdlc1twYXRoTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlKHBhdGhOYW1lLCBiYXNlNjQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuXG5jbGFzcyBJbWFnZSBleHRlbmRzIEx1Y2t5SW1hZ2VCYXNlIHtcblxuICAgIGZyb21Db2w6bnVtYmVyXG4gICAgZnJvbUNvbE9mZjpudW1iZXJcbiAgICBmcm9tUm93Om51bWJlclxuICAgIGZyb21Sb3dPZmY6bnVtYmVyXG5cbiAgICB0b0NvbDpudW1iZXJcbiAgICB0b0NvbE9mZjpudW1iZXJcbiAgICB0b1JvdzpudW1iZXJcbiAgICB0b1Jvd09mZjpudW1iZXJcblxuICAgIGNvbnN0cnVjdG9yKHBhdGhOYW1lOnN0cmluZywgYmFzZTY0OnN0cmluZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNyYyA9IGJhc2U2NDtcbiAgICB9XG5cbiAgICBzZXREZWZhdWx0KCl7XG5cbiAgICB9XG59Iiwi77u/aW1wb3J0IHsgSWx1Y2t5SW1hZ2VCb3JkZXIsSWx1Y2t5SW1hZ2VDcm9wLElsdWNreUltYWdlRGVmYXVsdCxJbHVja3lJbWFnZXMsSWx1Y2t5U2hlZXRDZWxsZGF0YSxJbHVja3lTaGVldENlbGxkYXRhVmFsdWUsSU1hcGx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWUsSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGUsSUZvcm11bGFTSSxJbHVja3lTaGVldFJvd0FuZENvbHVtbkxlbixJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlbixJbHVja3lTaGVldFNlbGVjdGlvbixJbHVja3lzaGVldEZyb3plbn0gZnJvbSBcIi4vSUx1Y2tcIjtcbmltcG9ydCB7THVja3lTaGVldENlbGxkYXRhfSBmcm9tIFwiLi9MdWNreUNlbGxcIjtcbmltcG9ydCB7IElhdHRyaWJ1dGVMaXN0IH0gZnJvbSBcIi4uL0lDb21tb25cIjtcbmltcG9ydCB7Z2V0WG1sQXR0aWJ1dGUsIGdldENvbHVtbldpZHRoUGl4ZWwsIGZyb211bGFSZWYsZ2V0Um93SGVpZ2h0UGl4ZWwsZ2V0Y2VsbHJhbmdlLGdlbmVyYXRlUmFuZG9tSW5kZXgsZ2V0UHhCeUVNVXN9IGZyb20gXCIuLi9jb21tb24vbWV0aG9kXCI7XG5pbXBvcnQge2JvcmRlclR5cGVzfSBmcm9tIFwiLi4vY29tbW9uL2NvbnN0YW50XCI7XG5pbXBvcnQgeyBSZWFkWG1sLCBJU3R5bGVDb2xsZWN0aW9ucywgRWxlbWVudCxnZXRDb2xvciB9IGZyb20gXCIuL1JlYWRYbWxcIjtcbmltcG9ydCB7IEx1Y2t5RmlsZUJhc2UsTHVja3lTaGVldEJhc2UsTHVja3lDb25maWcsTHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wLEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlLEx1Y2t5c2hlZXRDYWxjQ2hhaW4sTHVja3lTaGVldENvbmZpZ01lcmdlIH0gZnJvbSBcIi4vTHVja3lCYXNlXCI7XG5pbXBvcnQge0ltYWdlTGlzdH0gZnJvbSBcIi4vTHVja3lJbWFnZVwiO1xuXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldCBleHRlbmRzIEx1Y2t5U2hlZXRCYXNlIHtcblxuICAgIHByaXZhdGUgcmVhZFhtbDpSZWFkWG1sXG4gICAgcHJpdmF0ZSBzaGVldEZpbGU6c3RyaW5nXG4gICAgcHJpdmF0ZSBpc0luaXRpYWxDZWxsOmJvb2xlYW5cbiAgICBwcml2YXRlIHN0eWxlczpJU3R5bGVDb2xsZWN0aW9uc1xuICAgIHByaXZhdGUgc2hhcmVkU3RyaW5nczpFbGVtZW50W11cbiAgICBwcml2YXRlIG1lcmdlQ2VsbHM6RWxlbWVudFtdXG4gICAgcHJpdmF0ZSBjYWxjQ2hhaW5FbGVzOkVsZW1lbnRbXVxuICAgIHByaXZhdGUgc2hlZXRMaXN0OklhdHRyaWJ1dGVMaXN0XG5cbiAgICBwcml2YXRlIGltYWdlTGlzdDpJbWFnZUxpc3RcblxuICAgIHByaXZhdGUgZm9ybXVsYVJlZkxpc3Q6SUZvcm11bGFTSVxuXG4gICAgY29uc3RydWN0b3Ioc2hlZXROYW1lOnN0cmluZywgc2hlZXRJZDpzdHJpbmcsIHNoZWV0T3JkZXI6bnVtYmVyLGlzSW5pdGlhbENlbGw6Ym9vbGVhbj1mYWxzZSwgYWxsRmlsZU9wdGlvbjphbnkpe1xuICAgICAgICAvL1ByaXZhdGVcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxDZWxsID0gaXNJbml0aWFsQ2VsbDtcblxuICAgICAgICB0aGlzLnJlYWRYbWwgPSBhbGxGaWxlT3B0aW9uLnJlYWRYbWw7XG4gICAgICAgIHRoaXMuc2hlZXRGaWxlID0gYWxsRmlsZU9wdGlvbi5zaGVldEZpbGU7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gYWxsRmlsZU9wdGlvbi5zdHlsZXM7XG4gICAgICAgIHRoaXMuc2hhcmVkU3RyaW5ncyA9IGFsbEZpbGVPcHRpb24uc2hhcmVkU3RyaW5ncztcbiAgICAgICAgdGhpcy5jYWxjQ2hhaW5FbGVzID0gYWxsRmlsZU9wdGlvbi5jYWxjQ2hhaW47XG4gICAgICAgIHRoaXMuc2hlZXRMaXN0ID0gYWxsRmlsZU9wdGlvbi5zaGVldExpc3Q7XG4gICAgICAgIHRoaXMuaW1hZ2VMaXN0ID0gYWxsRmlsZU9wdGlvbi5pbWFnZUxpc3Q7ICBcblxuICAgICAgICAvL091dHB1dFxuICAgICAgICB0aGlzLm5hbWUgPSBzaGVldE5hbWU7XG4gICAgICAgIHRoaXMuaW5kZXggPSBzaGVldElkO1xuICAgICAgICB0aGlzLm9yZGVyID0gc2hlZXRPcmRlci50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IG5ldyBMdWNreUNvbmZpZygpO1xuICAgICAgICB0aGlzLmNlbGxkYXRhID0gW107XG4gICAgICAgIHRoaXMubWVyZ2VDZWxscyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm1lcmdlQ2VsbHMvbWVyZ2VDZWxsXCIsIHRoaXMuc2hlZXRGaWxlKTtcbiAgICAgICAgbGV0IGNsclNjaGVtZSA9IHRoaXMuc3R5bGVzW1wiY2xyU2NoZW1lXCJdIGFzIEVsZW1lbnRbXTtcbiAgICAgICAgbGV0IHNoZWV0VmlldyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNoZWV0Vmlld3Mvc2hlZXRWaWV3XCIsIHRoaXMuc2hlZXRGaWxlKTtcbiAgICAgICAgbGV0IHNob3dHcmlkTGluZXMgPSBcIjFcIiwgdGFiU2VsZWN0ZWQ9XCIwXCIsIHpvb21TY2FsZSA9IFwiMTAwXCIsIGFjdGl2ZUNlbGwgPSBcIkExXCI7XG4gICAgICAgIGlmKHNoZWV0Vmlldy5sZW5ndGg+MCl7XG4gICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBzaGVldFZpZXdbMF0uYXR0cmlidXRlTGlzdDtcbiAgICAgICAgICAgIHNob3dHcmlkTGluZXMgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJzaG93R3JpZExpbmVzXCIsIFwiMVwiKTtcbiAgICAgICAgICAgIHRhYlNlbGVjdGVkID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwidGFiU2VsZWN0ZWRcIiwgXCIwXCIpO1xuICAgICAgICAgICAgem9vbVNjYWxlID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiem9vbVNjYWxlXCIsIFwiMTAwXCIpO1xuICAgICAgICAgICAgLy8gbGV0IGNvbG9ySWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJjb2xvcklkXCIsIFwiMFwiKTtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb25zID0gc2hlZXRWaWV3WzBdLmdldElubmVyRWxlbWVudHMoXCJzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICBpZihzZWxlY3Rpb25zIT1udWxsICYmIHNlbGVjdGlvbnMubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgIGFjdGl2ZUNlbGwgPSBnZXRYbWxBdHRpYnV0ZShzZWxlY3Rpb25zWzBdLmF0dHJpYnV0ZUxpc3QsIFwiYWN0aXZlQ2VsbFwiLCBcIkExXCIpO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZTpJbHVja3lTaGVldFNlbGVjdGlvbiA9IGdldGNlbGxyYW5nZShhY3RpdmVDZWxsLCB0aGlzLnNoZWV0TGlzdCwgc2hlZXRJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sdWNreXNoZWV0X3NlbGVjdF9zYXZlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5sdWNreXNoZWV0X3NlbGVjdF9zYXZlLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvd0dyaWRMaW5lcyA9IHNob3dHcmlkTGluZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gdGFiU2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuem9vbVJhdGlvID0gcGFyc2VJbnQoem9vbVNjYWxlKS8xMDA7XG5cbiAgICAgICAgbGV0IHRhYkNvbG9ycyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNoZWV0UHIvdGFiQ29sb3JcIiwgdGhpcy5zaGVldEZpbGUpO1xuICAgICAgICBpZih0YWJDb2xvcnMhPW51bGwgJiYgdGFiQ29sb3JzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgIGxldCB0YWJDb2xvciA9IHRhYkNvbG9yc1swXSwgYXR0ckxpc3QgPSB0YWJDb2xvci5hdHRyaWJ1dGVMaXN0O1xuICAgICAgICAgICAgLy8gaWYoYXR0ckxpc3QucmdiIT1udWxsKXtcbiAgICAgICAgICAgICAgICBsZXQgdGMgPSBnZXRDb2xvcih0YWJDb2xvciwgdGhpcy5zdHlsZXMsIFwiYlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gdGM7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2hlZXRGb3JtYXRQciA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNoZWV0Rm9ybWF0UHJcIiwgdGhpcy5zaGVldEZpbGUpO1xuICAgICAgICBsZXQgZGVmYXVsdENvbFdpZHRoLCBkZWZhdWx0Um93SGVpZ2h0O1xuICAgICAgICBpZihzaGVldEZvcm1hdFByLmxlbmd0aD4wKXtcbiAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IHNoZWV0Rm9ybWF0UHJbMF0uYXR0cmlidXRlTGlzdDtcbiAgICAgICAgICAgIGRlZmF1bHRDb2xXaWR0aCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImRlZmF1bHRDb2xXaWR0aFwiLCBcIjkuMjFcIik7XG4gICAgICAgICAgICBkZWZhdWx0Um93SGVpZ2h0ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiZGVmYXVsdFJvd0hlaWdodFwiLCBcIjE5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0Q29sV2lkdGggPSBnZXRDb2x1bW5XaWR0aFBpeGVsKHBhcnNlRmxvYXQoZGVmYXVsdENvbFdpZHRoKSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFJvd0hlaWdodCA9IGdldFJvd0hlaWdodFBpeGVsKHBhcnNlRmxvYXQoZGVmYXVsdFJvd0hlaWdodCkpO1xuXG5cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNvbmZpZ0NvbHVtbkxlbkFuZEhpZGRlbigpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ29uZmlnUm93TGVuQW5kSGlkZGVuQWRkQ2VsbCgpO1xuXG4gICAgICAgIGlmKHRoaXMuZm9ybXVsYVJlZkxpc3QhPW51bGwpe1xuICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gdGhpcy5mb3JtdWxhUmVmTGlzdCl7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bmNsaXN0ID0gdGhpcy5mb3JtdWxhUmVmTGlzdFtrZXldO1xuICAgICAgICAgICAgICAgIGxldCBtYWluRnVuYyA9IGZ1bmNsaXN0W1wibWFpblJlZlwiXSwgbWFpbkNlbGxWYWx1ZSA9IG1haW5GdW5jLmNlbGxWYWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgZm9ybXVsYVR4dCA9IG1haW5GdW5jLmZ2O1xuICAgICAgICAgICAgICAgIGxldCBtYWluUiA9IG1haW5DZWxsVmFsdWUuciwgbWFpbkMgPSBtYWluQ2VsbFZhbHVlLmM7XG4gICAgICAgICAgICAgICAgLy8gbGV0IHJlZlJhbmdlID0gZ2V0Y2VsbHJhbmdlKHJlZik7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBuYW1lIGluIGZ1bmNsaXN0KXtcbiAgICAgICAgICAgICAgICAgICAgaWYobmFtZSA9PSBcIm1haW5SZWZcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBmdW5jVmFsdWUgPSBmdW5jbGlzdFtuYW1lXSwgY2VsbFZhbHVlID0gZnVuY1ZhbHVlLmNlbGxWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlPT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByID0gY2VsbFZhbHVlLnIsIGMgPSBjZWxsVmFsdWUuYztcblxuICAgICAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IGZvcm11bGFUeHQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXRSb3cgPSByIC0gbWFpblIsIG9mZnNldENvbCA9IGMgLSBtYWluQztcblxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYob2Zmc2V0Um93ID4gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jID0gXCI9XCIgKyBmcm9tdWxhUmVmLmZ1bmN0aW9uQ29weShmdW5jLCBcImRvd25cIiwgb2Zmc2V0Um93KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKG9mZnNldFJvdyA8IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYyA9IFwiPVwiICsgZnJvbXVsYVJlZi5mdW5jdGlvbkNvcHkoZnVuYywgXCJ1cFwiLCBNYXRoLmFicyhvZmZzZXRSb3cpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKG9mZnNldENvbCA+IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYyA9IFwiPVwiICsgZnJvbXVsYVJlZi5mdW5jdGlvbkNvcHkoZnVuYywgXCJyaWdodFwiLCBvZmZzZXRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYob2Zmc2V0Q29sIDwgMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jID0gXCI9XCIgKyBmcm9tdWxhUmVmLmZ1bmN0aW9uQ29weShmdW5jLCBcImxlZnRcIiwgTWF0aC5hYnMob2Zmc2V0Q29sKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhvZmZzZXRSb3csIG9mZnNldENvbCwgZnVuYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgKGNlbGxWYWx1ZS52IGFzIElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSApLmYgPSBmdW5jO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmKHRoaXMuY2FsY0NoYWluPT1udWxsKXtcbiAgICAgICAgICAgIHRoaXMuY2FsY0NoYWluID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBjPTA7Yzx0aGlzLmNhbGNDaGFpbkVsZXMubGVuZ3RoO2MrKyl7XG4gICAgICAgICAgICBsZXQgY2FsY0NoYWluRWxlID0gdGhpcy5jYWxjQ2hhaW5FbGVzW2NdLCBhdHRyTGlzdCA9IGNhbGNDaGFpbkVsZS5hdHRyaWJ1dGVMaXN0O1xuICAgICAgICAgICAgaWYoYXR0ckxpc3QuaSE9c2hlZXRJZCl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByID0gYXR0ckxpc3QuciAsIGkgPSBhdHRyTGlzdC5pLCBsID0gYXR0ckxpc3QubCwgcyA9IGF0dHJMaXN0LnMsIGEgPSBhdHRyTGlzdC5hLCB0ID0gYXR0ckxpc3QudDtcblxuICAgICAgICAgICAgbGV0IHJhbmdlID0gZ2V0Y2VsbHJhbmdlKHIpO1xuICAgICAgICAgICAgbGV0IGNoYWluID0gbmV3IEx1Y2t5c2hlZXRDYWxjQ2hhaW4oKTtcbiAgICAgICAgICAgIGNoYWluLnIgPSByYW5nZS5yb3dbMF07XG4gICAgICAgICAgICBjaGFpbi5jID0gcmFuZ2UuY29sdW1uWzBdO1xuICAgICAgICAgICAgY2hhaW4uaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5jYWxjQ2hhaW4ucHVzaChjaGFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLm1lcmdlQ2VsbHMhPW51bGwpe1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLm1lcmdlQ2VsbHMubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICAgICAgbGV0IG1lcmdlID0gdGhpcy5tZXJnZUNlbGxzW2ldLCBhdHRyTGlzdCA9IG1lcmdlLmF0dHJpYnV0ZUxpc3Q7XG4gICAgICAgICAgICAgICAgbGV0IHJlZiA9IGF0dHJMaXN0LnJlZjtcbiAgICAgICAgICAgICAgICBpZihyZWY9PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZ2V0Y2VsbHJhbmdlKHJlZiwgdGhpcy5zaGVldExpc3QsIHNoZWV0SWQpO1xuICAgICAgICAgICAgICAgIGxldCBtZXJnZVZhbHVlID0gbmV3IEx1Y2t5U2hlZXRDb25maWdNZXJnZSgpO1xuICAgICAgICAgICAgICAgIG1lcmdlVmFsdWUuciA9IHJhbmdlLnJvd1swXTtcbiAgICAgICAgICAgICAgICBtZXJnZVZhbHVlLmMgPSByYW5nZS5jb2x1bW5bMF07XG4gICAgICAgICAgICAgICAgbWVyZ2VWYWx1ZS5ycyA9IHJhbmdlLnJvd1sxXS1yYW5nZS5yb3dbMF0rMTtcbiAgICAgICAgICAgICAgICBtZXJnZVZhbHVlLmNzID0gcmFuZ2UuY29sdW1uWzFdLXJhbmdlLmNvbHVtblswXSsxO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLm1lcmdlPT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcubWVyZ2UgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubWVyZ2VbcmFuZ2Uucm93WzBdICsgXCJfXCIgKyByYW5nZS5jb2x1bW5bMF1dID0gbWVyZ2VWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkcmF3aW5nRmlsZSA9IGFsbEZpbGVPcHRpb24uZHJhd2luZ0ZpbGUsIGRyYXdpbmdSZWxzRmlsZSA9IGFsbEZpbGVPcHRpb24uZHJhd2luZ1JlbHNGaWxlO1xuICAgICAgICBpZihkcmF3aW5nRmlsZSE9bnVsbCAmJiBkcmF3aW5nUmVsc0ZpbGUhPW51bGwpe1xuICAgICAgICAgICAgbGV0IHR3b0NlbGxBbmNob3JzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwieGRyOnR3b0NlbGxBbmNob3JcIiwgZHJhd2luZ0ZpbGUpO1xuXG4gICAgICAgICAgICBpZih0d29DZWxsQW5jaG9ycyE9bnVsbCAmJiB0d29DZWxsQW5jaG9ycy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0d29DZWxsQW5jaG9ycy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR3b0NlbGxBbmNob3IgPSB0d29DZWxsQW5jaG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVkaXRBcyA9IGdldFhtbEF0dGlidXRlKHR3b0NlbGxBbmNob3IuYXR0cmlidXRlTGlzdCwgXCJlZGl0QXNcIiwgXCJ0d29DZWxsXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB4ZHJGcm9tcyA9IHR3b0NlbGxBbmNob3IuZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpmcm9tXCIpLCB4ZHJUb3MgPSB0d29DZWxsQW5jaG9yLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6dG9cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHhkcl9ibGlwZmlsbHMgPSB0d29DZWxsQW5jaG9yLmdldElubmVyRWxlbWVudHMoXCJhOmJsaXBcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmKHhkckZyb21zIT1udWxsICYmIHhkcl9ibGlwZmlsbHMhPW51bGwgJiYgeGRyRnJvbXMubGVuZ3RoPjAgJiYgeGRyX2JsaXBmaWxscy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeGRyRnJvbSA9IHhkckZyb21zWzBdLCB4ZHJUbyA9IHhkclRvc1swXSx4ZHJfYmxpcGZpbGwgPSB4ZHJfYmxpcGZpbGxzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVtYmVkID0gZ2V0WG1sQXR0aWJ1dGUoeGRyX2JsaXBmaWxsLmF0dHJpYnV0ZUxpc3QsIFwicjplbWJlZFwiLCBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlT2JqZWN0ID0gdGhpcy5nZXRCYXNlNjRCeVJpZChyZW1iZWQsIGRyYXdpbmdSZWxzRmlsZSk7XG5cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgYW9mZiA9IHhkcl94ZnJtLmdldElubmVyRWxlbWVudHMoXCJhOm9mZlwiKSwgYWV4dCA9IHhkcl94ZnJtLmdldElubmVyRWxlbWVudHMoXCJhOmV4dFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmKGFvZmYhPW51bGwgJiYgYWV4dCE9bnVsbCAmJiBhb2ZmLmxlbmd0aD4wICYmIGFleHQubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCBhb2ZmQXR0cmlidXRlID0gYW9mZlswXS5hdHRyaWJ1dGVMaXN0LCBhZXh0QXR0cmlidXRlID0gYWV4dFswXS5hdHRyaWJ1dGVMaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCB4ID0gZ2V0WG1sQXR0aWJ1dGUoYW9mZkF0dHJpYnV0ZSwgXCJ4XCIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCB5ID0gZ2V0WG1sQXR0aWJ1dGUoYW9mZkF0dHJpYnV0ZSwgXCJ5XCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgbGV0IGN4ID0gZ2V0WG1sQXR0aWJ1dGUoYWV4dEF0dHJpYnV0ZSwgXCJjeFwiLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgY3kgPSBnZXRYbWxBdHRpYnV0ZShhZXh0QXR0cmlidXRlLCBcImN5XCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgaWYoeCE9bnVsbCAmJiB5IT1udWxsICYmIGN4IT1udWxsICYmIGN5IT1udWxsICYmIGltYWdlT2JqZWN0ICE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgeF9uID0gZ2V0UHhCeUVNVXMocGFyc2VJbnQoeCksIFwiY1wiKSx5X24gPSBnZXRQeEJ5RU1VcyhwYXJzZUludCh5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgY3hfbiA9IGdldFB4QnlFTVVzKHBhcnNlSW50KGN4KSwgXCJjXCIpLGN5X24gPSBnZXRQeEJ5RU1VcyhwYXJzZUludChjeSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeF9uID0wLHlfbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3hfbiA9IDAsIGN5X24gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5mcm9tQ29sID0gdGhpcy5nZXRYZHJWYWx1ZSh4ZHJGcm9tLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6Y29sXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmZyb21Db2xPZmYgPSBnZXRQeEJ5RU1Vcyh0aGlzLmdldFhkclZhbHVlKHhkckZyb20uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpjb2xPZmZcIikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmZyb21Sb3c9IHRoaXMuZ2V0WGRyVmFsdWUoeGRyRnJvbS5nZXRJbm5lckVsZW1lbnRzKFwieGRyOnJvd1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5mcm9tUm93T2ZmID0gZ2V0UHhCeUVNVXModGhpcy5nZXRYZHJWYWx1ZSh4ZHJGcm9tLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6cm93T2ZmXCIpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LnRvQ29sID0gdGhpcy5nZXRYZHJWYWx1ZSh4ZHJUby5nZXRJbm5lckVsZW1lbnRzKFwieGRyOmNvbFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50b0NvbE9mZiA9IGdldFB4QnlFTVVzKHRoaXMuZ2V0WGRyVmFsdWUoeGRyVG8uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpjb2xPZmZcIikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LnRvUm93ID0gdGhpcy5nZXRYZHJWYWx1ZSh4ZHJUby5nZXRJbm5lckVsZW1lbnRzKFwieGRyOnJvd1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50b1Jvd09mZiA9IGdldFB4QnlFTVVzKHRoaXMuZ2V0WGRyVmFsdWUoeGRyVG8uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpyb3dPZmZcIikpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3Qub3JpZ2luV2lkdGggPSBjeF9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3Qub3JpZ2luSGVpZ2h0ID0gY3lfbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWRpdEFzPT1cImFic29sdXRlXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LnR5cGUgPSBcIjNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZWRpdEFzPT1cIm9uZUNlbGxcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudHlwZSA9IFwiMlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50eXBlID0gXCIxXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmlzRml4ZWRQb3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmZpeGVkTGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5maXhlZFRvcCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUJvcmRlcjpJbHVja3lJbWFnZUJvcmRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmJvcmRlciA9IGltYWdlQm9yZGVyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VDcm9wOklsdWNreUltYWdlQ3JvcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGN5X24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGN4X25cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmNyb3AgPSBpbWFnZUNyb3A7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZURlZmF1bHQ6SWx1Y2t5SW1hZ2VEZWZhdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY3lfbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4X24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB5X24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGN4X25cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmRlZmF1bHQgPSBpbWFnZURlZmF1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaW1hZ2VzPT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZXNbZ2VuZXJhdGVSYW5kb21JbmRleChcImltYWdlXCIpXSA9IGltYWdlT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9IFxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0WGRyVmFsdWUoZWxlOkVsZW1lbnRbXSk6bnVtYmVye1xuICAgICAgICBpZihlbGU9PW51bGwgfHwgZWxlLmxlbmd0aD09MCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUludChlbGVbMF0udmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0QmFzZTY0QnlSaWQocmlkOnN0cmluZywgZHJhd2luZ1JlbHNGaWxlOnN0cmluZyl7XG4gICAgICAgIGxldCBSZWxhdGlvbnNoaXBzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiUmVsYXRpb25zaGlwcy9SZWxhdGlvbnNoaXBcIiwgZHJhd2luZ1JlbHNGaWxlKTtcblxuICAgICAgICBpZihSZWxhdGlvbnNoaXBzIT1udWxsICYmIFJlbGF0aW9uc2hpcHMubGVuZ3RoPjApe1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTxSZWxhdGlvbnNoaXBzLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgICAgIGxldCBSZWxhdGlvbnNoaXAgPSBSZWxhdGlvbnNoaXBzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IFJlbGF0aW9uc2hpcC5hdHRyaWJ1dGVMaXN0O1xuICAgICAgICAgICAgICAgIGxldCBJZCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIklkXCIsIG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBzcmMgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJUYXJnZXRcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYoSWQgPT0gcmlkKXtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcLlxcLlxcLy9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gXCJ4bC9cIiArIHNyYztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGltZ2FnZSA9IHRoaXMuaW1hZ2VMaXN0LmdldEltYWdlQnlOYW1lKHNyYyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbWdhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAZGVzYyBUaGlzIHdpbGwgY29udmVydCBjb2xzL2NvbCB0byBsdWNreXNoZWV0IGNvbmZpZyBvZiBjb2x1bW4nd2lkdGhcbiAgICAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVDb25maWdDb2x1bW5MZW5BbmRIaWRkZW4oKXtcbiAgICAgICAgbGV0IGNvbHMgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb2xzL2NvbFwiLCB0aGlzLnNoZWV0RmlsZSk7XG4gICAgICAgIGZvcihsZXQgaT0wO2k8Y29scy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgIGxldCBjb2wgPSBjb2xzW2ldLCBhdHRyTGlzdCA9IGNvbC5hdHRyaWJ1dGVMaXN0O1xuICAgICAgICAgICAgbGV0IG1pbiA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIm1pblwiLCBudWxsKTtcbiAgICAgICAgICAgIGxldCBtYXggPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJtYXhcIiwgbnVsbCk7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJ3aWR0aFwiLCBudWxsKTtcbiAgICAgICAgICAgIGxldCBoaWRkZW4gPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJoaWRkZW5cIiwgbnVsbCk7XG4gICAgICAgICAgICBsZXQgY3VzdG9tV2lkdGggPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJjdXN0b21XaWR0aFwiLCBudWxsKTtcblxuXG4gICAgICAgICAgICBpZihtaW49PW51bGwgfHwgbWF4PT1udWxsKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG1pbk51bSA9IHBhcnNlSW50KG1pbiktMSwgbWF4TnVtPXBhcnNlSW50KG1heCktMSwgd2lkdGhOdW09cGFyc2VGbG9hdCh3aWR0aCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihsZXQgbT1taW5OdW07bTw9bWF4TnVtO20rKyl7XG4gICAgICAgICAgICAgICAgaWYod2lkdGghPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5jb2x1bW5sZW49PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY29sdW1ubGVuID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY29sdW1ubGVuW21dID0gZ2V0Q29sdW1uV2lkdGhQaXhlbCh3aWR0aE51bSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoaGlkZGVuPT1cIjFcIil7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLmNvbGhpZGRlbj09bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jb2xoaWRkZW4gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jb2xoaWRkZW5bbV0gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLmNvbHVtbmxlbil7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jb25maWcuY29sdW1ubGVuW21dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGN1c3RvbVdpZHRoIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcuY3VzdG9tV2lkdGg9PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY3VzdG9tV2lkdGggPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jdXN0b21XaWR0aFttXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGRlc2MgVGhpcyB3aWxsIGNvbnZlcnQgY29scy9jb2wgdG8gbHVja3lzaGVldCBjb25maWcgb2YgY29sdW1uJ3dpZHRoXG4gICAgKi9cbiAgIHByaXZhdGUgZ2VuZXJhdGVDb25maWdSb3dMZW5BbmRIaWRkZW5BZGRDZWxsKCl7XG4gICAgICAgIGxldCByb3dzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2hlZXREYXRhL3Jvd1wiLCB0aGlzLnNoZWV0RmlsZSk7XG4gICAgICAgIGZvcihsZXQgaT0wO2k8cm93cy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgIGxldCByb3cgPSByb3dzW2ldLCBhdHRyTGlzdCA9IHJvdy5hdHRyaWJ1dGVMaXN0O1xuICAgICAgICAgICAgbGV0IHJvd05vID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiclwiLCBudWxsKTtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJodFwiLCBudWxsKTtcbiAgICAgICAgICAgIGxldCBoaWRkZW4gPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJoaWRkZW5cIiwgbnVsbCk7XG4gICAgICAgICAgICBsZXQgY3VzdG9tSGVpZ2h0ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiY3VzdG9tSGVpZ2h0XCIsIG51bGwpO1xuXG4gICAgICAgICAgICBpZihyb3dObz09bnVsbCl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByb3dOb051bSA9IHBhcnNlSW50KHJvd05vKSAtIDE7XG4gICAgICAgICAgICBpZihoZWlnaHQhPW51bGwpe1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHROdW0gPSBwYXJzZUZsb2F0KGhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcucm93bGVuPT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcucm93bGVuID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnJvd2xlbltyb3dOb051bV0gPSBnZXRSb3dIZWlnaHRQaXhlbChoZWlnaHROdW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihoaWRkZW49PVwiMVwiKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5yb3doaWRkZW49PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5yb3doaWRkZW4gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcucm93aGlkZGVuW3Jvd05vTnVtXSA9IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcucm93bGVuKXtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uZmlnLnJvd2xlbltyb3dOb051bV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihjdXN0b21IZWlnaHQhPW51bGwpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLmN1c3RvbUhlaWdodD09bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmN1c3RvbUhlaWdodCA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jdXN0b21IZWlnaHRbcm93Tm9OdW1dID0gMTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZih0aGlzLmlzSW5pdGlhbENlbGwpe1xuICAgICAgICAgICAgICAgIGxldCBjZWxscyA9IHJvdy5nZXRJbm5lckVsZW1lbnRzKFwiY1wiKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGtleSBpbiBjZWxscyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsID0gY2VsbHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGxWYWx1ZSA9IG5ldyBMdWNreVNoZWV0Q2VsbGRhdGEoY2VsbCwgdGhpcy5zdHlsZXMsIHRoaXMuc2hhcmVkU3RyaW5ncywgdGhpcy5tZXJnZUNlbGxzLHRoaXMuc2hlZXRGaWxlLCB0aGlzLnJlYWRYbWwpO1xuICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuX2JvcmRlck9iamVjdCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5ib3JkZXJJbmZvPT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5ib3JkZXJJbmZvID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5ib3JkZXJJbmZvLnB1c2goY2VsbFZhbHVlLl9ib3JkZXJPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNlbGxWYWx1ZS5fYm9yZGVyT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgYm9yZGVySWQgPSBjZWxsVmFsdWUuX2JvcmRlcklkO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZihib3JkZXJJZCE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgYm9yZGVycyA9IHRoaXMuc3R5bGVzW1wiYm9yZGVyc1wiXSBhcyBFbGVtZW50W107XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBpZih0aGlzLmNvbmZpZy5fYm9yZGVySW5mbz09bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgdGhpcy5jb25maWcuX2JvcmRlckluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmKCBib3JkZXJJZCBpbiB0aGlzLmNvbmZpZy5fYm9yZGVySW5mbyl7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgdGhpcy5jb25maWcuX2JvcmRlckluZm9bYm9yZGVySWRdLmNlbGxzLnB1c2goY2VsbFZhbHVlLnIgKyBcIl9cIiArIGNlbGxWYWx1ZS5jKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGJvcmRlciA9IGJvcmRlcnNbYm9yZGVySWRdO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBib3JkZXJPYmplY3QgPSBuZXcgTHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgYm9yZGVyT2JqZWN0LnJhbmdlVHlwZSA9IFwiY2VsbEdyb3VwXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgYm9yZGVyT2JqZWN0LmNlbGxzID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGJvcmRlckNlbGxWYWx1ZSA9IG5ldyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBsZWZ0cyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwibGVmdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgcmlnaHRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJyaWdodFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgdG9wcyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwidG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBib3R0b21zID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJib3R0b21cIik7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGRpYWdvbmFscyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwiZGlhZ29uYWxcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgbGVmdCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhsZWZ0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5nZXRCb3JkZXJJbmZvKHJpZ2h0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IHRvcCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyh0b3BzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5nZXRCb3JkZXJJbmZvKGJvdHRvbXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBkaWFnb25hbCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhkaWFnb25hbHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGlzQWRkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYobGVmdCE9bnVsbCAmJiBsZWZ0LmNvbG9yIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLmwgPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYocmlnaHQhPW51bGwgJiYgcmlnaHQuY29sb3IhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUuciA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYodG9wIT1udWxsICYmIHRvcC5jb2xvciE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS50ID0gdG9wO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYoYm90dG9tIT1udWxsICYmIGJvdHRvbS5jb2xvciE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS5iID0gYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYoaXNBZGQpe1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJPYmplY3QudmFsdWUgPSBib3JkZXJDZWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvW2JvcmRlcklkXSA9IGJvcmRlck9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuX2Zvcm11bGFUeXBlPT1cInNoYXJlZFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZm9ybXVsYVJlZkxpc3Q9PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybXVsYVJlZkxpc3QgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5mb3JtdWxhUmVmTGlzdFtjZWxsVmFsdWUuX2Zvcm11bGFTaV09PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybXVsYVJlZkxpc3RbY2VsbFZhbHVlLl9mb3JtdWxhU2ldID0ge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZ2O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLnYhPW51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ2ID0gKGNlbGxWYWx1ZS52IGFzIElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSkuZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlZlZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ6Y2VsbFZhbHVlLl9mb3JtdWxhVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6Y2VsbFZhbHVlLl9mb211bGFSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2k6Y2VsbFZhbHVlLl9mb3JtdWxhU2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnY6ZnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlOmNlbGxWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuX2ZvbXVsYVJlZiE9bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtdWxhUmVmTGlzdFtjZWxsVmFsdWUuX2Zvcm11bGFTaV1bXCJtYWluUmVmXCJdID0gcmVmVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybXVsYVJlZkxpc3RbY2VsbFZhbHVlLl9mb3JtdWxhU2ldW2NlbGxWYWx1ZS5yK1wiX1wiK2NlbGxWYWx1ZS5jXSA9IHJlZlZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZWZWYWx1ZSwgdGhpcy5mb3JtdWxhUmVmTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxkYXRhLnB1c2goY2VsbFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcml2YXRlIGdldEJvcmRlckluZm8oYm9yZGVyczpFbGVtZW50W10pOkx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGV7XG4gICAgLy8gICAgIGlmKGJvcmRlcnM9PW51bGwpe1xuICAgIC8vICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBsZXQgYm9yZGVyID0gYm9yZGVyc1swXSwgYXR0ckxpc3QgPSBib3JkZXIuYXR0cmlidXRlTGlzdDtcbiAgICAvLyAgICAgbGV0IGNsclNjaGVtZSA9IHRoaXMuc3R5bGVzW1wiY2xyU2NoZW1lXCJdIGFzIEVsZW1lbnRbXTtcbiAgICAvLyAgICAgbGV0IHN0eWxlOnN0cmluZyA9IGF0dHJMaXN0LnN0eWxlO1xuICAgIC8vICAgICBpZihzdHlsZT09bnVsbCB8fCBzdHlsZT09XCJub25lXCIpe1xuICAgIC8vICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBsZXQgY29sb3JzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJjb2xvclwiKTtcbiAgICAvLyAgICAgbGV0IGNvbG9yUmV0ID0gXCIjMDAwMDAwXCI7XG4gICAgLy8gICAgIGlmKGNvbG9ycyE9bnVsbCl7XG4gICAgLy8gICAgICAgICBsZXQgY29sb3IgPSBjb2xvcnNbMF07XG4gICAgLy8gICAgICAgICBjb2xvclJldCA9IGdldENvbG9yKGNvbG9yLCBjbHJTY2hlbWUpO1xuICAgIC8vICAgICB9XG5cbiAgICAvLyAgICAgbGV0IHJldCA9IG5ldyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlKCk7XG4gICAgLy8gICAgIHJldC5zdHlsZSA9IGJvcmRlclR5cGVzW3N0eWxlXTtcbiAgICAvLyAgICAgcmV0LmNvbG9yID0gY29sb3JSZXQ7XG5cbiAgICAvLyAgICAgcmV0dXJuIHJldDtcbiAgICAvLyB9XG59XG4iLCJpbXBvcnQge0l1cGxvYWRmaWxlTGlzdCwgSWF0dHJpYnV0ZUxpc3QsIHN0cmluZ1RvTnVtfSBmcm9tIFwiLi4vSUNvbW1vblwiO1xuaW1wb3J0IHtpbmRleGVkQ29sb3JzfSAgZnJvbSBcIi4uL2NvbW1vbi9jb25zdGFudFwiO1xuaW1wb3J0IHtMaWdodGVuRGFya2VuQ29sb3J9ICBmcm9tIFwiLi4vY29tbW9uL21ldGhvZFwiO1xuXG5cbmNsYXNzIHhtbG9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgKiBAcGFyYW0gdGFnIFNlYXJjaCB4bWwgdGFnIG5hbWUgLCBkaXYsdGl0bGUgZXRjLlxuICAgICogQHBhcmFtIGZpbGUgWG1sIHN0cmluZ1xuICAgICogQHJldHVybiBYbWwgZWxlbWVudCBzdHJpbmcgXG4gICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RWxlbWVudHNCeU9uZVRhZyh0YWc6c3RyaW5nLCBmaWxlOnN0cmluZyk6c3RyaW5nW117XG4gICAgICAgIC8vPGE6W14vPjogXSs/Pi4qPzwvYTpbXi8+OiBdKz8+XG4gICAgICAgIGxldCByZWFkVGFnUmVnO1xuICAgICAgICBpZih0YWcuaW5kZXhPZihcInxcIik+LTEpe1xuICAgICAgICAgICAgbGV0IHRhZ3MgPSB0YWcuc3BsaXQoXCJ8XCIpLCB0YWdzUmVnVHh0PVwiXCI7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRhZ3MubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICAgICAgbGV0IHQgPSB0YWdzW2ldO1xuICAgICAgICAgICAgICAgIHRhZ3NSZWdUeHQgKz0gXCJ8PFwiKyB0ICtcIiBbXj5dKz9bXi9dPltcXFxcc1xcXFxTXSo/PC9cIisgdCArXCI+fDxcIisgdCArXCIgW14+XSs/Lz58PFwiKyB0ICtcIj5bXFxcXHNcXFxcU10qPzwvXCIrIHQgK1wiPnw8XCIrIHQgK1wiLz5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhZ3NSZWdUeHQgPSB0YWdzUmVnVHh0LnN1YnN0cigxLCB0YWdzUmVnVHh0Lmxlbmd0aCk7XG4gICAgICAgICAgICByZWFkVGFnUmVnID0gbmV3IFJlZ0V4cCh0YWdzUmVnVHh0LCBcImdcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHJlYWRUYWdSZWcgPSBuZXcgUmVnRXhwKFwiPFwiKyB0YWcgK1wiIFtePl0rP1teL10+W1xcXFxzXFxcXFNdKj88L1wiKyB0YWcgK1wiPnw8XCIrIHRhZyArXCIgW14+XSs/Lz58PFwiKyB0YWcgK1wiPltcXFxcc1xcXFxTXSo/PC9cIisgdGFnICtcIj58PFwiKyB0YWcgK1wiLz5cIiwgXCJnXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgcmV0ID0gZmlsZS5tYXRjaChyZWFkVGFnUmVnKTtcbiAgICAgICAgaWYocmV0PT1udWxsKXtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlYWRYbWwgZXh0ZW5kcyB4bWxvcGVyYXRpb257XG4gICAgb3JpZ2luRmlsZTpJdXBsb2FkZmlsZUxpc3RcbiAgICBjb25zdHJ1Y3RvcihmaWxlczpJdXBsb2FkZmlsZUxpc3Qpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9yaWdpbkZpbGUgPSBmaWxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0gcGF0aCBTZWFyY2ggeG1sIHRhZyBncm91cCAsIGRpdix0aXRsZSBldGMuXG4gICAgKiBAcGFyYW0gZmlsZU5hbWUgT25lIG9mIHVwbG9hZGZpbGVMaXN0LCB1cGxvYWRmaWxlTGlzdCBpcyBmaWxlIGdyb3VwLCB7a2V5OnZhbHVlfVxuICAgICogQHJldHVybiBYbWwgZWxlbWVudCBjYWxzc1xuICAgICovXG4gICAgZ2V0RWxlbWVudHNCeVRhZ05hbWUocGF0aDpzdHJpbmcsIGZpbGVOYW1lOnN0cmluZyk6IEVsZW1lbnRbXXtcbiAgICAgICAgXG4gICAgICAgIGxldCBmaWxlID0gdGhpcy5nZXRGaWxlQnlOYW1lKGZpbGVOYW1lKTtcbiAgICAgICAgbGV0IHBhdGhBcnIgPSBwYXRoLnNwbGl0KFwiL1wiKSwgcmV0OnN0cmluZ1tdIHwgc3RyaW5nO1xuICAgICAgICBmb3IobGV0IGtleSBpbiBwYXRoQXJyKXtcbiAgICAgICAgICAgIGxldCBwYXRoID0gcGF0aEFycltrZXldO1xuICAgICAgICAgICAgaWYocmV0PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuZ2V0RWxlbWVudHNCeU9uZVRhZyhwYXRoLGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBpZihyZXQgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtczpzdHJpbmdbXT1bXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gcmV0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gcmV0W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdCh0aGlzLmdldEVsZW1lbnRzQnlPbmVUYWcocGF0aCxpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gaXRlbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuZ2V0RWxlbWVudHNCeU9uZVRhZyhwYXRoLHJldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVsZW1lbnRzOkVsZW1lbnRbXSA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgaT0wO2k8cmV0Lmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgbGV0IGVsZSA9IG5ldyBFbGVtZW50KHJldFtpXSk7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0gbmFtZSBPbmUgb2YgdXBsb2FkZmlsZUxpc3QncyBuYW1lLCBzZWFyY2ggZm9yIGZpbGUgYnkgdGhpcyBwYXJhbWV0ZXJcbiAgICAqIEByZXRydW4gU2VsZWN0IGEgZmlsZSBmcm9tIHVwbG9hZGZpbGVMaXN0XG4gICAgKi9cbiAgICBwcml2YXRlIGdldEZpbGVCeU5hbWUobmFtZTpzdHJpbmcpOnN0cmluZ3tcbiAgICAgICAgZm9yKGxldCBmaWxlS2V5IGluIHRoaXMub3JpZ2luRmlsZSl7XG4gICAgICAgICAgICBpZihmaWxlS2V5LmluZGV4T2YobmFtZSk+LTEpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbkZpbGVbZmlsZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgXG59XG5cbmV4cG9ydCBjbGFzcyBFbGVtZW50IGV4dGVuZHMgeG1sb3BlcmF0aW9uIHtcbiAgICBlbGVtZW50U3RyaW5nOnN0cmluZ1xuICAgIGF0dHJpYnV0ZUxpc3Q6SWF0dHJpYnV0ZUxpc3RcbiAgICB2YWx1ZTpzdHJpbmdcbiAgICBjb250YWluZXI6c3RyaW5nXG4gICAgY29uc3RydWN0b3Ioc3RyOnN0cmluZyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudFN0cmluZyA9IHN0cjtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCByZWFkQXR0clJlZyA9IG5ldyBSZWdFeHAoJ1thLXpBLVowLTlfOl0qPz1cIi4qP1wiJywgXCJnXCIpO1xuICAgICAgICBsZXQgYXR0ckxpc3QgPSB0aGlzLmNvbnRhaW5lci5tYXRjaChyZWFkQXR0clJlZyk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTGlzdCA9IHt9O1xuICAgICAgICBpZihhdHRyTGlzdCE9bnVsbCl7XG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiBhdHRyTGlzdCl7XG4gICAgICAgICAgICAgICAgbGV0IGF0dHJGdWxsID0gYXR0ckxpc3Rba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBsZXQgYWw9IGF0dHJGdWxsLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBpZihhdHRyRnVsbC5sZW5ndGg9PTApe1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGF0dHJLZXkgPSBhdHRyRnVsbC5zdWJzdHIoMCwgYXR0ckZ1bGwuaW5kZXhPZignPScpKTtcbiAgICAgICAgICAgICAgICBsZXQgYXR0clZhbHVlID0gYXR0ckZ1bGwuc3Vic3RyKGF0dHJGdWxsLmluZGV4T2YoJz0nKSArIDEpO1xuICAgICAgICAgICAgICAgIGlmKGF0dHJLZXk9PW51bGwgfHwgYXR0clZhbHVlPT1udWxsIHx8YXR0cktleS5sZW5ndGg9PTAgfHwgYXR0clZhbHVlLmxlbmd0aD09MCl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUxpc3RbYXR0cktleV0gPSBhdHRyVmFsdWUuc3Vic3RyKDEsIGF0dHJWYWx1ZS5sZW5ndGgtMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSBuYW1lIEdldCBhdHRyaWJ1dGUgYnkga2V5IGluIGVsZW1lbnRcbiAgICAqIEByZXR1cm4gU2luZ2xlIGF0dHJpYnV0ZVxuICAgICovXG4gICAgZ2V0KG5hbWU6c3RyaW5nKTpzdHJpbmd8bnVtYmVyfGJvb2xlYW57XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZUxpc3RbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0gdGFnIEdldCBlbGVtZW50cyBieSB0YWcgaW4gZWxlbWVudFN0cmluZ1xuICAgICogQHJldHVybiBFbGVtZW50IGdyb3VwXG4gICAgKi9cbiAgICBnZXRJbm5lckVsZW1lbnRzKHRhZzpzdHJpbmcpOkVsZW1lbnRbXXtcbiAgICAgICAgbGV0IHJldCA9IHRoaXMuZ2V0RWxlbWVudHNCeU9uZVRhZyh0YWcsdGhpcy5lbGVtZW50U3RyaW5nKTtcbiAgICAgICAgbGV0IGVsZW1lbnRzOkVsZW1lbnRbXSA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgaT0wO2k8cmV0Lmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgbGV0IGVsZSA9IG5ldyBFbGVtZW50KHJldFtpXSk7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbGVtZW50cy5sZW5ndGg9PTApe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGRlc2MgZ2V0IHhtbCBkb20gdmFsdWUgYW5kIGNvbnRhaW5lciwgPGNvbnRhaW5lcj52YWx1ZTwvY29udGFpbmVyPlxuICAgICovXG4gICAgcHJpdmF0ZSBzZXRWYWx1ZSgpe1xuICAgICAgICBsZXQgc3RyID0gdGhpcy5lbGVtZW50U3RyaW5nO1xuICAgICAgICBpZihzdHIuc3Vic3RyKHN0ci5sZW5ndGgtMiwgMik9PVwiLz5cIil7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBsZXQgZmlyc3RUYWcgPSB0aGlzLmdldEZpcnN0VGFnKCk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFRhZ1JlZyA9IG5ldyBSZWdFeHAoXCIoPFwiKyBmaXJzdFRhZyArXCIgW14+XSs/W14vXT4pKFtcXFxcc1xcXFxTXSo/KTwvXCIrIGZpcnN0VGFnICtcIj58KDxcIisgZmlyc3RUYWcgK1wiPikoW1xcXFxzXFxcXFNdKj8pPC9cIisgZmlyc3RUYWcgK1wiPlwiLCBcImdcIik7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZmlyc3RUYWdSZWcuZXhlYyhzdHIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYocmVzdWx0WzFdIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSByZXN1bHRbMV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZXN1bHRbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gcmVzdWx0WzNdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0WzRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGRlc2MgZ2V0IHhtbCBkb20gZmlyc3QgdGFnLCA8YT48Yj48L2I+PC9hPiwgZ2V0IGFcbiAgICAqL1xuICAgIHByaXZhdGUgZ2V0Rmlyc3RUYWcoKXtcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMuZWxlbWVudFN0cmluZztcbiAgICAgICAgbGV0IGZpcnN0VGFnID0gc3RyLnN1YnN0cigwLCBzdHIuaW5kZXhPZignICcpKTtcbiAgICAgICAgaWYoZmlyc3RUYWc9PVwiXCIgfHwgZmlyc3RUYWcuaW5kZXhPZihcIj5cIik+LTEpe1xuICAgICAgICAgICAgZmlyc3RUYWcgPSBzdHIuc3Vic3RyKDAsIHN0ci5pbmRleE9mKCc+JykpO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0VGFnID0gZmlyc3RUYWcuc3Vic3RyKDEsZmlyc3RUYWcubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0VGFnO1xuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIElTdHlsZUNvbGxlY3Rpb25zIHtcbiAgICBbaW5kZXg6c3RyaW5nXTpFbGVtZW50W10gfCBJYXR0cmlidXRlTGlzdFxufVxuXG5mdW5jdGlvbiBjb21iaW5lSW5kZXhlZENvbG9yKGluZGV4ZWRDb2xvcnNJbm5lcjpFbGVtZW50W10sIGluZGV4ZWRDb2xvcnM6SWF0dHJpYnV0ZUxpc3QpOklhdHRyaWJ1dGVMaXN0e1xuICAgIGxldCByZXQ6SWF0dHJpYnV0ZUxpc3QgPSB7fTtcbiAgICBpZihpbmRleGVkQ29sb3JzSW5uZXI9PW51bGwgfHwgaW5kZXhlZENvbG9yc0lubmVyLmxlbmd0aD09MCl7XG4gICAgICAgIHJldHVybiBpbmRleGVkQ29sb3JzO1xuICAgIH1cbiAgICBmb3IobGV0IGtleSBpbiBpbmRleGVkQ29sb3JzKXtcbiAgICAgICAgbGV0IHZhbHVlID0gaW5kZXhlZENvbG9yc1trZXldLCBrbiA9IHBhcnNlSW50KGtleSk7XG4gICAgICAgIGxldCBpbm5lciA9IGluZGV4ZWRDb2xvcnNJbm5lcltrbl07XG4gICAgICAgIGlmKGlubmVyPT1udWxsKXtcbiAgICAgICAgICAgIHJldFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGxldCByZ2IgPSBpbm5lci5hdHRyaWJ1dGVMaXN0LnJnYjtcbiAgICAgICAgICAgIHJldFtrZXldID0gcmdiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuLy9jbHJTY2hlbWU6RWxlbWVudFtdXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sb3IoY29sb3I6RWxlbWVudCwgc3R5bGVzOklTdHlsZUNvbGxlY3Rpb25zICwgdHlwZTpzdHJpbmc9XCJnXCIpe1xuICAgIGxldCBhdHRyTGlzdCA9IGNvbG9yLmF0dHJpYnV0ZUxpc3Q7XG4gICAgbGV0IGNsclNjaGVtZSA9IHN0eWxlc1tcImNsclNjaGVtZVwiXSBhcyBFbGVtZW50W107XG4gICAgbGV0IGluZGV4ZWRDb2xvcnNJbm5lciA9IHN0eWxlc1tcImluZGV4ZWRDb2xvcnNcIl0gYXMgRWxlbWVudFtdO1xuICAgIGxldCBtcnVDb2xvcnNJbm5lciA9IHN0eWxlc1tcIm1ydUNvbG9yc1wiXTtcbiAgICBsZXQgaW5kZXhlZENvbG9yc0xpc3QgPSBjb21iaW5lSW5kZXhlZENvbG9yKGluZGV4ZWRDb2xvcnNJbm5lciwgaW5kZXhlZENvbG9ycyk7XG4gICAgbGV0IGluZGV4ZWQgPSBhdHRyTGlzdC5pbmRleGVkLCByZ2IgPSBhdHRyTGlzdC5yZ2IsIHRoZW1lID0gYXR0ckxpc3QudGhlbWUsIHRpbnQgPSBhdHRyTGlzdC50aW50O1xuICAgIGxldCBiZztcbiAgICBpZihpbmRleGVkIT1udWxsKXtcbiAgICAgICAgbGV0IGluZGV4ZWROdW0gPSBwYXJzZUludChpbmRleGVkKTtcbiAgICAgICAgYmcgPSBpbmRleGVkQ29sb3JzTGlzdFtpbmRleGVkTnVtXTtcbiAgICAgICAgaWYoYmchPW51bGwpe1xuICAgICAgICAgICAgYmcgPSBiZy5zdWJzdHJpbmcoYmcubGVuZ3RoLTYsIGJnLmxlbmd0aCk7XG4gICAgICAgICAgICBiZyA9IFwiI1wiK2JnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYocmdiIT1udWxsKXtcbiAgICAgICAgcmdiID0gcmdiLnN1YnN0cmluZyhyZ2IubGVuZ3RoLTYsIHJnYi5sZW5ndGgpO1xuICAgICAgICBiZyA9IFwiI1wiK3JnYjtcbiAgICB9XG4gICAgZWxzZSBpZih0aGVtZSE9bnVsbCl7XG4gICAgICAgIGxldCB0aGVtZU51bSA9IHBhcnNlSW50KHRoZW1lKTtcbiAgICAgICAgaWYodGhlbWVOdW09PTApe1xuICAgICAgICAgICAgdGhlbWVOdW0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhlbWVOdW09PTEpe1xuICAgICAgICAgICAgdGhlbWVOdW0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhlbWVOdW09PTIpe1xuICAgICAgICAgICAgdGhlbWVOdW0gPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhlbWVOdW09PTMpe1xuICAgICAgICAgICAgdGhlbWVOdW0gPSAyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbHJTY2hlbWVFbGVtZW50ID0gY2xyU2NoZW1lW3RoZW1lTnVtXTtcbiAgICAgICAgaWYoY2xyU2NoZW1lRWxlbWVudCE9bnVsbCl7XG4gICAgICAgICAgICBsZXQgY2xycyA9IGNsclNjaGVtZUVsZW1lbnQuZ2V0SW5uZXJFbGVtZW50cyhcImE6c3lzQ2xyfGE6c3JnYkNsclwiKTtcbiAgICAgICAgICAgIGlmKGNscnMhPW51bGwpe1xuICAgICAgICAgICAgICAgIGxldCBjbHIgPSBjbHJzWzBdO1xuICAgICAgICAgICAgICAgIGxldCBjbHJBdHRyTGlzdCA9IGNsci5hdHRyaWJ1dGVMaXN0O1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNsci5jb250YWluZXIsICk7XG4gICAgICAgICAgICAgICAgaWYoY2xyLmNvbnRhaW5lci5pbmRleE9mKFwic3lzQ2xyXCIpPi0xKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYodHlwZT09XCJnXCIgJiYgY2xyQXR0ckxpc3QudmFsPT1cIndpbmRvd1RleHRcIil7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBiZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpZigodHlwZT09XCJ0XCIgfHwgdHlwZT09XCJiXCIpICYmIGNsckF0dHJMaXN0LnZhbD09XCJ3aW5kb3dcIil7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBiZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIH0gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIFxuICAgICAgICAgICAgICAgICAgICBpZihjbHJBdHRyTGlzdC5sYXN0Q2xyIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnID0gXCIjXCIgKyBjbHJBdHRyTGlzdC5sYXN0Q2xyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2xyQXR0ckxpc3QudmFsIT1udWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnID0gXCIjXCIgKyBjbHJBdHRyTGlzdC52YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGNsci5jb250YWluZXIuaW5kZXhPZihcInNyZ2JDbHJcIik+LTEpe1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjbHJBdHRyTGlzdC52YWwpO1xuICAgICAgICAgICAgICAgICAgICBiZyA9IFwiI1wiICsgY2xyQXR0ckxpc3QudmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgaWYodGludCE9bnVsbCl7XG4gICAgICAgIGxldCB0aW50TnVtID0gcGFyc2VGbG9hdCh0aW50KTtcbiAgICAgICAgaWYoYmchPW51bGwpe1xuICAgICAgICAgICAgYmcgPSBMaWdodGVuRGFya2VuQ29sb3IoYmcsIHRpbnROdW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJnO1xufVxuXG5cbi8qKiBcbiAqIEBkb20geG1sIGF0dHJpYnV0ZSBvYmplY3RcbiAqIEBhdHRyIGF0dHJpYnV0ZSBuYW1lXG4gKiBAZCBpZiBhdHRyaWJ1dGUgaXMgbnVsbCwgcmV0dXJuIGRlZmF1bHQgdmFsdWUgXG4gKiBAcmV0dXJuIGF0dHJpYnV0ZSB2YWx1ZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRsaW5lU3RyaW5nQXR0cihmcnByOkVsZW1lbnQsIGF0dHI6c3RyaW5nKTpzdHJpbmd7XG4gICAgbGV0IGF0dHJFbGUgPSBmcnByLmdldElubmVyRWxlbWVudHMoYXR0ciksIHZhbHVlO1xuXG4gICAgaWYoYXR0ckVsZSE9bnVsbCAmJiBhdHRyRWxlLmxlbmd0aD4wKXtcbiAgICAgICAgaWYoYXR0cj09XCJiXCIgfHwgYXR0cj09XCJpXCIgfHwgYXR0cj09XCJzdHJpa2VcIil7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiMVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoYXR0cj09XCJ1XCIpe1xuICAgICAgICAgICAgbGV0IHYgPSBhdHRyRWxlWzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xuICAgICAgICAgICAgaWYodj09XCJkb3VibGVcIil7XG4gICAgICAgICAgICAgICAgdmFsdWXCoD3CoMKgXCIyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlwqBpZih2PT1cInNpbmdsZUFjY291bnRpbmdcIil7XG4gICAgICAgICAgICAgICAgdmFsdWXCoD3CoMKgXCIzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlwqBpZih2PT1cImRvdWJsZUFjY291bnRpbmdcIil7XG4gICAgICAgICAgICAgICAgdmFsdWXCoD3CoMKgXCI0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihhdHRyPT1cInZlcnRBbGlnblwiKXtcbiAgICAgICAgICAgIGxldCB2ID0gYXR0ckVsZVswXS5hdHRyaWJ1dGVMaXN0LnZhbDtcbiAgICAgICAgICAgIGlmKHY9PVwic3Vic2NyaXB0XCIpe1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHY9PVwic3VwZXJzY3JpcHRcIil7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgdmFsdWUgPSBhdHRyRWxlWzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn0iLCJpbXBvcnQge3N0cmluZ1RvTnVtLCBJYXR0cmlidXRlTGlzdCwgbnVtVG9zdHJpbmd9IGZyb20gXCIuLi9JQ29tbW9uXCI7XG5cbmV4cG9ydCBjb25zdCBjb2x1bWVIZWFkZXJfd29yZDpzdHJpbmdbXSA9IFsnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJ107XG5cbmV4cG9ydCBjb25zdCBjb2x1bWVIZWFkZXJfd29yZF9pbmRleDpzdHJpbmdUb051bSA9IHsgJ0EnOiAwLCAnQic6IDEsICdDJzogMiwgJ0QnOiAzLCAnRSc6IDQsICdGJzogNSwgJ0cnOiA2LCAnSCc6IDcsICdJJzogOCwgJ0onOiA5LCAnSyc6IDEwLCAnTCc6IDExLCAnTSc6IDEyLCAnTic6IDEzLCAnTyc6IDE0LCAnUCc6IDE1LCAnUSc6IDE2LCAnUic6IDE3LCAnUyc6IDE4LCAnVCc6IDE5LCAnVSc6IDIwLCAnVic6IDIxLCAnVyc6IDIyLCAnWCc6IDIzLCAnWSc6IDI0LCAnWic6IDI1IH07XG5cbmV4cG9ydCBjb25zdCBjb3JlRmlsZSA9IFwiZG9jUHJvcHMvY29yZS54bWxcIjtcbmV4cG9ydCBjb25zdCBhcHBGaWxlID0gXCJkb2NQcm9wcy9hcHAueG1sXCI7XG5leHBvcnQgY29uc3QgY29udGVudFR5cGVzRmlsZSA9IFwiW0NvbnRlbnRfVHlwZXNdLnhtbFwiO1xuZXhwb3J0IGNvbnN0IHdvcmtCb29rRmlsZSA9IFwieGwvd29ya2Jvb2sueG1sXCI7XG5leHBvcnQgY29uc3QgY2FsY0NoYWluRmlsZSA9IFwieGwvY2FsY0NoYWluLnhtbFwiO1xuZXhwb3J0IGNvbnN0IHN0eWxlc0ZpbGUgPSBcInhsL3N0eWxlcy54bWxcIjtcbmV4cG9ydCBjb25zdCBzaGFyZWRTdHJpbmdzRmlsZSA9IFwieGwvc2hhcmVkU3RyaW5ncy54bWxcIjtcbmV4cG9ydCBjb25zdCB3b3Jrc2hlZXRGaWxlUGF0aCA9IFwieGwvd29ya3NoZWV0cy9cIjtcbmV4cG9ydCBjb25zdCB0aGVtZTFGaWxlID0gXCJ4bC90aGVtZS90aGVtZTEueG1sXCI7XG5leHBvcnQgY29uc3Qgd29ya2Jvb2tSZWxzPSBcInhsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzXCI7XG5cblxuXG5cbi8vRXhjZWwgQnVpbHQtSW4gY2VsbCB0eXBlXG5leHBvcnQgY29uc3QgU1RfQ2VsbFR5cGU6SWF0dHJpYnV0ZUxpc3QgPXtcbiAgICBcIkJvb2xlYW5cIjpcImJcIixcbiAgICBcIkRhdGVcIjpcImRcIixcbiAgICBcIkVycm9yXCI6XCJlXCIsXG4gICAgXCJJbmxpbmVTdHJpbmdcIjpcImlubGluZVN0clwiLFxuICAgIFwiTnVtYmVyXCI6XCJuXCIsXG4gICAgXCJTaGFyZWRTdHJpbmdcIjpcInNcIixcbiAgICBcIlN0cmluZ1wiOlwic3RyXCIsXG59XG5cbi8vRXhjZWwgQnVpbHQtSW4gY2VsbCBzdHlsZVxuZXhwb3J0IGNvbnN0IEJ1aWx0SW5DZWxsU3R5bGVzOklhdHRyaWJ1dGVMaXN0ID0ge1xuICAgIFwiMFwiOlwiTm9ybWFsXCIsXG5cbn1cblxuXG5leHBvcnQgbGV0IG51bUZtdERlZmF1bHQ6SWF0dHJpYnV0ZUxpc3QgPSB7XG4gICAgXCIwXCI6J0dlbmVyYWwnLFxuICAgIFwiMVwiOiAnMCcsXG4gICAgXCIyXCI6ICcwLjAwJyxcbiAgICBcIjNcIjogJyMsIyMwJyxcbiAgICBcIjRcIjogJyMsIyMwLjAwJyxcbiAgICBcIjlcIjonMCUnLFxuICAgIFwiMTBcIjogJzAuMDAlJyxcbiAgICBcIjExXCI6ICcwLjAwRSswMCcsXG4gICAgXCIxMlwiOiAnIyA/Lz8nLFxuICAgIFwiMTNcIjogJyMgPz8vPz8nLFxuICAgIFwiMTRcIjogJ20vZC95eScsXG4gICAgXCIxNVwiOiAnZC1tbW0teXknLFxuICAgIFwiMTZcIjogJ2QtbW1tJyxcbiAgICBcIjE3XCI6ICdtbW0teXknLFxuICAgIFwiMThcIjogJ2g6bW0gQU0vUE0nLFxuICAgIFwiMTlcIjogJ2g6bW06c3MgQU0vUE0nLFxuICAgIFwiMjBcIjogJ2g6bW0nLFxuICAgIFwiMjFcIjogJ2g6bW06c3MnLFxuICAgIFwiMjJcIjogJ20vZC95eSBoOm1tJyxcbiAgICBcIjM3XCI6ICcjLCMjMCA7KCMsIyMwKScsXG4gICAgXCIzOFwiOiAnIywjIzAgO1tSZWRdKCMsIyMwKScsXG4gICAgXCIzOVwiOiAnIywjIzAuMDA7KCMsIyMwLjAwKScsXG4gICAgXCI0MFwiOiAnIywjIzAuMDA7W1JlZF0oIywjIzAuMDApJyxcbiAgICBcIjQ1XCI6ICdtbTpzcycsXG4gICAgXCI0NlwiOiAnW2hdOm1tOnNzJyxcbiAgICBcIjQ3XCI6ICdtbXNzLjAnLFxuICAgIFwiNDhcIjogJyMjMC4wRSswJyxcbiAgICBcIjQ5XCI6ICdAJ1xufVxuXG5leHBvcnQgY29uc3QgaW5kZXhlZENvbG9yczpJYXR0cmlidXRlTGlzdCA9IHtcbiAgICBcIjBcIjonMDAwMDAwMDAnLFxuICAgIFwiMVwiOicwMEZGRkZGRicsXG4gICAgXCIyXCI6JzAwRkYwMDAwJyxcbiAgICBcIjNcIjonMDAwMEZGMDAnLFxuICAgIFwiNFwiOicwMDAwMDBGRicsXG4gICAgXCI1XCI6JzAwRkZGRjAwJyxcbiAgICBcIjZcIjonMDBGRjAwRkYnLFxuICAgIFwiN1wiOicwMDAwRkZGRicsXG4gICAgXCI4XCI6JzAwMDAwMDAwJyxcbiAgICBcIjlcIjonMDBGRkZGRkYnLFxuICAgIFwiMTBcIjonMDBGRjAwMDAnLFxuICAgIFwiMTFcIjonMDAwMEZGMDAnLFxuICAgIFwiMTJcIjonMDAwMDAwRkYnLFxuICAgIFwiMTNcIjonMDBGRkZGMDAnLFxuICAgIFwiMTRcIjonMDBGRjAwRkYnLFxuICAgIFwiMTVcIjonMDAwMEZGRkYnLFxuICAgIFwiMTZcIjonMDA4MDAwMDAnLFxuICAgIFwiMTdcIjonMDAwMDgwMDAnLFxuICAgIFwiMThcIjonMDAwMDAwODAnLFxuICAgIFwiMTlcIjonMDA4MDgwMDAnLFxuICAgIFwiMjBcIjonMDA4MDAwODAnLFxuICAgIFwiMjFcIjonMDAwMDgwODAnLFxuICAgIFwiMjJcIjonMDBDMEMwQzAnLFxuICAgIFwiMjNcIjonMDA4MDgwODAnLFxuICAgIFwiMjRcIjonMDA5OTk5RkYnLFxuICAgIFwiMjVcIjonMDA5OTMzNjYnLFxuICAgIFwiMjZcIjonMDBGRkZGQ0MnLFxuICAgIFwiMjdcIjonMDBDQ0ZGRkYnLFxuICAgIFwiMjhcIjonMDA2NjAwNjYnLFxuICAgIFwiMjlcIjonMDBGRjgwODAnLFxuICAgIFwiMzBcIjonMDAwMDY2Q0MnLFxuICAgIFwiMzFcIjonMDBDQ0NDRkYnLFxuICAgIFwiMzJcIjonMDAwMDAwODAnLFxuICAgIFwiMzNcIjonMDBGRjAwRkYnLFxuICAgIFwiMzRcIjonMDBGRkZGMDAnLFxuICAgIFwiMzVcIjonMDAwMEZGRkYnLFxuICAgIFwiMzZcIjonMDA4MDAwODAnLFxuICAgIFwiMzdcIjonMDA4MDAwMDAnLFxuICAgIFwiMzhcIjonMDAwMDgwODAnLFxuICAgIFwiMzlcIjonMDAwMDAwRkYnLFxuICAgIFwiNDBcIjonMDAwMENDRkYnLFxuICAgIFwiNDFcIjonMDBDQ0ZGRkYnLFxuICAgIFwiNDJcIjonMDBDQ0ZGQ0MnLFxuICAgIFwiNDNcIjonMDBGRkZGOTknLFxuICAgIFwiNDRcIjonMDA5OUNDRkYnLFxuICAgIFwiNDVcIjonMDBGRjk5Q0MnLFxuICAgIFwiNDZcIjonMDBDQzk5RkYnLFxuICAgIFwiNDdcIjonMDBGRkNDOTknLFxuICAgIFwiNDhcIjonMDAzMzY2RkYnLFxuICAgIFwiNDlcIjonMDAzM0NDQ0MnLFxuICAgIFwiNTBcIjonMDA5OUNDMDAnLFxuICAgIFwiNTFcIjonMDBGRkNDMDAnLFxuICAgIFwiNTJcIjonMDBGRjk5MDAnLFxuICAgIFwiNTNcIjonMDBGRjY2MDAnLFxuICAgIFwiNTRcIjonMDA2NjY2OTknLFxuICAgIFwiNTVcIjonMDA5Njk2OTYnLFxuICAgIFwiNTZcIjonMDAwMDMzNjYnLFxuICAgIFwiNTdcIjonMDAzMzk5NjYnLFxuICAgIFwiNThcIjonMDAwMDMzMDAnLFxuICAgIFwiNTlcIjonMDAzMzMzMDAnLFxuICAgIFwiNjBcIjonMDA5OTMzMDAnLFxuICAgIFwiNjFcIjonMDA5OTMzNjYnLFxuICAgIFwiNjJcIjonMDAzMzMzOTknLFxuICAgIFwiNjNcIjonMDAzMzMzMzMnLFxuICAgIFwiNjRcIjpudWxsLC8vc3lzdGVtIEZvcmVncm91bmQgbi9hXG4gICAgXCI2NVwiOm51bGwsLy9zeXN0ZW0gQmFja2dyb3VuZCBuL2Fcbn1cblxuZXhwb3J0IGNvbnN0IE9FTV9DSEFSU0VUOklhdHRyaWJ1dGVMaXN0ID0ge1xuICAgIFwiMFwiOiBcIkFOU0lfQ0hBUlNFVFwiLFxuICAgIFwiMVwiOiBcIkRFRkFVTFRfQ0hBUlNFVFwiLFxuICAgIFwiMlwiOiBcIlNZTUJPTF9DSEFSU0VUXCIsXG4gICAgXCI3N1wiOiBcIk1BQ19DSEFSU0VUXCIsXG4gICAgXCIxMjhcIjogXCJTSElGVEpJU19DSEFSU0VUXCIsXG4gICAgXCIxMjlcIjogXCJIQU5HVUxfQ0hBUlNFVFwiLFxuICAgIFwiMTMwXCI6IFwiSk9IQUJfQ0hBUlNFVFwiLFxuICAgIFwiMTM0XCI6IFwiR0IyMzEyX0NIQVJTRVRcIixcbiAgICBcIjEzNlwiOiBcIkNISU5FU0VCSUc1X0NIQVJTRVRcIixcbiAgICBcIjE2MVwiOiBcIkdSRUVLX0NIQVJTRVRcIixcbiAgICBcIjE2MlwiOiBcIlRVUktJU0hfQ0hBUlNFVFwiLFxuICAgIFwiMTYzXCI6IFwiVklFVE5BTUVTRV9DSEFSU0VUXCIsXG4gICAgXCIxNzdcIjogXCJIRUJSRVdfQ0hBUlNFVFwiLFxuICAgIFwiMTc4XCI6IFwiQVJBQklDX0NIQVJTRVRcIixcbiAgICBcIjE4NlwiOiBcIkJBTFRJQ19DSEFSU0VUXCIsXG4gICAgXCIyMDRcIjogXCJSVVNTSUFOX0NIQVJTRVRcIixcbiAgICBcIjIyMlwiOiBcIlRIQUlfQ0hBUlNFVFwiLFxuICAgIFwiMjM4XCI6IFwiRUFTVEVVUk9QRV9DSEFSU0VUXCIsXG4gICAgXCIyNTVcIjogXCJPRU1fQ0hBUlNFVFwiLFxufVxuXG5cbmV4cG9ydCBjb25zdCBib3JkZXJUeXBlczpzdHJpbmdUb051bSA9IHtcbiAgICBcIm5vbmVcIjowLFxuICAgIFwidGhpblwiOjEsIFxuICAgIFwiaGFpclwiOjIsIFxuICAgIFwiZG90dGVkXCI6MywgXG4gICAgXCJkYXNoZWRcIjo0LCBcbiAgICBcImRhc2hEb3RcIjo1LCBcbiAgICBcImRhc2hEb3REb3RcIjo2LCBcbiAgICBcImRvdWJsZVwiOjcsIFxuICAgIFwibWVkaXVtXCI6OCwgXG4gICAgXCJtZWRpdW1EYXNoZWRcIjo5LCBcbiAgICBcIm1lZGl1bURhc2hEb3RcIjoxMCwgXG4gICAgXCJtZWRpdW1EYXNoRG90RG90XCI6MTEsIFxuICAgIFwic2xhbnREYXNoRG90XCI6MTIsIFxuICAgIFwidGhpY2tcIjoxM1xufVxuXG5cbmV4cG9ydCBjb25zdCBmb250RmFtaWx5czpJYXR0cmlidXRlTGlzdCA9IHtcbiAgICBcIjBcIjpcImRlZnVhbHRcIixcbiAgICBcIjFcIjpcIlJvbWFuXCIsXG4gICAgXCIyXCI6XCJTd2lzc1wiLFxuICAgIFwiM1wiOlwiTW9kZXJuXCIsXG4gICAgXCI0XCI6XCJTY3JpcHRcIixcbiAgICBcIjVcIjpcIkRlY29yYXRpdmVcIlxufSIsImV4cG9ydCBsZXQgVURPQzphbnkgPSB7fTtcblx0XG5cdFVET0MuRyA9IHtcblx0XHRjb25jYXQgOiBmdW5jdGlvbihwOmFueSxyOmFueSkge1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8ci5jbWRzLmxlbmd0aDsgaSsrKSBwLmNtZHMucHVzaChyLmNtZHNbaV0pO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8ci5jcmRzLmxlbmd0aDsgaSsrKSBwLmNyZHMucHVzaChyLmNyZHNbaV0pO1xuXHRcdH0sXG5cdFx0Z2V0QkIgIDogZnVuY3Rpb24ocHM6YW55KSB7XG5cdFx0XHR2YXIgeDA9MWU5OSwgeTA9MWU5OSwgeDE9LXgwLCB5MT0teTA7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxwcy5sZW5ndGg7IGkrPTIpIHsgIHZhciB4PXBzW2ldLHk9cHNbaSsxXTsgIGlmKHg8eDApeDA9eDsgZWxzZSBpZih4PngxKXgxPXg7ICBpZih5PHkwKXkwPXk7ICBlbHNlIGlmKHk+eTEpeTE9eTsgIH1cblx0XHRcdHJldHVybiBbeDAseTAseDEseTFdO1xuXHRcdH0sXG5cdFx0cmVjdFRvUGF0aDogZnVuY3Rpb24ocjphbnkpIHsgIHJldHVybiAge2NtZHM6W1wiTVwiLFwiTFwiLFwiTFwiLFwiTFwiLFwiWlwiXSxjcmRzOltyWzBdLHJbMV0sclsyXSxyWzFdLCByWzJdLHJbM10sclswXSxyWzNdXX07ICB9LFxuXHRcdC8vIGEgaW5zaWRlIGJcblx0XHRpbnNpZGVCb3g6IGZ1bmN0aW9uKGE6YW55LGI6YW55KSB7ICByZXR1cm4gYlswXTw9YVswXSAmJiBiWzFdPD1hWzFdICYmIGFbMl08PWJbMl0gJiYgYVszXTw9YlszXTsgICB9LFxuXHRcdGlzQm94IDogZnVuY3Rpb24ocDphbnksIGJiOmFueSkge1xuXHRcdFx0dmFyIHNhbWVDcmQ4ID0gZnVuY3Rpb24ocGNyZDphbnksIGNyZHM6YW55KSB7XG5cdFx0XHRcdGZvcih2YXIgbz0wOyBvPDg7IG8rPTIpIHsgIHZhciBlcSA9IHRydWU7ICBmb3IodmFyIGo9MDsgajw4OyBqKyspIGlmKE1hdGguYWJzKGNyZHNbal0tcGNyZFsoaitvKSY3XSk+PTIpIHsgIGVxID0gZmFsc2U7ICBicmVhazsgIH0gICAgaWYoZXEpIHJldHVybiB0cnVlOyAgfVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0aWYocC5jbWRzLmxlbmd0aD4xMCkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0dmFyIGNtZHM9cC5jbWRzLmpvaW4oXCJcIiksIGNyZHM9cC5jcmRzO1xuXHRcdFx0dmFyIHNhbWVSZWN0ID0gZmFsc2U7XG5cdFx0XHRpZigoY21kcz09XCJNTExMWlwiICAmJiBjcmRzLmxlbmd0aD09IDgpIFxuXHRcdFx0IHx8KGNtZHM9PVwiTUxMTExaXCIgJiYgY3Jkcy5sZW5ndGg9PTEwKSApIHtcblx0XHRcdFx0aWYoY3Jkcy5sZW5ndGg9PTEwKSBjcmRzPWNyZHMuc2xpY2UoMCw4KTtcblx0XHRcdFx0dmFyIHgwPWJiWzBdLHkwPWJiWzFdLHgxPWJiWzJdLHkxPWJiWzNdO1xuXHRcdFx0XHRpZighc2FtZVJlY3QpIHNhbWVSZWN0ID0gc2FtZUNyZDgoY3JkcywgW3gwLHkwLHgxLHkwLHgxLHkxLHgwLHkxXSk7XG5cdFx0XHRcdGlmKCFzYW1lUmVjdCkgc2FtZVJlY3QgPSBzYW1lQ3JkOChjcmRzLCBbeDAseTEseDEseTEseDEseTAseDAseTBdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzYW1lUmVjdDtcblx0XHR9LFxuXHRcdGJveEFyZWE6IGZ1bmN0aW9uKGE6YW55KSB7ICB2YXIgdz1hWzJdLWFbMF0sIGg9YVszXS1hWzFdOyAgcmV0dXJuIHcqaDsgIH0sXG5cdFx0bmV3UGF0aDogZnVuY3Rpb24oZ3N0OmFueSAgICApIHsgIGdzdC5wdGggPSB7Y21kczpbXSwgY3JkczpbXX07ICB9LFxuXHRcdG1vdmVUbyA6IGZ1bmN0aW9uKGdzdDphbnkseDphbnkseTphbnkpIHsgIHZhciBwPVVET0MuTS5tdWx0UG9pbnQoZ3N0LmN0bSxbeCx5XSk7ICAvL2lmKGdzdC5jcG9zWzBdPT1wWzBdICYmIGdzdC5jcG9zWzFdPT1wWzFdKSByZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGdzdC5wdGguY21kcy5wdXNoKFwiTVwiKTsgIGdzdC5wdGguY3Jkcy5wdXNoKHBbMF0scFsxXSk7ICBnc3QuY3BvcyA9IHA7ICB9LFxuXHRcdGxpbmVUbyA6IGZ1bmN0aW9uKGdzdDphbnkseDphbnkseTphbnkpIHsgIHZhciBwPVVET0MuTS5tdWx0UG9pbnQoZ3N0LmN0bSxbeCx5XSk7ICBpZihnc3QuY3Bvc1swXT09cFswXSAmJiBnc3QuY3Bvc1sxXT09cFsxXSkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRnc3QucHRoLmNtZHMucHVzaChcIkxcIik7ICBnc3QucHRoLmNyZHMucHVzaChwWzBdLHBbMV0pOyAgZ3N0LmNwb3MgPSBwOyAgfSxcblx0XHRjdXJ2ZVRvOiBmdW5jdGlvbihnc3Q6YW55LHgxOmFueSx5MTphbnkseDI6YW55LHkyOmFueSx4MzphbnkseTM6YW55KSB7ICAgdmFyIHA7ICBcblx0XHRcdHA9VURPQy5NLm11bHRQb2ludChnc3QuY3RtLFt4MSx5MV0pOyAgeDE9cFswXTsgIHkxPXBbMV07XG5cdFx0XHRwPVVET0MuTS5tdWx0UG9pbnQoZ3N0LmN0bSxbeDIseTJdKTsgIHgyPXBbMF07ICB5Mj1wWzFdO1xuXHRcdFx0cD1VRE9DLk0ubXVsdFBvaW50KGdzdC5jdG0sW3gzLHkzXSk7ICB4Mz1wWzBdOyAgeTM9cFsxXTsgIGdzdC5jcG9zID0gcDtcblx0XHRcdGdzdC5wdGguY21kcy5wdXNoKFwiQ1wiKTsgIFxuXHRcdFx0Z3N0LnB0aC5jcmRzLnB1c2goeDEseTEseDIseTIseDMseTMpOyAgXG5cdFx0fSxcblx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uKGdzdDphbnkgICkgeyAgZ3N0LnB0aC5jbWRzLnB1c2goXCJaXCIpOyAgfSxcblx0XHRhcmMgOiBmdW5jdGlvbihnc3Q6YW55LHg6YW55LHk6YW55LHI6YW55LGEwOmFueSxhMTphbnksIG5lZzphbnkpIHtcblx0XHRcdFxuXHRcdFx0Ly8gY2lyY2xlIGZyb20gYTAgY291bnRlci1jbG9jay13aXNlIHRvIGExXG5cdFx0XHRpZihuZWcpIHdoaWxlKGExPmEwKSBhMS09MipNYXRoLlBJO1xuXHRcdFx0ZWxzZSAgICB3aGlsZShhMTxhMCkgYTErPTIqTWF0aC5QSTtcblx0XHRcdHZhciB0aCA9IChhMS1hMCkvNDtcblx0XHRcdFxuXHRcdFx0dmFyIHgwID0gTWF0aC5jb3ModGgvMiksIHkwID0gLU1hdGguc2luKHRoLzIpO1xuXHRcdFx0dmFyIHgxID0gKDQteDApLzMsIHkxID0geTA9PTAgPyB5MCA6ICgxLXgwKSooMy14MCkvKDMqeTApO1xuXHRcdFx0dmFyIHgyID0geDEsIHkyID0gLXkxO1xuXHRcdFx0dmFyIHgzID0geDAsIHkzID0gLXkwO1xuXHRcdFx0XG5cdFx0XHR2YXIgcDAgPSBbeDAseTBdLCBwMSA9IFt4MSx5MV0sIHAyID0gW3gyLHkyXSwgcDMgPSBbeDMseTNdO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHRoID0ge2NtZHM6Wyhnc3QucHRoLmNtZHMubGVuZ3RoPT0wKT9cIk1cIjpcIkxcIixcIkNcIixcIkNcIixcIkNcIixcIkNcIl0sIGNyZHM6W3gwLHkwLHgxLHkxLHgyLHkyLHgzLHkzXX07XG5cdFx0XHRcblx0XHRcdHZhciByb3QgPSBbMSwwLDAsMSwwLDBdOyAgVURPQy5NLnJvdGF0ZShyb3QsLXRoKTtcblx0XHRcdFxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8MzsgaSsrKSB7XG5cdFx0XHRcdHAxID0gVURPQy5NLm11bHRQb2ludChyb3QscDEpOyAgcDIgPSBVRE9DLk0ubXVsdFBvaW50KHJvdCxwMik7ICBwMyA9IFVET0MuTS5tdWx0UG9pbnQocm90LHAzKTtcblx0XHRcdFx0cHRoLmNyZHMucHVzaChwMVswXSxwMVsxXSxwMlswXSxwMlsxXSxwM1swXSxwM1sxXSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBzYyA9IFtyLDAsMCxyLHgseV07ICBcblx0XHRcdFVET0MuTS5yb3RhdGUocm90LCAtYTArdGgvMik7ICBVRE9DLk0uY29uY2F0KHJvdCwgc2MpOyAgVURPQy5NLm11bHRBcnJheShyb3QsIHB0aC5jcmRzKTtcblx0XHRcdFVET0MuTS5tdWx0QXJyYXkoZ3N0LmN0bSwgcHRoLmNyZHMpO1xuXHRcdFx0XG5cdFx0XHRVRE9DLkcuY29uY2F0KGdzdC5wdGgsIHB0aCk7XG5cdFx0XHR2YXIgeTphbnk9cHRoLmNyZHMucG9wKCk7ICB4PXB0aC5jcmRzLnBvcCgpO1xuXHRcdFx0Z3N0LmNwb3MgPSBbeCx5XTtcblx0XHR9LFxuXHRcdHRvUG9seSA6IGZ1bmN0aW9uKHA6YW55KSB7XG5cdFx0XHRpZihwLmNtZHNbMF0hPVwiTVwiIHx8IHAuY21kc1twLmNtZHMubGVuZ3RoLTFdIT1cIlpcIikgcmV0dXJuIG51bGw7XG5cdFx0XHRmb3IodmFyIGk9MTsgaTxwLmNtZHMubGVuZ3RoLTE7IGkrKykgaWYocC5jbWRzW2ldIT1cIkxcIikgcmV0dXJuIG51bGw7XG5cdFx0XHR2YXIgb3V0ID0gW10sIGNsID0gcC5jcmRzLmxlbmd0aDtcblx0XHRcdGlmKHAuY3Jkc1swXT09cC5jcmRzW2NsLTJdICYmIHAuY3Jkc1sxXT09cC5jcmRzW2NsLTFdKSBjbC09Mjtcblx0XHRcdGZvcih2YXIgaT0wOyBpPGNsOyBpKz0yKSBvdXQucHVzaChbcC5jcmRzW2ldLHAuY3Jkc1tpKzFdXSk7XG5cdFx0XHRpZihVRE9DLkcucG9seUFyZWEocC5jcmRzKTwwKSBvdXQucmV2ZXJzZSgpO1xuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9LFxuXHRcdGZyb21Qb2x5IDogZnVuY3Rpb24ocDphbnkpIHtcblx0XHRcdHZhciBvOmFueSA9IHtjbWRzOltdLGNyZHM6W119O1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrKykgeyBvLmNyZHMucHVzaChwW2ldWzBdLCBwW2ldWzFdKTsgIG8uY21kcy5wdXNoKGk9PTA/XCJNXCI6XCJMXCIpOyAgfVxuXHRcdFx0by5jbWRzLnB1c2goXCJaXCIpO1xuXHRcdFx0cmV0dXJuIG87XG5cdFx0fSxcblx0XHRwb2x5QXJlYSA6IGZ1bmN0aW9uKHA6YW55KSB7XG5cdFx0XHRpZihwLmxlbmd0aCA8NikgcmV0dXJuIDA7XG5cdFx0XHR2YXIgbCA9IHAubGVuZ3RoIC0gMjtcblx0XHRcdHZhciBzdW0gPSAocFswXS1wW2xdKSAqIChwW2wrMV0rcFsxXSk7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxuXHRcdFx0XHRzdW0gKz0gKHBbaSsyXS1wW2ldKSAqIChwW2krMV0rcFtpKzNdKTtcblx0XHRcdHJldHVybiAtIHN1bSAqIDAuNTtcblx0XHR9LFxuXHRcdHBvbHlDbGlwIDogZnVuY3Rpb24ocDA6YW55LCBwMTphbnkpIHsgIC8vIHAwIGNsaXBwZWQgYnkgcDFcbiAgICAgICAgICAgIHZhciBjcDE6YW55LCBjcDI6YW55LCBzOmFueSwgZTphbnk7XG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gZnVuY3Rpb24gKHA6YW55KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcDJbMF0tY3AxWzBdKSoocFsxXS1jcDFbMV0pID4gKGNwMlsxXS1jcDFbMV0pKihwWzBdLWNwMVswXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGlzYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGMgPSBbIGNwMVswXSAtIGNwMlswXSwgY3AxWzFdIC0gY3AyWzFdIF0sXG4gICAgICAgICAgICAgICAgICAgIGRwID0gWyBzWzBdIC0gZVswXSwgc1sxXSAtIGVbMV0gXSxcbiAgICAgICAgICAgICAgICAgICAgbjEgPSBjcDFbMF0gKiBjcDJbMV0gLSBjcDFbMV0gKiBjcDJbMF0sXG4gICAgICAgICAgICAgICAgICAgIG4yID0gc1swXSAqIGVbMV0gLSBzWzFdICogZVswXSwgXG4gICAgICAgICAgICAgICAgICAgIG4zID0gMS4wIC8gKGRjWzBdICogZHBbMV0gLSBkY1sxXSAqIGRwWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyhuMSpkcFswXSAtIG4yKmRjWzBdKSAqIG4zLCAobjEqZHBbMV0gLSBuMipkY1sxXSkgKiBuM107XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG91dCA9IHAwO1xuICAgICAgICAgICAgY3AxID0gcDFbcDEubGVuZ3RoLTFdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiBpbiBwMSkge1xuICAgICAgICAgICAgICAgIHZhciBjcDIgPSBwMVtqXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wID0gb3V0O1xuICAgICAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICAgICAgICAgIHMgPSBpbnBbaW5wLmxlbmd0aCAtIDFdOyAvL2xhc3Qgb24gdGhlIGlucHV0IGxpc3RcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIGlucCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGlucFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2lkZShlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUocykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChpc2MoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnNpZGUocykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGlzYygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3AxID0gY3AyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dFxuICAgICAgICB9XG5cdH1cblx0VURPQy5NID0ge1xuXHRcdGdldFNjYWxlIDogZnVuY3Rpb24obTphbnkpIHsgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5hYnMobVswXSptWzNdLW1bMV0qbVsyXSkpOyAgfSxcblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uKG06YW55LHg6YW55LHk6YW55KSB7ICBVRE9DLk0uY29uY2F0KG0sIFsxLDAsMCwxLHgseV0pOyAgfSxcblx0XHRyb3RhdGUgICA6IGZ1bmN0aW9uKG06YW55LGE6YW55ICApIHsgIFVET0MuTS5jb25jYXQobSwgW01hdGguY29zKGEpLCAtTWF0aC5zaW4oYSksIE1hdGguc2luKGEpLCBNYXRoLmNvcyhhKSwwLDBdKTsgIH0sXG5cdFx0c2NhbGUgICAgOiBmdW5jdGlvbihtOmFueSx4OmFueSx5OmFueSkgeyAgVURPQy5NLmNvbmNhdChtLCBbeCwwLDAseSwwLDBdKTsgIH0sXG5cdFx0Y29uY2F0ICAgOiBmdW5jdGlvbihtOmFueSx3OmFueSAgKSB7ICBcblx0XHRcdHZhciBhPW1bMF0sYj1tWzFdLGM9bVsyXSxkPW1bM10sdHg9bVs0XSx0eT1tWzVdO1xuXHRcdFx0bVswXSA9IChhICp3WzBdKSsoYiAqd1syXSk7ICAgICAgIG1bMV0gPSAoYSAqd1sxXSkrKGIgKndbM10pO1xuXHRcdFx0bVsyXSA9IChjICp3WzBdKSsoZCAqd1syXSk7ICAgICAgIG1bM10gPSAoYyAqd1sxXSkrKGQgKndbM10pO1xuXHRcdFx0bVs0XSA9ICh0eCp3WzBdKSsodHkqd1syXSkrd1s0XTsgIG1bNV0gPSAodHgqd1sxXSkrKHR5KndbM10pK3dbNV07IFxuXHRcdH0sXG5cdFx0aW52ZXJ0ICAgOiBmdW5jdGlvbihtOmFueSAgICApIHsgIFxuXHRcdFx0dmFyIGE9bVswXSxiPW1bMV0sYz1tWzJdLGQ9bVszXSx0eD1tWzRdLHR5PW1bNV0sIGFkYmM9YSpkLWIqYztcblx0XHRcdG1bMF0gPSBkL2FkYmM7ICBtWzFdID0gLWIvYWRiYzsgIG1bMl0gPS1jL2FkYmM7ICBtWzNdID0gIGEvYWRiYztcblx0XHRcdG1bNF0gPSAoYyp0eSAtIGQqdHgpL2FkYmM7ICBtWzVdID0gKGIqdHggLSBhKnR5KS9hZGJjO1xuXHRcdH0sXG5cdFx0bXVsdFBvaW50OiBmdW5jdGlvbihtOmFueSwgcDphbnkgKSB7ICB2YXIgeD1wWzBdLHk9cFsxXTsgIHJldHVybiBbeCptWzBdK3kqbVsyXSttWzRdLCAgIHgqbVsxXSt5Km1bM10rbVs1XV07ICB9LFxuXHRcdG11bHRBcnJheTogZnVuY3Rpb24obTphbnksIGE6YW55ICkgeyAgZm9yKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrPTIpIHsgIHZhciB4PWFbaV0seT1hW2krMV07ICBhW2ldPXgqbVswXSt5Km1bMl0rbVs0XTsgIGFbaSsxXT14Km1bMV0reSptWzNdK21bNV07ICB9ICB9XG5cdH1cblx0VURPQy5DID0ge1xuXHRcdHNyZ2JHYW1tYSA6IGZ1bmN0aW9uKHg6YW55KSB7ICByZXR1cm4geCA8IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMS4wIC8gMi40KSAtIDAuMDU1OyAgfSxcblx0XHRjbXlrVG9SZ2IgOiBmdW5jdGlvbihjbHI6YW55KSB7IFxuXHRcdFx0dmFyIGM9Y2xyWzBdLCBtPWNsclsxXSwgeT1jbHJbMl0sIGs9Y2xyWzNdO1xuXHRcdFx0Ly8gcmV0dXJuIFsxLU1hdGgubWluKDEsYytrKSwgMS1NYXRoLm1pbigxLCBtK2spLCAxLU1hdGgubWluKDEseStrKV07XG5cdFx0XHR2YXIgciA9IDI1NVxuXHRcdFx0KyBjICogKC00LjM4NzMzMjM4NDYwOTk4OCAgKiBjICsgNTQuNDg2MTUxOTQxODkxNzYgICogbSArICAxOC44MjI5MDUwMjE2NTMwMiAgKiB5ICsgMjEyLjI1NjYyNDUxNjM5NTg1ICogayArICAtMjg1LjIzMzEwMjYxMzcwMDQpIFxuXHRcdFx0KyBtICogKCAxLjcxNDk3NjM0NzczNjIxMzQgKiBtIC0gNS42MDk2NzM2OTA0MDQ3MzE1ICogeSArIC0xNy44NzM4NzA4NjE0MTU0NDQgKiBrIC0gNS40OTcwMDY0MjcxOTYzNjYpIFxuXHRcdFx0KyB5ICogKC0yLjUyMTczNDAxMzE2ODMwMzMgKiB5IC0gMjEuMjQ4OTIzMzM3MzUzMDczICogayArICAxNy41MTE5MjcwODQxODEzKSBcblx0XHRcdCsgayAqICgtMjEuODYxMjIxNDc0NjM2MDUgICogayAtIDE4OS40ODE4MDgzNTkyMjc0Nyk7XG5cdFx0XHR2YXIgZyA9IDI1NVxuXHRcdFx0KyBjICogKDguODQxMDQxNDIyMDM2MTQ5ICAgKiBjICsgNjAuMTE4MDI3MDQ1NTk3MzY2ICogbSArICA2Ljg3MTQyNTU5MjA0OTAwNyAgKiB5ICsgMzEuMTU5MTAwMTMwMDU1OTIyICogayArICAtNzkuMjk3MDg0NDgxNjU0OCkgXG5cdFx0XHQrIG0gKiAoLTE1LjMxMDM2MTMwNjk2NzgxNyAqIG0gKyAxNy41NzUyNTEyNjExMDk0ODIgKiB5ICsgIDEzMS4zNTI1MDkxMjQ5Mzk3NiAqIGsgLSAxOTAuOTQ1MzMwMjU4ODk1MSkgXG5cdFx0XHQrIHkgKiAoNC40NDQzMzkxMDI4NTI3MzkgICAqIHkgKyA5Ljg2MzI4NjE0OTM0MDUgICAgKiBrIC0gIDI0Ljg2NzQxNTgyNTU1ODc4KSBcblx0XHRcdCsgayAqICgtMjAuNzM3MzI1NDcxMTgxMDM0ICogayAtIDE4Ny44MDQ1MzcwOTcxOTU3OCk7XG5cdFx0XHR2YXIgYiA9IDI1NVxuXHRcdFx0KyBjICogKDAuODg0MjUyMjQzMDAwMzI5NiAgKiBjICsgOC4wNzg2Nzc1MDMxMTI5MjggICogbSArICAzMC44OTk3ODMwOTcwMzcyOSAgKiB5IC0gMC4yMzg4MzIzODY4OTE3ODkzNCAqIGsgKyAtMTQuMTgzNTc2Nzk5NjczMjg2KSBcblx0XHRcdCsgbSAqICgxMC40OTU5MzI3MzQzMjA3MiAgICogbSArIDYzLjAyMzc4NDk0NzU0MDUyICAqIHkgKyAgNTAuNjA2OTU3NjU2MzYwNzM0ICogayAtIDExMi4yMzg4NDI1MzcxOTI0OCkgXG5cdFx0XHQrIHkgKiAoMC4wMzI5NjA0MTExNDg3MzIxNyAqIHkgKyAxMTUuNjAzODQ0NDk2NDY2NDEgKiBrICsgLTE5My41ODIwOTM1Njg2MTUwNSlcblx0XHRcdCsgayAqICgtMjIuMzM4MTY4MDczMDk4ODYgICogayAtIDE4MC4xMjYxMzk3NDcwODM2Nyk7XG5cblx0XHRcdHJldHVybiBbTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgci8yNTUpKSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZy8yNTUpKSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYi8yNTUpKV07XG5cdFx0XHQvL3ZhciBpSyA9IDEtY1szXTsgIFxuXHRcdFx0Ly9yZXR1cm4gWygxLWNbMF0pKmlLLCAoMS1jWzFdKSppSywgKDEtY1syXSkqaUtdOyAgXG5cdFx0fSxcblx0XHRsYWJUb1JnYiAgOiBmdW5jdGlvbihsYWI6YW55KSB7XG5cdFx0XHR2YXIgayA9IDkwMy4zLCBlID0gMC4wMDg4NTYsIEwgPSBsYWJbMF0sIGEgPSBsYWJbMV0sIGIgPSBsYWJbMl07XG5cdFx0XHR2YXIgZnkgPSAoTCsxNikvMTE2LCBmeTMgPSBmeSpmeSpmeTtcblx0XHRcdHZhciBmeiA9IGZ5IC0gYi8yMDAsIGZ6MyA9IGZ6KmZ6KmZ6O1xuXHRcdFx0dmFyIGZ4ID0gYS81MDAgKyBmeSwgZngzID0gZngqZngqZng7XG5cdFx0XHR2YXIgenIgPSBmejM+ZSA/IGZ6MyA6ICgxMTYqZnotMTYpL2s7XG5cdFx0XHR2YXIgeXIgPSBmeTM+ZSA/IGZ5MyA6ICgxMTYqZnktMTYpL2s7XG5cdFx0XHR2YXIgeHIgPSBmeDM+ZSA/IGZ4MyA6ICgxMTYqZngtMTYpL2s7XG5cdFx0XHRcdFxuXHRcdFx0dmFyIFggPSB4cio5Ni43MiwgWSA9IHlyKjEwMCwgWiA9IHpyKjgxLjQyNywgeHl6ID0gW1gvMTAwLFkvMTAwLFovMTAwXTtcblx0XHRcdHZhciB4MnMgPSBbMy4xMzM4NTYxLCAtMS42MTY4NjY3LCAtMC40OTA2MTQ2LCAtMC45Nzg3Njg0LCAgMS45MTYxNDE1LCAgMC4wMzM0NTQwLCAwLjA3MTk0NTMsIC0wLjIyODk5MTQsICAxLjQwNTI0MjddO1xuXHRcdFx0XG5cdFx0XHR2YXIgcmdiID0gWyB4MnNbMF0qeHl6WzBdICsgeDJzWzFdKnh5elsxXSArIHgyc1syXSp4eXpbMl0sXG5cdFx0XHRcdFx0XHR4MnNbM10qeHl6WzBdICsgeDJzWzRdKnh5elsxXSArIHgyc1s1XSp4eXpbMl0sXG5cdFx0XHRcdFx0XHR4MnNbNl0qeHl6WzBdICsgeDJzWzddKnh5elsxXSArIHgyc1s4XSp4eXpbMl0gIF07XG5cdFx0XHRmb3IodmFyIGk9MDsgaTwzOyBpKyspIHJnYltpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIFVET0MuQy5zcmdiR2FtbWEocmdiW2ldKSkpO1xuXHRcdFx0cmV0dXJuIHJnYjtcblx0XHR9XG5cdH1cblx0XG5cdFVET0MuZ2V0U3RhdGUgPSBmdW5jdGlvbihjcmRzOmFueSk6YW55IHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Zm9udCA6IFVET0MuZ2V0Rm9udCgpLFxuXHRcdFx0ZGQ6IHtmbGF0OjF9LCAgLy8gZGV2aWNlLWRlcGVuZGVudFxuXHRcdFx0c3BhY2UgOlwiL0RldmljZUdyYXlcIixcblx0XHRcdC8vIGZpbGxcblx0XHRcdGNhOiAxLFxuXHRcdFx0Y29sciAgOiBbMCwwLDBdLFxuXHRcdFx0c3NwYWNlOlwiL0RldmljZUdyYXlcIixcblx0XHRcdC8vIHN0cm9rZVxuXHRcdFx0Q0E6IDEsXG5cdFx0XHRDT0xSIDogWzAsMCwwXSxcblx0XHRcdGJtb2RlOiBcIi9Ob3JtYWxcIixcblx0XHRcdFNBOmZhbHNlLCBPUE06MCwgQUlTOmZhbHNlLCBPUDpmYWxzZSwgb3A6ZmFsc2UsIFNNYXNrOlwiL05vbmVcIixcblx0XHRcdGx3aWR0aCA6IDEsXG5cdFx0XHRsY2FwOiAwLFxuXHRcdFx0bGpvaW46IDAsXG5cdFx0XHRtbGltaXQ6IDEwLFxuXHRcdFx0U00gOiAwLjEsXG5cdFx0XHRkb2ZmOiAwLFxuXHRcdFx0ZGFzaDogW10sXG5cdFx0XHRjdG0gOiBbMSwwLDAsMSwwLDBdLFxuXHRcdFx0Y3BvczogWzAsMF0sXG5cdFx0XHRwdGggOiB7Y21kczpbXSxjcmRzOltdfSwgXG5cdFx0XHRjcHRoOiBjcmRzID8gVURPQy5HLnJlY3RUb1BhdGgoY3JkcykgOiBudWxsICAvLyBjbGlwcGluZyBwYXRoXG5cdFx0fTtcblx0fVxuXHRcblx0VURPQy5nZXRGb250ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdFRjOiAwLCAvLyBjaGFyYWN0ZXIgc3BhY2luZ1xuXHRcdFx0VHc6IDAsIC8vIHdvcmQgc3BhY2luZ1xuXHRcdFx0VGg6MTAwLCAvLyBob3Jpem9udGFsIHNjYWxlXG5cdFx0XHRUbDogMCwgLy8gbGVhZGluZ1xuXHRcdFx0VGY6XCJIZWx2ZXRpY2EtQm9sZFwiLCBcblx0XHRcdFRmczoxLCAvLyBmb250IHNpemVcblx0XHRcdFRtb2RlOjAsIC8vIHJlbmRlcmluZyBtb2RlXG5cdFx0XHRUcmlzZTowLCAvLyByaXNlXG5cdFx0XHRUazogMCwgIC8vIGtub2Nrb3V0XG5cdFx0XHRUYWw6MCwgIC8vIGFsaWduLCAwOiBsZWZ0LCAxOiByaWdodCwgMjogY2VudGVyXG5cdFx0XHRUdW46MCwgIC8vIDA6IG5vLCAxOiB1bmRlcmxpbmVcblx0XHRcdFxuXHRcdFx0VG0gOlsxLDAsMCwxLDAsMF0sXG5cdFx0XHRUbG06WzEsMCwwLDEsMCwwXSxcblx0XHRcdFRybTpbMSwwLDAsMSwwLDBdXG5cdFx0fTtcblx0fVxuXG5cbmV4cG9ydCBsZXQgRnJvbUVNRjphbnkgPSBmdW5jdGlvbigpXG57XG59XG5cbkZyb21FTUYuUGFyc2UgPSBmdW5jdGlvbihidWZmOmFueSwgZ2VudjphbnkpXG57XG4gICAgYnVmZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpOyAgdmFyIG9mZj0wO1xuICAgIC8vY29uc29sZS5sb2coYnVmZi5zbGljZSgwLDMyKSk7XG4gICAgdmFyIHBybXM6YW55ID0ge2ZpbGw6ZmFsc2UsIHN0cms6ZmFsc2UsIGJiOlswLDAsMSwxXSwgd2JiOlswLDAsMSwxXSwgZm50OntuYW06XCJBcmlhbFwiLGhnaDoyNSx1bmQ6ZmFsc2Usb3JuOjB9LCB0Y2xyOlswLDAsMF0sIHRhbGc6MH0sIGdzdCwgdGFiID0gW10sIHN0cz1bXTtcbiAgICBcbiAgICB2YXIgckkgPSBGcm9tRU1GLkIucmVhZFNob3J0LCByVSA9IEZyb21FTUYuQi5yZWFkVXNob3J0LCBySTMyID0gRnJvbUVNRi5CLnJlYWRJbnQsIHJVMzIgPSBGcm9tRU1GLkIucmVhZFVpbnQsIHJGMzIgPSBGcm9tRU1GLkIucmVhZEZsb2F0O1x0XG4gICAgXG4gICAgdmFyIG9wbj0wO1xuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgdmFyIGZuYyA9IHJVMzIoYnVmZiwgb2ZmKTsgIG9mZis9NDtcbiAgICAgICAgdmFyIGZubSA9IEZyb21FTUYuS1tmbmNdOyBcbiAgICAgICAgdmFyIHNpeiA9IHJVMzIoYnVmZiwgb2ZmKTsgIG9mZis9NDtcbiAgICAgICAgXG4gICAgICAgIC8vaWYoZ3N0ICYmIGlzTmFOKGdzdC5jdG1bMF0pKSB0aHJvdyBcImVcIjtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhmbmMsZm5tLHNpeik7XG4gICAgICAgIFxuICAgICAgICB2YXIgbG9mZiA9IG9mZjtcbiAgICAgICAgXG4gICAgICAgIC8vaWYob3BuKys9PTI1MykgYnJlYWs7XG4gICAgICAgIHZhciBvYmo6YW55ID0gbnVsbCwgb2lkID0gMDtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhmbm0sIHNpeik7XG4gICAgICAgIFxuICAgICAgICBpZihmYWxzZSkge31cbiAgICAgICAgZWxzZSBpZihmbm09PVwiRU9GXCIpIHsgIGJyZWFrOyAgfVxuICAgICAgICBlbHNlIGlmKGZubT09XCJIRUFERVJcIikge1xuICAgICAgICAgICAgcHJtcy5iYiA9IEZyb21FTUYuX3JlYWRCb3goYnVmZixsb2ZmKTsgICBsb2ZmKz0xNjsgIC8vY29uc29sZS5sb2coZm5tLCBwcm1zLmJiKTtcbiAgICAgICAgICAgIGdlbnYuU3RhcnRQYWdlKHBybXMuYmJbMF0scHJtcy5iYlsxXSxwcm1zLmJiWzJdLHBybXMuYmJbM10pO1xuICAgICAgICAgICAgZ3N0ID0gVURPQy5nZXRTdGF0ZShwcm1zLmJiKTtcdFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNBVkVEQ1wiKSBzdHMucHVzaChKU09OLnN0cmluZ2lmeShnc3QpLCBKU09OLnN0cmluZ2lmeShwcm1zKSk7XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlJFU1RPUkVEQ1wiKSB7XG4gICAgICAgICAgICB2YXIgZGlmID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB3aGlsZShkaWY8LTEpIHsgIHN0cy5wb3AoKTsgIHN0cy5wb3AoKTsgIH1cbiAgICAgICAgICAgIHBybXMgPSBKU09OLnBhcnNlKHN0cy5wb3AoKSk7ICBnc3QgPSBKU09OLnBhcnNlKHN0cy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VMRUNUQ0xJUFBBVEhcIikgeyAgZ3N0LmNwdGggPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdzdC5wdGgpKTsgIH1cbiAgICAgICAgZWxzZSBpZihbXCJTRVRNQVBNT0RFXCIsXCJTRVRQT0xZRklMTE1PREVcIixcIlNFVEJLTU9ERVwiLyosXCJTRVRWSUVXUE9SVEVYVEVYXCIqLyxcIlNFVElDTU1PREVcIixcIlNFVFJPUDJcIixcIkVYVFNFTEVDVENMSVBSR05cIl0uaW5kZXhPZihmbm0pIT0tMSkge31cbiAgICAgICAgLy9lbHNlIGlmKGZubT09XCJJTlRFUlNFQ1RDTElQUkVDVFwiKSB7ICB2YXIgcj1wcm1zLmNyY3Q9RnJvbUVNRi5fcmVhZEJveChidWZmLCBsb2ZmKTsgIC8qdmFyIHkwPXJbMV0seTE9clszXTsgaWYoeTA+eTEpe3JbMV09eTE7IHJbM109eTA7fSovIGNvbnNvbGUubG9nKHBybXMuY3JjdCk7ICB9XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVE1JVEVSTElNSVRcIikgZ3N0Lm1saW1pdCA9IHJVMzIoYnVmZiwgbG9mZik7XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVFRFWFRDT0xPUlwiKSBwcm1zLnRjbHIgPSBbYnVmZltsb2ZmXS8yNTUsIGJ1ZmZbbG9mZisxXS8yNTUsIGJ1ZmZbbG9mZisyXS8yNTVdOyBcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VUVEVYVEFMSUdOXCIpIHBybXMudGFsZyA9IHJVMzIoYnVmZiwgbG9mZik7XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVFZJRVdQT1JURVhURVhcIiB8fCBmbm09PVwiU0VUVklFV1BPUlRPUkdFWFwiKSB7XG4gICAgICAgICAgICBpZihwcm1zLnZiYj09bnVsbCkgcHJtcy52YmI9W107XG4gICAgICAgICAgICB2YXIgY29mZiA9IGZubT09XCJTRVRWSUVXUE9SVE9SR0VYXCIgPyAwIDogMjtcbiAgICAgICAgICAgIHBybXMudmJiW2NvZmYgIF0gPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgIHBybXMudmJiW2NvZmYrMV0gPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocHJtcy52YmIpO1xuICAgICAgICAgICAgaWYoZm5tPT1cIlNFVFZJRVdQT1JURVhURVhcIikgRnJvbUVNRi5fdXBkYXRlQ3RtKHBybXMsIGdzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VUV0lORE9XRVhURVhcIiB8fCBmbm09PVwiU0VUV0lORE9XT1JHRVhcIikge1xuICAgICAgICAgICAgdmFyIGNvZmYgPSBmbm09PVwiU0VUV0lORE9XT1JHRVhcIiA/IDAgOiAyO1xuICAgICAgICAgICAgcHJtcy53YmJbY29mZiAgXSA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xuICAgICAgICAgICAgcHJtcy53YmJbY29mZisxXSA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xuICAgICAgICAgICAgaWYoZm5tPT1cIlNFVFdJTkRPV0VYVEVYXCIpIEZyb21FTUYuX3VwZGF0ZUN0bShwcm1zLCBnc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vZWxzZSBpZihmbm09PVwiU0VUTUVUQVJHTlwiKSB7fVxuICAgICAgICBlbHNlIGlmKGZubT09XCJDT01NRU5UXCIpIHsgIHZhciBkcyA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgfVxuICAgICAgICBcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VMRUNUT0JKRUNUXCIpIHtcbiAgICAgICAgICAgIHZhciBpbmQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaW5kLnRvU3RyaW5nKDE2KSwgdGFiLCB0YWJbaW5kXSk7XG4gICAgICAgICAgICBpZiAgICAgKGluZD09MHg4MDAwMDAwMCkgeyAgcHJtcy5maWxsPXRydWUgOyAgZ3N0LmNvbHI9WzEsMSwxXTsgIH0gLy8gd2hpdGUgYnJ1c2hcbiAgICAgICAgICAgIGVsc2UgaWYoaW5kPT0weDgwMDAwMDA1KSB7ICBwcm1zLmZpbGw9ZmFsc2U7ICB9IC8vIG51bGwgYnJ1c2hcbiAgICAgICAgICAgIGVsc2UgaWYoaW5kPT0weDgwMDAwMDA3KSB7ICBwcm1zLnN0cms9dHJ1ZSA7ICBwcm1zLmx3aWR0aD0xOyAgZ3N0LkNPTFI9WzAsMCwwXTsgIH0gLy8gYmxhY2sgcGVuXG4gICAgICAgICAgICBlbHNlIGlmKGluZD09MHg4MDAwMDAwOCkgeyAgcHJtcy5zdHJrPWZhbHNlOyAgfSAvLyBudWxsICBwZW5cbiAgICAgICAgICAgIGVsc2UgaWYoaW5kPT0weDgwMDAwMDBkKSB7fSAvLyBzeXN0ZW0gZm9udFxuICAgICAgICAgICAgZWxzZSBpZihpbmQ9PTB4ODAwMDAwMGUpIHt9ICAvLyBkZXZpY2UgZGVmYXVsdCBmb250XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY286YW55ID0gdGFiW2luZF07ICAvL2NvbnNvbGUubG9nKGluZCwgY28pO1xuICAgICAgICAgICAgICAgIGlmKGNvLnQ9PVwiYlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBybXMuZmlsbD1jby5zdGwhPTE7XG4gICAgICAgICAgICAgICAgICAgIGlmICAgICAoY28uc3RsPT0wKSB7fVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNvLnN0bD09MSkge31cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBjby5zdGwrXCIgZVwiO1xuICAgICAgICAgICAgICAgICAgICBnc3QuY29scj1jby5jbHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY28udD09XCJwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJtcy5zdHJrPWNvLnN0bCE9NTtcbiAgICAgICAgICAgICAgICAgICAgZ3N0Lmx3aWR0aCA9IGNvLndpZDtcbiAgICAgICAgICAgICAgICAgICAgZ3N0LkNPTFI9Y28uY2xyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGNvLnQ9PVwiZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBybXMuZm50ID0gY287XG4gICAgICAgICAgICAgICAgICAgIGdzdC5mb250LlRmID0gY28ubmFtO1xuICAgICAgICAgICAgICAgICAgICBnc3QuZm9udC5UZnMgPSBNYXRoLmFicyhjby5oZ2gpO1xuICAgICAgICAgICAgICAgICAgICBnc3QuZm9udC5UdW4gPSBjby51bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgXCJlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihmbm09PVwiREVMRVRFT0JKRUNUXCIpIHtcbiAgICAgICAgICAgIHZhciBpbmQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgIGlmKHRhYltpbmRdIT1udWxsKSB0YWJbaW5kXT1udWxsO1xuICAgICAgICAgICAgZWxzZSB0aHJvdyBcImVcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGZubT09XCJDUkVBVEVCUlVTSElORElSRUNUXCIpIHtcbiAgICAgICAgICAgIG9pZCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xuICAgICAgICAgICAgb2JqID0ge3Q6XCJiXCJ9O1xuICAgICAgICAgICAgb2JqLnN0bCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xuICAgICAgICAgICAgb2JqLmNsciA9IFtidWZmW2xvZmZdLzI1NSwgYnVmZltsb2ZmKzFdLzI1NSwgYnVmZltsb2ZmKzJdLzI1NV07ICBsb2ZmKz00O1xuICAgICAgICAgICAgb2JqLmh0YyA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhvaWQsIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihmbm09PVwiQ1JFQVRFUEVOXCIgfHwgZm5tPT1cIkVYVENSRUFURVBFTlwiKSB7XG4gICAgICAgICAgICBvaWQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgIG9iaiA9IHt0OlwicFwifTtcbiAgICAgICAgICAgIGlmKGZubT09XCJFWFRDUkVBVEVQRU5cIikge1xuICAgICAgICAgICAgICAgIGxvZmYrPTE2O1xuICAgICAgICAgICAgICAgIG9iai5zdGwgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgICAgICBvYmoud2lkID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICAgICAgLy9vYmouc3RsID0gclUzMihidWZmLCBsb2ZmKTsgIFxuICAgICAgICAgICAgICAgIGxvZmYrPTQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iai5zdGwgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgICAgICBvYmoud2lkID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICBsb2ZmKz00O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqLmNsciA9IFtidWZmW2xvZmZdLzI1NSwgYnVmZltsb2ZmKzFdLzI1NSwgYnVmZltsb2ZmKzJdLzI1NV07ICBsb2ZmKz00O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkVYVENSRUFURUZPTlRJTkRJUkVDVFdcIikge1xuICAgICAgICAgICAgb2lkID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICBvYmogPSB7dDpcImZcIiwgbmFtOlwiXCJ9O1xuICAgICAgICAgICAgb2JqLmhnaCA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmICs9IDQ7XG4gICAgICAgICAgICBsb2ZmICs9IDQqMjtcbiAgICAgICAgICAgIG9iai5vcm4gPSBySTMyKGJ1ZmYsIGxvZmYpLzEwOyAgbG9mZis9NDtcbiAgICAgICAgICAgIHZhciB3Z2ggPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIC8vY29uc29sZS5sb2coZm5tLCBvYmoub3JuLCB3Z2gpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyVTMyKGJ1ZmYsbG9mZiksIHJVMzIoYnVmZixsb2ZmKzQpLCBidWZmLnNsaWNlKGxvZmYsbG9mZis4KSk7XG4gICAgICAgICAgICBvYmoudW5kID0gYnVmZltsb2ZmKzFdOyAgb2JqLnN0ayA9IGJ1ZmZbbG9mZisyXTsgIGxvZmYgKz0gNCoyO1xuICAgICAgICAgICAgd2hpbGUoclUoYnVmZixsb2ZmKSE9MCkgeyAgb2JqLm5hbSs9U3RyaW5nLmZyb21DaGFyQ29kZShyVShidWZmLGxvZmYpKTsgIGxvZmYrPTI7ICB9XG4gICAgICAgICAgICBpZih3Z2g+NTAwKSBvYmoubmFtKz1cIi1Cb2xkXCI7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHdnaCwgb2JqLm5hbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihmbm09PVwiRVhUVEVYVE9VVFdcIikge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhidWZmLnNsaWNlKGxvZmYtOCwgbG9mZi04K3NpeikpO1xuICAgICAgICAgICAgbG9mZis9MTY7XG4gICAgICAgICAgICB2YXIgbW9kID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICAvL2NvbnNvbGUubG9nKG1vZCk7XG4gICAgICAgICAgICB2YXIgc2N4ID0gckYzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgc2N5ID0gckYzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgcmZ4ID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgcmZ5ID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG1vZCwgc2N4LCBzY3kscmZ4LHJmeSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdzdC5mb250LlRtID0gWzEsMCwwLC0xLDAsMF07XG4gICAgICAgICAgICBVRE9DLk0ucm90YXRlKGdzdC5mb250LlRtLCBwcm1zLmZudC5vcm4qTWF0aC5QSS8xODApO1xuICAgICAgICAgICAgVURPQy5NLnRyYW5zbGF0ZShnc3QuZm9udC5UbSwgcmZ4LCByZnkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYWxnID0gcHJtcy50YWxnOyAgLy9jb25zb2xlLmxvZyhhbGcudG9TdHJpbmcoMikpO1xuICAgICAgICAgICAgaWYgICAgICgoYWxnJjYpPT02KSBnc3QuZm9udC5UYWwgPSAyO1xuICAgICAgICAgICAgZWxzZSBpZigoYWxnJjcpPT0wKSBnc3QuZm9udC5UYWwgPSAwO1xuICAgICAgICAgICAgZWxzZSB0aHJvdyBhbGcrXCIgZVwiO1xuICAgICAgICAgICAgaWYoKGFsZyYyNCk9PTI0KSB7fSAgLy8gYmFzZWxpbmVcbiAgICAgICAgICAgIGVsc2UgaWYoKGFsZyYyNCk9PTApIFVET0MuTS50cmFuc2xhdGUoZ3N0LmZvbnQuVG0sIDAsIGdzdC5mb250LlRmcyk7XG4gICAgICAgICAgICBlbHNlIHRocm93IFwiZVwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjcnMgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgIHZhciBvZnMgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgIHZhciBvcHMgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIC8vaWYob3BzIT0wKSB0aHJvdyBcImVcIjtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cob2ZzLG9wcyxjcnMpO1xuICAgICAgICAgICAgbG9mZis9MTY7XG4gICAgICAgICAgICB2YXIgb2ZEID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICAvL2NvbnNvbGUubG9nKG9wcywgb2ZELCBsb2ZmLCBvZnMrb2ZmLTgpO1xuICAgICAgICAgICAgb2ZzICs9IG9mZi04OyAgLy9jb25zb2xlLmxvZyhjcnMsIG9wcyk7XG4gICAgICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGNyczsgaSsrKSB7ICB2YXIgY2M9clUoYnVmZixvZnMraSoyKTsgIHN0cis9U3RyaW5nLmZyb21DaGFyQ29kZShjYyk7ICB9O1xuICAgICAgICAgICAgdmFyIG9jbHIgPSBnc3QuY29scjsgIGdzdC5jb2xyID0gcHJtcy50Y2xyO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdHIsIGdzdC5jb2xyLCBnc3QuZm9udC5UbSk7XG4gICAgICAgICAgICAvL3ZhciBvdGZzID0gZ3N0LmZvbnQuVGZzOyAgZ3N0LmZvbnQuVGZzICo9IDEvZ3N0LmN0bVswXTtcbiAgICAgICAgICAgIGdlbnYuUHV0VGV4dChnc3QsIHN0ciwgc3RyLmxlbmd0aCpnc3QuZm9udC5UZnMqMC41KTsgIGdzdC5jb2xyPW9jbHI7XG4gICAgICAgICAgICAvL2dzdC5mb250LlRmcyA9IG90ZnM7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJmeCwgcmZ5LCBzY3gsIG9wcywgcmNYLCByY1ksIHJjVywgcmNILCBvZmZEeCwgc3RyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGZubT09XCJCRUdJTlBBVEhcIikgeyAgVURPQy5HLm5ld1BhdGgoZ3N0KTsgIH1cbiAgICAgICAgZWxzZSBpZihmbm09PVwiRU5EUEFUSFwiICApIHsgICAgfVxuICAgICAgICBlbHNlIGlmKGZubT09XCJDTE9TRUZJR1VSRVwiKSBVRE9DLkcuY2xvc2VQYXRoKGdzdCk7XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIk1PVkVUT0VYXCIgKSB7ICBVRE9DLkcubW92ZVRvKGdzdCwgckkzMihidWZmLGxvZmYpLCBySTMyKGJ1ZmYsbG9mZis0KSk7ICB9XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkxJTkVUT1wiICAgKSB7ICBcbiAgICAgICAgICAgIGlmKGdzdC5wdGguY21kcy5sZW5ndGg9PTApIHsgIHZhciBpbT1nc3QuY3RtLnNsaWNlKDApOyAgVURPQy5NLmludmVydChpbSk7ICB2YXIgcCA9IFVET0MuTS5tdWx0UG9pbnQoaW0sIGdzdC5jcG9zKTsgIFVET0MuRy5tb3ZlVG8oZ3N0LCBwWzBdLCBwWzFdKTsgIH0gIFxuICAgICAgICAgICAgVURPQy5HLmxpbmVUbyhnc3QsIHJJMzIoYnVmZixsb2ZmKSwgckkzMihidWZmLGxvZmYrNCkpOyAgfVxuICAgICAgICBlbHNlIGlmKGZubT09XCJQT0xZR09OXCIgfHwgZm5tPT1cIlBPTFlHT04xNlwiIHx8IGZubT09XCJQT0xZTElORVwiIHx8IGZubT09XCJQT0xZTElORTE2XCIgfHwgZm5tPT1cIlBPTFlMSU5FVE9cIiB8fCBmbm09PVwiUE9MWUxJTkVUTzE2XCIpIHtcbiAgICAgICAgICAgIGxvZmYrPTE2O1xuICAgICAgICAgICAgdmFyIG5kZiA9IGZubS5zdGFydHNXaXRoKFwiUE9MWUdPTlwiKSwgaXNUbyA9IGZubS5pbmRleE9mKFwiVE9cIikhPS0xO1xuICAgICAgICAgICAgdmFyIGNudCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xuICAgICAgICAgICAgaWYoIWlzVG8pIFVET0MuRy5uZXdQYXRoKGdzdCk7XG4gICAgICAgICAgICBsb2ZmID0gRnJvbUVNRi5fZHJhd1BvbHkoYnVmZixsb2ZmLGNudCxnc3QsIGZubS5lbmRzV2l0aChcIjE2XCIpPzI6NCwgIG5kZiwgaXNUbyk7XG4gICAgICAgICAgICBpZighaXNUbykgRnJvbUVNRi5fZHJhdyhnZW52LGdzdCxwcm1zLCBuZGYpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwcm1zLCBnc3QubHdpZHRoKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnc3QucHRoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlBPTFlQT0xZR09OMTZcIikge1xuICAgICAgICAgICAgbG9mZis9MTY7XG4gICAgICAgICAgICB2YXIgbmRmID0gZm5tLnN0YXJ0c1dpdGgoXCJQT0xZUE9MWUdPTlwiKSwgaXNUbyA9IGZubS5pbmRleE9mKFwiVE9cIikhPS0xO1xuICAgICAgICAgICAgdmFyIG5vcCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgbG9mZis9NDtcbiAgICAgICAgICAgIHZhciBwaSA9IGxvZmY7ICBsb2ZmKz0gbm9wKjQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCFpc1RvKSBVRE9DLkcubmV3UGF0aChnc3QpO1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8bm9wOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHBwID0gclUoYnVmZiwgcGkraSo0KTtcbiAgICAgICAgICAgICAgICBsb2ZmID0gRnJvbUVNRi5fZHJhd1BvbHkoYnVmZixsb2ZmLHBwcCxnc3QsIGZubS5lbmRzV2l0aChcIjE2XCIpPzI6NCwgbmRmLCBpc1RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFpc1RvKSBGcm9tRU1GLl9kcmF3KGdlbnYsZ3N0LHBybXMsIG5kZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihmbm09PVwiUE9MWUJFWklFUlwiIHx8IGZubT09XCJQT0xZQkVaSUVSMTZcIiB8fCBmbm09PVwiUE9MWUJFWklFUlRPXCIgfHwgZm5tPT1cIlBPTFlCRVpJRVJUTzE2XCIpIHtcbiAgICAgICAgICAgIGxvZmYrPTE2O1xuICAgICAgICAgICAgdmFyIGlzMTYgPSBmbm0uZW5kc1dpdGgoXCIxNlwiKSwgckMgPSBpczE2P3JJOnJJMzIsIG5sID0gaXMxNj8yOjQ7XG4gICAgICAgICAgICB2YXIgY250ID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICBpZihmbm0uaW5kZXhPZihcIlRPXCIpPT0tMSkge1xuICAgICAgICAgICAgICAgIFVET0MuRy5tb3ZlVG8oZ3N0LCByQyhidWZmLGxvZmYpLCByQyhidWZmLGxvZmYrbmwpKTsgIGxvZmYrPTIqbmw7ICBjbnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlKGNudD4wKSB7XG4gICAgICAgICAgICAgICAgVURPQy5HLmN1cnZlVG8oZ3N0LCByQyhidWZmLGxvZmYpLCByQyhidWZmLGxvZmYrbmwpLCByQyhidWZmLGxvZmYrMipubCksIHJDKGJ1ZmYsbG9mZiszKm5sKSwgckMoYnVmZixsb2ZmKzQqbmwpLCByQyhidWZmLGxvZmYrNSpubCkgKTtcbiAgICAgICAgICAgICAgICBsb2ZmKz02Km5sO1xuICAgICAgICAgICAgICAgIGNudC09MztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnc3QucHRoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlJFQ1RBTkdMRVwiIHx8IGZubT09XCJFTExJUFNFXCIpIHtcbiAgICAgICAgICAgIFVET0MuRy5uZXdQYXRoKGdzdCk7XG4gICAgICAgICAgICB2YXIgYnggPSBGcm9tRU1GLl9yZWFkQm94KGJ1ZmYsIGxvZmYpO1xuICAgICAgICAgICAgaWYoZm5tPT1cIlJFQ1RBTkdMRVwiKSB7XG4gICAgICAgICAgICAgICAgVURPQy5HLm1vdmVUbyhnc3QsIGJ4WzBdLGJ4WzFdKTtcbiAgICAgICAgICAgICAgICBVRE9DLkcubGluZVRvKGdzdCwgYnhbMl0sYnhbMV0pO1xuICAgICAgICAgICAgICAgIFVET0MuRy5saW5lVG8oZ3N0LCBieFsyXSxieFszXSk7XG4gICAgICAgICAgICAgICAgVURPQy5HLmxpbmVUbyhnc3QsIGJ4WzBdLGJ4WzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gKGJ4WzBdK2J4WzJdKS8yLCB5ID0gKGJ4WzFdK2J4WzNdKS8yO1xuICAgICAgICAgICAgICAgIFVET0MuRy5hcmMoZ3N0LHgseSwoYnhbMl0tYnhbMF0pLzIsMCwyKk1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFVET0MuRy5jbG9zZVBhdGgoZ3N0KTtcbiAgICAgICAgICAgIEZyb21FTUYuX2RyYXcoZ2Vudixnc3QscHJtcywgdHJ1ZSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBybXMsIGdzdC5sd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkZJTExQQVRIXCIgICkgZ2Vudi5GaWxsKGdzdCwgZmFsc2UpO1xuICAgICAgICBlbHNlIGlmKGZubT09XCJTVFJPS0VQQVRIXCIpIGdlbnYuU3Ryb2tlKGdzdCk7XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNUUk9LRUFOREZJTExQQVRIXCIpIHsgIGdlbnYuRmlsbChnc3QsIGZhbHNlKTsgIGdlbnYuU3Ryb2tlKGdzdCk7ICB9XG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVFdPUkxEVFJBTlNGT1JNXCIgfHwgZm5tPT1cIk1PRElGWVdPUkxEVFJBTlNGT1JNXCIpIHtcbiAgICAgICAgICAgIHZhciBtYXQgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPDY7IGkrKykgbWF0LnB1c2gockYzMihidWZmLGxvZmYraSo0KSk7ICBsb2ZmKz0yNDtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZm5tLCBnc3QuY3RtLnNsaWNlKDApLCBtYXQpO1xuICAgICAgICAgICAgaWYoZm5tPT1cIlNFVFdPUkxEVFJBTlNGT1JNXCIpIGdzdC5jdG09bWF0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZCA9IHJVMzIoYnVmZixsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICAgICAgaWYobW9kPT0yKSB7ICB2YXIgb209Z3N0LmN0bTsgIGdzdC5jdG09bWF0OyAgVURPQy5NLmNvbmNhdChnc3QuY3RtLCBvbSk7ICB9XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBcImVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRVRTVFJFVENIQkxUTU9ERVwiKSB7ICB2YXIgc20gPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIH1cbiAgICAgICAgZWxzZSBpZihmbm09PVwiU1RSRVRDSERJQklUU1wiKSB7XG4gICAgICAgICAgICB2YXIgYnggPSBGcm9tRU1GLl9yZWFkQm94KGJ1ZmYsIGxvZmYpOyAgbG9mZis9MTY7XG4gICAgICAgICAgICB2YXIgeEQgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgIHZhciB5RCA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xuICAgICAgICAgICAgdmFyIHhTID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgeVMgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcbiAgICAgICAgICAgIHZhciB3UyA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xuICAgICAgICAgICAgdmFyIGhTID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgb2ZIID0gclUzMihidWZmLCBsb2ZmKStvZmYtODsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgc3pIID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgb2ZCID0gclUzMihidWZmLCBsb2ZmKStvZmYtODsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgc3pCID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgdXNnID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICBpZih1c2chPTApIHRocm93IFwiZVwiO1xuICAgICAgICAgICAgdmFyIGJvcCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xuICAgICAgICAgICAgdmFyIHdEID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XG4gICAgICAgICAgICB2YXIgaEQgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIC8vY29uc29sZS5sb2coYm9wLCB3RCwgaEQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG9mSCwgc3pILCBvZkIsIHN6Qiwgb2ZIKzQwKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYngsIHhELHlELHdELGhEKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coeFMseVMsd1MsaFMpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhvZkgsc3pILG9mQixzekIsdXNnLGJvcCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBobCA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcbiAgICAgICAgICAgIHZhciB3ICA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcbiAgICAgICAgICAgIHZhciBoICA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDsgIGlmKHchPXdTIHx8IGghPWhTKSB0aHJvdyBcImVcIjtcbiAgICAgICAgICAgIHZhciBwcyA9IHJVICAoYnVmZiwgb2ZIKTsgIG9mSCs9MjtcbiAgICAgICAgICAgIHZhciBiYyA9IHJVICAoYnVmZiwgb2ZIKTsgIG9mSCs9MjsgIGlmKGJjIT04ICYmIGJjIT0yNCAmJiBiYyE9MzIpIHRocm93IGJjK1wiIGVcIjtcbiAgICAgICAgICAgIHZhciBjcHI9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDsgIGlmKGNwciE9MCkgdGhyb3cgY3ByK1wiIGVcIjtcbiAgICAgICAgICAgIHZhciBzeiA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcbiAgICAgICAgICAgIHZhciB4cG09IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcbiAgICAgICAgICAgIHZhciB5cG09IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcbiAgICAgICAgICAgIHZhciBjdSA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcbiAgICAgICAgICAgIHZhciBjaSA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDsgIC8vY29uc29sZS5sb2coaGwsIHcsIGgsIHBzLCBiYywgY3ByLCBzeiwgeHBtLCB5cG0sIGN1LCBjaSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaGwsdyxoLFwiLFwiLHhTLHlTLHdTLGhTLFwiLFwiLHhELHlELHdELGhELFwiLFwiLHhwbSx5cG0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcmwgPSBNYXRoLmZsb29yKCgodyAqIHBzICogYmMgKyAzMSkgJiB+MzEpIC8gOCk7XG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkodypoKjQpO1xuICAgICAgICAgICAgaWYoYmM9PTgpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIHk9MDsgeTxoOyB5KyspIFxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxaSA9ICh5KncreCk8PDIsIGluZDphbnkgPSBidWZmW29mQisoaC0xLXkpKnJsK3hdPDwyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpICBdID0gYnVmZltvZkgraW5kKzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzFdID0gYnVmZltvZkgraW5kKzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzJdID0gYnVmZltvZkgraW5kKzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzNdID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihiYz09MjQpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIHk9MDsgeTxoOyB5KyspIFxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxaSA9ICh5KncreCk8PDIsIHRpPW9mQisoaC0xLXkpKnJsK3gqMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSAgXSA9IGJ1ZmZbdGkrMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrMV0gPSBidWZmW3RpKzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzJdID0gYnVmZlt0aSswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSszXSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoYmM9PTMyKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSBcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcWkgPSAoeSp3K3gpPDwyLCB0aT1vZkIrKGgtMS15KSpybCt4KjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkgIF0gPSBidWZmW3RpKzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzFdID0gYnVmZlt0aSsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSsyXSA9IGJ1ZmZbdGkrMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrM10gPSBidWZmW3RpKzNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjdG0gPSBnc3QuY3RtLnNsaWNlKDApO1xuICAgICAgICAgICAgZ3N0LmN0bSA9IFsxLDAsMCwxLDAsMF07XG4gICAgICAgICAgICBVRE9DLk0uc2NhbGUoZ3N0LmN0bSwgd0QsIC1oRCk7XG4gICAgICAgICAgICBVRE9DLk0udHJhbnNsYXRlKGdzdC5jdG0sIHhELCB5RCtoRCk7XG4gICAgICAgICAgICBVRE9DLk0uY29uY2F0KGdzdC5jdG0sIGN0bSk7XG4gICAgICAgICAgICBnZW52LlB1dEltYWdlKGdzdCwgaW1nLCB3LCBoKTtcbiAgICAgICAgICAgIGdzdC5jdG0gPSBjdG07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhmbm0sIHNpeik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKG9iaiE9bnVsbCkgdGFiW29pZF09b2JqO1xuICAgICAgICBcbiAgICAgICAgb2ZmKz1zaXotODtcbiAgICB9XG4gICAgLy9nZW52LlN0cm9rZShnc3QpO1xuICAgIGdlbnYuU2hvd1BhZ2UoKTsgIGdlbnYuRG9uZSgpO1xufVxuRnJvbUVNRi5fcmVhZEJveCA9IGZ1bmN0aW9uKGJ1ZmY6YW55LCBvZmY6YW55KSB7ICB2YXIgYj1bXTsgIGZvcih2YXIgaT0wOyBpPDQ7IGkrKykgYltpXSA9IEZyb21FTUYuQi5yZWFkSW50KGJ1ZmYsb2ZmK2kqNCk7ICByZXR1cm4gYjsgIH1cdFxuXG5Gcm9tRU1GLl91cGRhdGVDdG0gPSBmdW5jdGlvbihwcm1zOmFueSwgZ3N0OmFueSkge1xuICAgIHZhciBtYXQgPSBbMSwwLDAsMSwwLDBdO1xuICAgIHZhciB3YmIgPSBwcm1zLndiYiwgYmIgPSBwcm1zLmJiLCB2YmI9KHBybXMudmJiICYmIHBybXMudmJiLmxlbmd0aD09NCkgPyBwcm1zLnZiYjpwcm1zLmJiO1xuICAgIFxuICAgIC8vdmFyIHkwID0gYmJbMV0sIHkxID0gYmJbM107ICBiYlsxXT1NYXRoLm1pbih5MCx5MSk7ICBiYlszXT1NYXRoLm1heCh5MCx5MSk7XG4gICAgXG4gICAgVURPQy5NLnRyYW5zbGF0ZShtYXQsIC13YmJbMF0sLXdiYlsxXSk7XG4gICAgVURPQy5NLnNjYWxlKG1hdCwgMS93YmJbMl0sIDEvd2JiWzNdKTtcbiAgICBcbiAgICBVRE9DLk0uc2NhbGUobWF0LCB2YmJbMl0sIHZiYlszXSk7XG4gICAgLy9VRE9DLk0uc2NhbGUobWF0LCB2YmJbMl0vKGJiWzJdLWJiWzBdKSwgdmJiWzNdLyhiYlszXS1iYlsxXSkpO1xuICAgIFxuICAgIC8vVURPQy5NLnNjYWxlKG1hdCwgYmJbMl0tYmJbMF0sYmJbM10tYmJbMV0pO1xuICAgIFxuICAgIGdzdC5jdG0gPSBtYXQ7XG59XG5Gcm9tRU1GLl9kcmF3ID0gZnVuY3Rpb24oZ2VudjphbnksIGdzdDphbnksIHBybXM6YW55LCBuZWVkRmlsbDphbnkpIHtcbiAgICBpZihwcm1zLmZpbGwgJiYgbmVlZEZpbGwgICAgICkgZ2Vudi5GaWxsICAoZ3N0LCBmYWxzZSk7XG4gICAgaWYocHJtcy5zdHJrICYmIGdzdC5sd2lkdGghPTApIGdlbnYuU3Ryb2tlKGdzdCk7XG59XG5Gcm9tRU1GLl9kcmF3UG9seSA9IGZ1bmN0aW9uKGJ1ZmY6YW55LCBvZmY6YW55LCBwcHA6YW55LCBnc3Q6YW55LCBubDphbnksIGNsb3M6YW55LCBqdXN0TGluZTphbnkpIHtcbiAgICB2YXIgclMgPSBubD09MiA/IEZyb21FTUYuQi5yZWFkU2hvcnQgOiBGcm9tRU1GLkIucmVhZEludDtcbiAgICBmb3IodmFyIGo9MDsgajxwcHA7IGorKykge1xuICAgICAgICB2YXIgcHggPSByUyhidWZmLCBvZmYpOyAgb2ZmKz1ubDsgIFxuICAgICAgICB2YXIgcHkgPSByUyhidWZmLCBvZmYpOyAgb2ZmKz1ubDtcbiAgICAgICAgaWYoaj09MCAmJiAhanVzdExpbmUpIFVET0MuRy5tb3ZlVG8oZ3N0LHB4LHB5KTsgIGVsc2UgVURPQy5HLmxpbmVUbyhnc3QscHgscHkpO1xuICAgIH1cbiAgICBpZihjbG9zKSBVRE9DLkcuY2xvc2VQYXRoKGdzdCk7XG4gICAgcmV0dXJuIG9mZjtcbn1cblxuRnJvbUVNRi5CID0ge1xuICAgIHVpbnQ4IDogbmV3IFVpbnQ4QXJyYXkoNCksXG4gICAgcmVhZFNob3J0ICA6IGZ1bmN0aW9uKGJ1ZmY6YW55LHA6YW55KTphbnkgIHsgIHZhciB1OD1Gcm9tRU1GLkIudWludDg7ICB1OFswXT1idWZmW3BdOyAgdThbMV09YnVmZltwKzFdOyAgcmV0dXJuIEZyb21FTUYuQi5pbnQxNiBbMF07ICB9LFxuICAgIHJlYWRVc2hvcnQgOiBmdW5jdGlvbihidWZmOmFueSxwOmFueSk6YW55ICB7ICB2YXIgdTg9RnJvbUVNRi5CLnVpbnQ4OyAgdThbMF09YnVmZltwXTsgIHU4WzFdPWJ1ZmZbcCsxXTsgIHJldHVybiBGcm9tRU1GLkIudWludDE2WzBdOyAgfSxcbiAgICByZWFkSW50ICAgIDogZnVuY3Rpb24oYnVmZjphbnkscDphbnkpOmFueSAgeyAgdmFyIHU4PUZyb21FTUYuQi51aW50ODsgIHU4WzBdPWJ1ZmZbcF07ICB1OFsxXT1idWZmW3ArMV07ICB1OFsyXT1idWZmW3ArMl07ICB1OFszXT1idWZmW3ArM107ICByZXR1cm4gRnJvbUVNRi5CLmludDMyIFswXTsgIH0sXG4gICAgcmVhZFVpbnQgICA6IGZ1bmN0aW9uKGJ1ZmY6YW55LHA6YW55KTphbnkgIHsgIHZhciB1OD1Gcm9tRU1GLkIudWludDg7ICB1OFswXT1idWZmW3BdOyAgdThbMV09YnVmZltwKzFdOyAgdThbMl09YnVmZltwKzJdOyAgdThbM109YnVmZltwKzNdOyAgcmV0dXJuIEZyb21FTUYuQi51aW50MzJbMF07ICB9LFxuICAgIHJlYWRGbG9hdCAgOiBmdW5jdGlvbihidWZmOmFueSxwOmFueSk6YW55ICB7ICB2YXIgdTg9RnJvbUVNRi5CLnVpbnQ4OyAgdThbMF09YnVmZltwXTsgIHU4WzFdPWJ1ZmZbcCsxXTsgIHU4WzJdPWJ1ZmZbcCsyXTsgIHU4WzNdPWJ1ZmZbcCszXTsgIHJldHVybiBGcm9tRU1GLkIuZmxvdDMyWzBdOyAgfSxcbiAgICByZWFkQVNDSUkgIDogZnVuY3Rpb24oYnVmZjphbnkscDphbnksbDphbnkpOmFueSB7ICB2YXIgcyA9IFwiXCI7ICBmb3IodmFyIGk9MDsgaTxsOyBpKyspIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmW3AraV0pOyAgcmV0dXJuIHM7ICAgIH1cbn1cbkZyb21FTUYuQi5pbnQxNiAgPSBuZXcgSW50MTZBcnJheSAoRnJvbUVNRi5CLnVpbnQ4LmJ1ZmZlcik7XG5Gcm9tRU1GLkIudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KEZyb21FTUYuQi51aW50OC5idWZmZXIpO1xuRnJvbUVNRi5CLmludDMyICA9IG5ldyBJbnQzMkFycmF5IChGcm9tRU1GLkIudWludDguYnVmZmVyKTtcbkZyb21FTUYuQi51aW50MzIgPSBuZXcgVWludDMyQXJyYXkoRnJvbUVNRi5CLnVpbnQ4LmJ1ZmZlcik7XG5Gcm9tRU1GLkIuZmxvdDMyID0gbmV3IEZsb2F0MzJBcnJheShGcm9tRU1GLkIudWludDguYnVmZmVyKTtcblxuXG5Gcm9tRU1GLkMgPSB7XG4gICAgRU1SX0hFQURFUiA6IDB4MDAwMDAwMDEsXG4gICAgRU1SX1BPTFlCRVpJRVIgOiAweDAwMDAwMDAyLFxuICAgIEVNUl9QT0xZR09OIDogMHgwMDAwMDAwMyxcbiAgICBFTVJfUE9MWUxJTkUgOiAweDAwMDAwMDA0LFxuICAgIEVNUl9QT0xZQkVaSUVSVE8gOiAweDAwMDAwMDA1LFxuICAgIEVNUl9QT0xZTElORVRPIDogMHgwMDAwMDAwNixcbiAgICBFTVJfUE9MWVBPTFlMSU5FIDogMHgwMDAwMDAwNyxcbiAgICBFTVJfUE9MWVBPTFlHT04gOiAweDAwMDAwMDA4LFxuICAgIEVNUl9TRVRXSU5ET1dFWFRFWCA6IDB4MDAwMDAwMDksXG4gICAgRU1SX1NFVFdJTkRPV09SR0VYIDogMHgwMDAwMDAwQSxcbiAgICBFTVJfU0VUVklFV1BPUlRFWFRFWCA6IDB4MDAwMDAwMEIsXG4gICAgRU1SX1NFVFZJRVdQT1JUT1JHRVggOiAweDAwMDAwMDBDLFxuICAgIEVNUl9TRVRCUlVTSE9SR0VYIDogMHgwMDAwMDAwRCxcbiAgICBFTVJfRU9GIDogMHgwMDAwMDAwRSxcbiAgICBFTVJfU0VUUElYRUxWIDogMHgwMDAwMDAwRixcbiAgICBFTVJfU0VUTUFQUEVSRkxBR1MgOiAweDAwMDAwMDEwLFxuICAgIEVNUl9TRVRNQVBNT0RFIDogMHgwMDAwMDAxMSxcbiAgICBFTVJfU0VUQktNT0RFIDogMHgwMDAwMDAxMixcbiAgICBFTVJfU0VUUE9MWUZJTExNT0RFIDogMHgwMDAwMDAxMyxcbiAgICBFTVJfU0VUUk9QMiA6IDB4MDAwMDAwMTQsXG4gICAgRU1SX1NFVFNUUkVUQ0hCTFRNT0RFIDogMHgwMDAwMDAxNSxcbiAgICBFTVJfU0VUVEVYVEFMSUdOIDogMHgwMDAwMDAxNixcbiAgICBFTVJfU0VUQ09MT1JBREpVU1RNRU5UIDogMHgwMDAwMDAxNyxcbiAgICBFTVJfU0VUVEVYVENPTE9SIDogMHgwMDAwMDAxOCxcbiAgICBFTVJfU0VUQktDT0xPUiA6IDB4MDAwMDAwMTksXG4gICAgRU1SX09GRlNFVENMSVBSR04gOiAweDAwMDAwMDFBLFxuICAgIEVNUl9NT1ZFVE9FWCA6IDB4MDAwMDAwMUIsXG4gICAgRU1SX1NFVE1FVEFSR04gOiAweDAwMDAwMDFDLFxuICAgIEVNUl9FWENMVURFQ0xJUFJFQ1QgOiAweDAwMDAwMDFELFxuICAgIEVNUl9JTlRFUlNFQ1RDTElQUkVDVCA6IDB4MDAwMDAwMUUsXG4gICAgRU1SX1NDQUxFVklFV1BPUlRFWFRFWCA6IDB4MDAwMDAwMUYsXG4gICAgRU1SX1NDQUxFV0lORE9XRVhURVggOiAweDAwMDAwMDIwLFxuICAgIEVNUl9TQVZFREMgOiAweDAwMDAwMDIxLFxuICAgIEVNUl9SRVNUT1JFREMgOiAweDAwMDAwMDIyLFxuICAgIEVNUl9TRVRXT1JMRFRSQU5TRk9STSA6IDB4MDAwMDAwMjMsXG4gICAgRU1SX01PRElGWVdPUkxEVFJBTlNGT1JNIDogMHgwMDAwMDAyNCxcbiAgICBFTVJfU0VMRUNUT0JKRUNUIDogMHgwMDAwMDAyNSxcbiAgICBFTVJfQ1JFQVRFUEVOIDogMHgwMDAwMDAyNixcbiAgICBFTVJfQ1JFQVRFQlJVU0hJTkRJUkVDVCA6IDB4MDAwMDAwMjcsXG4gICAgRU1SX0RFTEVURU9CSkVDVCA6IDB4MDAwMDAwMjgsXG4gICAgRU1SX0FOR0xFQVJDIDogMHgwMDAwMDAyOSxcbiAgICBFTVJfRUxMSVBTRSA6IDB4MDAwMDAwMkEsXG4gICAgRU1SX1JFQ1RBTkdMRSA6IDB4MDAwMDAwMkIsXG4gICAgRU1SX1JPVU5EUkVDVCA6IDB4MDAwMDAwMkMsXG4gICAgRU1SX0FSQyA6IDB4MDAwMDAwMkQsXG4gICAgRU1SX0NIT1JEIDogMHgwMDAwMDAyRSxcbiAgICBFTVJfUElFIDogMHgwMDAwMDAyRixcbiAgICBFTVJfU0VMRUNUUEFMRVRURSA6IDB4MDAwMDAwMzAsXG4gICAgRU1SX0NSRUFURVBBTEVUVEUgOiAweDAwMDAwMDMxLFxuICAgIEVNUl9TRVRQQUxFVFRFRU5UUklFUyA6IDB4MDAwMDAwMzIsXG4gICAgRU1SX1JFU0laRVBBTEVUVEUgOiAweDAwMDAwMDMzLFxuICAgIEVNUl9SRUFMSVpFUEFMRVRURSA6IDB4MDAwMDAwMzQsXG4gICAgRU1SX0VYVEZMT09ERklMTCA6IDB4MDAwMDAwMzUsXG4gICAgRU1SX0xJTkVUTyA6IDB4MDAwMDAwMzYsXG4gICAgRU1SX0FSQ1RPIDogMHgwMDAwMDAzNyxcbiAgICBFTVJfUE9MWURSQVcgOiAweDAwMDAwMDM4LFxuICAgIEVNUl9TRVRBUkNESVJFQ1RJT04gOiAweDAwMDAwMDM5LFxuICAgIEVNUl9TRVRNSVRFUkxJTUlUIDogMHgwMDAwMDAzQSxcbiAgICBFTVJfQkVHSU5QQVRIIDogMHgwMDAwMDAzQixcbiAgICBFTVJfRU5EUEFUSCA6IDB4MDAwMDAwM0MsXG4gICAgRU1SX0NMT1NFRklHVVJFIDogMHgwMDAwMDAzRCxcbiAgICBFTVJfRklMTFBBVEggOiAweDAwMDAwMDNFLFxuICAgIEVNUl9TVFJPS0VBTkRGSUxMUEFUSCA6IDB4MDAwMDAwM0YsXG4gICAgRU1SX1NUUk9LRVBBVEggOiAweDAwMDAwMDQwLFxuICAgIEVNUl9GTEFUVEVOUEFUSCA6IDB4MDAwMDAwNDEsXG4gICAgRU1SX1dJREVOUEFUSCA6IDB4MDAwMDAwNDIsXG4gICAgRU1SX1NFTEVDVENMSVBQQVRIIDogMHgwMDAwMDA0MyxcbiAgICBFTVJfQUJPUlRQQVRIIDogMHgwMDAwMDA0NCxcbiAgICBFTVJfQ09NTUVOVCA6IDB4MDAwMDAwNDYsXG4gICAgRU1SX0ZJTExSR04gOiAweDAwMDAwMDQ3LFxuICAgIEVNUl9GUkFNRVJHTiA6IDB4MDAwMDAwNDgsXG4gICAgRU1SX0lOVkVSVFJHTiA6IDB4MDAwMDAwNDksXG4gICAgRU1SX1BBSU5UUkdOIDogMHgwMDAwMDA0QSxcbiAgICBFTVJfRVhUU0VMRUNUQ0xJUFJHTiA6IDB4MDAwMDAwNEIsXG4gICAgRU1SX0JJVEJMVCA6IDB4MDAwMDAwNEMsXG4gICAgRU1SX1NUUkVUQ0hCTFQgOiAweDAwMDAwMDRELFxuICAgIEVNUl9NQVNLQkxUIDogMHgwMDAwMDA0RSxcbiAgICBFTVJfUExHQkxUIDogMHgwMDAwMDA0RixcbiAgICBFTVJfU0VURElCSVRTVE9ERVZJQ0UgOiAweDAwMDAwMDUwLFxuICAgIEVNUl9TVFJFVENIRElCSVRTIDogMHgwMDAwMDA1MSxcbiAgICBFTVJfRVhUQ1JFQVRFRk9OVElORElSRUNUVyA6IDB4MDAwMDAwNTIsXG4gICAgRU1SX0VYVFRFWFRPVVRBIDogMHgwMDAwMDA1MyxcbiAgICBFTVJfRVhUVEVYVE9VVFcgOiAweDAwMDAwMDU0LFxuICAgIEVNUl9QT0xZQkVaSUVSMTYgOiAweDAwMDAwMDU1LFxuICAgIEVNUl9QT0xZR09OMTYgOiAweDAwMDAwMDU2LFxuICAgIEVNUl9QT0xZTElORTE2IDogMHgwMDAwMDA1NyxcbiAgICBFTVJfUE9MWUJFWklFUlRPMTYgOiAweDAwMDAwMDU4LFxuICAgIEVNUl9QT0xZTElORVRPMTYgOiAweDAwMDAwMDU5LFxuICAgIEVNUl9QT0xZUE9MWUxJTkUxNiA6IDB4MDAwMDAwNUEsXG4gICAgRU1SX1BPTFlQT0xZR09OMTYgOiAweDAwMDAwMDVCLFxuICAgIEVNUl9QT0xZRFJBVzE2IDogMHgwMDAwMDA1QyxcbiAgICBFTVJfQ1JFQVRFTU9OT0JSVVNIIDogMHgwMDAwMDA1RCxcbiAgICBFTVJfQ1JFQVRFRElCUEFUVEVSTkJSVVNIUFQgOiAweDAwMDAwMDVFLFxuICAgIEVNUl9FWFRDUkVBVEVQRU4gOiAweDAwMDAwMDVGLFxuICAgIEVNUl9QT0xZVEVYVE9VVEEgOiAweDAwMDAwMDYwLFxuICAgIEVNUl9QT0xZVEVYVE9VVFcgOiAweDAwMDAwMDYxLFxuICAgIEVNUl9TRVRJQ01NT0RFIDogMHgwMDAwMDA2MixcbiAgICBFTVJfQ1JFQVRFQ09MT1JTUEFDRSA6IDB4MDAwMDAwNjMsXG4gICAgRU1SX1NFVENPTE9SU1BBQ0UgOiAweDAwMDAwMDY0LFxuICAgIEVNUl9ERUxFVEVDT0xPUlNQQUNFIDogMHgwMDAwMDA2NSxcbiAgICBFTVJfR0xTUkVDT1JEIDogMHgwMDAwMDA2NixcbiAgICBFTVJfR0xTQk9VTkRFRFJFQ09SRCA6IDB4MDAwMDAwNjcsXG4gICAgRU1SX1BJWEVMRk9STUFUIDogMHgwMDAwMDA2OCxcbiAgICBFTVJfRFJBV0VTQ0FQRSA6IDB4MDAwMDAwNjksXG4gICAgRU1SX0VYVEVTQ0FQRSA6IDB4MDAwMDAwNkEsXG4gICAgRU1SX1NNQUxMVEVYVE9VVCA6IDB4MDAwMDAwNkMsXG4gICAgRU1SX0ZPUkNFVUZJTUFQUElORyA6IDB4MDAwMDAwNkQsXG4gICAgRU1SX05BTUVERVNDQVBFIDogMHgwMDAwMDA2RSxcbiAgICBFTVJfQ09MT1JDT1JSRUNUUEFMRVRURSA6IDB4MDAwMDAwNkYsXG4gICAgRU1SX1NFVElDTVBST0ZJTEVBIDogMHgwMDAwMDA3MCxcbiAgICBFTVJfU0VUSUNNUFJPRklMRVcgOiAweDAwMDAwMDcxLFxuICAgIEVNUl9BTFBIQUJMRU5EIDogMHgwMDAwMDA3MixcbiAgICBFTVJfU0VUTEFZT1VUIDogMHgwMDAwMDA3MyxcbiAgICBFTVJfVFJBTlNQQVJFTlRCTFQgOiAweDAwMDAwMDc0LFxuICAgIEVNUl9HUkFESUVOVEZJTEwgOiAweDAwMDAwMDc2LFxuICAgIEVNUl9TRVRMSU5LRURVRklTIDogMHgwMDAwMDA3NyxcbiAgICBFTVJfU0VUVEVYVEpVU1RJRklDQVRJT04gOiAweDAwMDAwMDc4LFxuICAgIEVNUl9DT0xPUk1BVENIVE9UQVJHRVRXIDogMHgwMDAwMDA3OSxcbiAgICBFTVJfQ1JFQVRFQ09MT1JTUEFDRVcgOiAweDAwMDAwMDdBXG59O1xuRnJvbUVNRi5LID0gW107XG5cbi8vIChmdW5jdGlvbigpIHtcbi8vICAgICB2YXIgaW5wLCBvdXQsIHN0dDtcbi8vICAgICBpbnAgPSBGcm9tRU1GLkM7ICAgb3V0ID0gRnJvbUVNRi5LOyAgIHN0dD00O1xuLy8gICAgIGZvcih2YXIgcCBpbiBpbnApIG91dFtpbnBbcF1dID0gcC5zbGljZShzdHQpO1xuLy8gfSAgKSgpO1xuXG5cblxuZXhwb3J0IGxldCBUb0NvbnRleHQyRDphbnkgPSBmdW5jdGlvbiAobmVlZFBhZ2U6YW55LCBzY2FsZTphbnkpXG57XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHRoaXMuYmIgPSBudWxsO1xuICAgIHRoaXMuY3VyclBhZ2UgPSAwO1xuICAgIHRoaXMubmVlZFBhZ2UgPSBuZWVkUGFnZTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG59XG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuU3RhcnRQYWdlID0gZnVuY3Rpb24oeDphbnkseTphbnksdzphbnksaDphbnkpIHtcbiAgICBpZih0aGlzLmN1cnJQYWdlIT10aGlzLm5lZWRQYWdlKSByZXR1cm47XG4gICAgdGhpcy5iYiA9IFt4LHksdyxoXTtcbiAgICB2YXIgc2NsID0gdGhpcy5zY2FsZSwgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgdmFyIGNudiA9IHRoaXMuY2FudmFzLCBjdHggPSB0aGlzLmN0eDtcbiAgICBjbnYud2lkdGggPSBNYXRoLnJvdW5kKHcqc2NsKTsgIGNudi5oZWlnaHQgPSBNYXRoLnJvdW5kKGgqc2NsKTtcbiAgICBjdHgudHJhbnNsYXRlKDAsaCpzY2wpOyAgY3R4LnNjYWxlKHNjbCwtc2NsKTtcbiAgICBjbnYuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJib3JkZXI6MXB4IHNvbGlkOyB3aWR0aDpcIisoY252LndpZHRoL2RwcikrXCJweDsgaGVpZ2h0OlwiKyhjbnYuaGVpZ2h0L2RwcikrXCJweFwiKTtcbn1cblRvQ29udGV4dDJELnByb3RvdHlwZS5GaWxsID0gZnVuY3Rpb24oZ3N0OmFueSwgZXZlbk9kZDphbnkpIHtcbiAgICBpZih0aGlzLmN1cnJQYWdlIT10aGlzLm5lZWRQYWdlKSByZXR1cm47XG4gICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLl9zZXRTdHlsZShnc3QsIGN0eCk7XG4gICAgdGhpcy5fZHJhdyhnc3QucHRoLCBjdHgpO1xuICAgIGN0eC5maWxsKCk7XG59XG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuU3Ryb2tlID0gZnVuY3Rpb24oZ3N0OmFueSkge1xuICAgIGlmKHRoaXMuY3VyclBhZ2UhPXRoaXMubmVlZFBhZ2UpIHJldHVybjtcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuX3NldFN0eWxlKGdzdCwgY3R4KTtcbiAgICB0aGlzLl9kcmF3KGdzdC5wdGgsIGN0eCk7XG4gICAgY3R4LnN0cm9rZSgpO1xufVxuVG9Db250ZXh0MkQucHJvdG90eXBlLlB1dFRleHQgPSBmdW5jdGlvbihnc3Q6YW55LCBzdHI6YW55LCBzdHc6YW55KSB7XG4gICAgaWYodGhpcy5jdXJyUGFnZSE9dGhpcy5uZWVkUGFnZSkgcmV0dXJuO1xuICAgIHZhciBzY2wgPSB0aGlzLl9zY2FsZShnc3QuY3RtKTtcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5fc2V0U3R5bGUoZ3N0LCBjdHgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgdmFyIG0gPSBbMSwwLDAsLTEsMCwwXTsgIHRoaXMuX2NvbmNhdChtLCBnc3QuZm9udC5UbSk7ICB0aGlzLl9jb25jYXQobSwgZ3N0LmN0bSk7XG4gICAgLy9jb25zb2xlLmxvZyhzdHIsIG0sIGdzdCk7ICB0aHJvdyBcImVcIjtcbiAgICBjdHgudHJhbnNmb3JtKG1bMF0sbVsxXSxtWzJdLG1bM10sbVs0XSxtWzVdKTtcbiAgICBjdHguZmlsbFRleHQoc3RyLDAsMCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn1cblRvQ29udGV4dDJELnByb3RvdHlwZS5QdXRJbWFnZSA9IGZ1bmN0aW9uKGdzdDphbnksIGJ1ZmY6YW55LCB3OmFueSwgaDphbnksIG1zazphbnkpIHtcbiAgICBpZih0aGlzLmN1cnJQYWdlIT10aGlzLm5lZWRQYWdlKSByZXR1cm47XG4gICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgIFxuICAgIGlmKGJ1ZmYubGVuZ3RoPT13KmgqNCkge1xuICAgICAgICBidWZmID0gYnVmZi5zbGljZSgwKTtcbiAgICAgICAgaWYobXNrICYmIG1zay5sZW5ndGg9PXcqaCo0KSBmb3IodmFyIGk9MDsgaTxidWZmLmxlbmd0aDsgaSs9NCkgYnVmZltpKzNdID0gbXNrW2krMV07XG4gICAgICAgIFxuICAgICAgICB2YXIgY252ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgY2N0eCA9IGNudi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGNudi53aWR0aCA9IHc7ICBjbnYuaGVpZ2h0ID0gaDtcbiAgICAgICAgdmFyIGltZ2QgPSBjY3R4LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxidWZmLmxlbmd0aDsgaSsrKSBpbWdkLmRhdGFbaV09YnVmZltpXTtcbiAgICAgICAgY2N0eC5wdXRJbWFnZURhdGEoaW1nZCwwLDApO1xuICAgICAgICBcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdmFyIG0gPSBbMSwwLDAsMSwwLDBdOyAgdGhpcy5fY29uY2F0KG0sIFsxL3csMCwwLC0xL2gsMCwxXSk7ICB0aGlzLl9jb25jYXQobSwgZ3N0LmN0bSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0obVswXSxtWzFdLG1bMl0sbVszXSxtWzRdLG1bNV0pO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGNudiwwLDApO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbn1cblRvQ29udGV4dDJELnByb3RvdHlwZS5TaG93UGFnZSA9IGZ1bmN0aW9uKCkgeyAgdGhpcy5jdXJyUGFnZSsrOyAgfVxuVG9Db250ZXh0MkQucHJvdG90eXBlLkRvbmUgPSBmdW5jdGlvbigpIHt9XG5cblxuZnVuY3Rpb24gX2ZsdChuOmFueSkgIHsgIHJldHVybiBcIlwiK3BhcnNlRmxvYXQobi50b0ZpeGVkKDIpKTsgIH1cblxuVG9Db250ZXh0MkQucHJvdG90eXBlLl9zZXRTdHlsZSA9IGZ1bmN0aW9uKGdzdDphbnksIGN0eDphbnkpIHtcbiAgICB2YXIgc2NsID0gdGhpcy5fc2NhbGUoZ3N0LmN0bSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2dldEZpbGwoZ3N0LmNvbHIsIGdzdC5jYSwgY3R4KTtcbiAgICBjdHguc3Ryb2tlU3R5bGU9dGhpcy5fZ2V0RmlsbChnc3QuQ09MUiwgZ3N0LkNBLCBjdHgpO1xuICAgIFxuICAgIGN0eC5saW5lQ2FwID0gW1wiYnV0dFwiLFwicm91bmRcIixcInNxdWFyZVwiXVtnc3QubGNhcF07XG4gICAgY3R4LmxpbmVKb2luPSBbXCJtaXRlclwiLFwicm91bmRcIixcImJldmVsXCJdW2dzdC5sam9pbl07XG4gICAgY3R4LmxpbmVXaWR0aD1nc3QubHdpZHRoKnNjbDtcbiAgICB2YXIgZHNoID0gZ3N0LmRhc2guc2xpY2UoMCk7ICBmb3IodmFyIGk9MDsgaTxkc2gubGVuZ3RoOyBpKyspIGRzaFtpXSA9IF9mbHQoZHNoW2ldKnNjbCk7XG4gICAgY3R4LnNldExpbmVEYXNoKGRzaCk7IFxuICAgIGN0eC5taXRlckxpbWl0ID0gZ3N0Lm1saW1pdCpzY2w7XG4gICAgXG4gICAgdmFyIGZuID0gZ3N0LmZvbnQuVGYsIGxuID0gZm4udG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgcDAgPSBsbi5pbmRleE9mKFwiYm9sZFwiKSE9LTEgPyBcImJvbGQgXCIgOiBcIlwiO1xuICAgIHZhciBwMSA9IChsbi5pbmRleE9mKFwiaXRhbGljXCIpIT0tMSB8fCBsbi5pbmRleE9mKFwib2JsaXF1ZVwiKSE9LTEpID8gXCJpdGFsaWMgXCIgOiBcIlwiO1xuICAgIGN0eC5mb250ID0gcDArcDEgKyBnc3QuZm9udC5UZnMrXCJweCBcXFwiXCIrZm4rXCJcXFwiXCI7XG59XG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX2dldEZpbGwgPSBmdW5jdGlvbihjb2xyOmFueSwgY2E6YW55LCBjdHg6YW55KVxue1xuICAgIGlmKGNvbHIudHlwPT1udWxsKSByZXR1cm4gdGhpcy5fY29scihjb2xyLGNhKTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdyZCA9IGNvbHIsIGNyZCA9IGdyZC5jcmRzLCBtYXQgPSBncmQubWF0LCBzY2w9dGhpcy5fc2NhbGUobWF0KSwgZ2Y7XG4gICAgICAgIGlmICAgICAoZ3JkLnR5cD09XCJsaW5cIikge1xuICAgICAgICAgICAgdmFyIHAwID0gdGhpcy5fbXVsdFBvaW50KG1hdCxjcmQuc2xpY2UoMCwyKSksIHAxID0gdGhpcy5fbXVsdFBvaW50KG1hdCxjcmQuc2xpY2UoMikpO1xuICAgICAgICAgICAgZ2Y9Y3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHAwWzBdLHAwWzFdLHAxWzBdLHAxWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGdyZC50eXA9PVwicmFkXCIpIHtcbiAgICAgICAgICAgIHZhciBwMCA9IHRoaXMuX211bHRQb2ludChtYXQsY3JkLnNsaWNlKDAsMikpLCBwMSA9IHRoaXMuX211bHRQb2ludChtYXQsY3JkLnNsaWNlKDMpKTtcbiAgICAgICAgICAgIGdmPWN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChwMFswXSxwMFsxXSxjcmRbMl0qc2NsLHAxWzBdLHAxWzFdLGNyZFs1XSpzY2wpO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGdyZC5ncmFkLmxlbmd0aDsgaSsrKSAgZ2YuYWRkQ29sb3JTdG9wKGdyZC5ncmFkW2ldWzBdLHRoaXMuX2NvbHIoZ3JkLmdyYWRbaV1bMV0sIGNhKSk7XG4gICAgICAgIHJldHVybiBnZjtcbiAgICB9XG59XG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX2NvbHIgID0gZnVuY3Rpb24oYzphbnksYTphbnkpIHsgIHJldHVybiBcInJnYmEoXCIrTWF0aC5yb3VuZChjWzBdKjI1NSkrXCIsXCIrTWF0aC5yb3VuZChjWzFdKjI1NSkrXCIsXCIrTWF0aC5yb3VuZChjWzJdKjI1NSkrXCIsXCIrYStcIilcIjsgIH07XG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX3NjYWxlID0gZnVuY3Rpb24obTphbnkpICB7ICByZXR1cm4gTWF0aC5zcXJ0KE1hdGguYWJzKG1bMF0qbVszXS1tWzFdKm1bMl0pKTsgIH07XG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX2NvbmNhdD0gZnVuY3Rpb24obTphbnksdzphbnkgICkgeyAgXG4gICAgICAgIHZhciBhPW1bMF0sYj1tWzFdLGM9bVsyXSxkPW1bM10sdHg9bVs0XSx0eT1tWzVdO1xuICAgICAgICBtWzBdID0gKGEgKndbMF0pKyhiICp3WzJdKTsgICAgICAgbVsxXSA9IChhICp3WzFdKSsoYiAqd1szXSk7XG4gICAgICAgIG1bMl0gPSAoYyAqd1swXSkrKGQgKndbMl0pOyAgICAgICBtWzNdID0gKGMgKndbMV0pKyhkICp3WzNdKTtcbiAgICAgICAgbVs0XSA9ICh0eCp3WzBdKSsodHkqd1syXSkrd1s0XTsgIG1bNV0gPSAodHgqd1sxXSkrKHR5KndbM10pK3dbNV07IFxufVxuVG9Db250ZXh0MkQucHJvdG90eXBlLl9tdWx0UG9pbnQ9IGZ1bmN0aW9uKG06YW55LCBwOmFueSkgeyAgdmFyIHg9cFswXSx5PXBbMV07ICByZXR1cm4gW3gqbVswXSt5Km1bMl0rbVs0XSwgICB4Km1bMV0reSptWzNdK21bNV1dOyAgfSxcblRvQ29udGV4dDJELnByb3RvdHlwZS5fZHJhdyAgPSBmdW5jdGlvbihwYXRoOmFueSwgY3R4OmFueSlcbntcbiAgICB2YXIgYyA9IDAsIGNyZHMgPSBwYXRoLmNyZHM7XG4gICAgZm9yKHZhciBqPTA7IGo8cGF0aC5jbWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBjbWQgPSBwYXRoLmNtZHNbal07XG4gICAgICAgIGlmICAgICAoY21kPT1cIk1cIikgeyAgY3R4Lm1vdmVUbyhjcmRzW2NdLCBjcmRzW2MrMV0pOyAgYys9MjsgIH1cbiAgICAgICAgZWxzZSBpZihjbWQ9PVwiTFwiKSB7ICBjdHgubGluZVRvKGNyZHNbY10sIGNyZHNbYysxXSk7ICBjKz0yOyAgfVxuICAgICAgICBlbHNlIGlmKGNtZD09XCJDXCIpIHsgIGN0eC5iZXppZXJDdXJ2ZVRvKGNyZHNbY10sIGNyZHNbYysxXSwgY3Jkc1tjKzJdLCBjcmRzW2MrM10sIGNyZHNbYys0XSwgY3Jkc1tjKzVdKTsgIGMrPTY7ICB9XG4gICAgICAgIGVsc2UgaWYoY21kPT1cIlFcIikgeyAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY3Jkc1tjXSwgY3Jkc1tjKzFdLCBjcmRzW2MrMl0sIGNyZHNbYyszXSk7ICBjKz00OyAgfVxuICAgICAgICBlbHNlIGlmKGNtZD09XCJaXCIpIHsgIGN0eC5jbG9zZVBhdGgoKTsgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjb2x1bWVIZWFkZXJfd29yZCwgY29sdW1lSGVhZGVyX3dvcmRfaW5kZXggfSBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IHsgSWx1Y2t5U2hlZXRTZWxlY3Rpb24gfSBmcm9tIFwiLi4vVG9MdWNreVNoZWV0L0lMdWNrXCI7XG5pbXBvcnQgeyBJYXR0cmlidXRlTGlzdCwgc3RyaW5nVG9OdW19IGZyb20gXCIuLi9JQ29tbW9uXCI7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdldHh0KHJhbmdlOklsdWNreVNoZWV0U2VsZWN0aW9uLCBzaGVldHR4dDpzdHJpbmcpIHtcblxuICAgIGxldCByb3cwID0gcmFuZ2VbXCJyb3dcIl1bMF0sIHJvdzEgPSByYW5nZVtcInJvd1wiXVsxXTtcbiAgICBsZXQgY29sdW1uMCA9IHJhbmdlW1wiY29sdW1uXCJdWzBdLCBjb2x1bW4xID0gcmFuZ2VbXCJjb2x1bW5cIl1bMV07XG5cbiAgICBpZiAocm93MCA9PSBudWxsICYmIHJvdzEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2hlZXR0eHQgKyBjaGF0YXRBQkMoY29sdW1uMCkgKyBcIjpcIiArIGNoYXRhdEFCQyhjb2x1bW4xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sdW1uMCA9PSBudWxsICYmIGNvbHVtbjEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2hlZXR0eHQgKyAocm93MCArIDEpICsgXCI6XCIgKyAocm93MSArIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNvbHVtbjAgPT0gY29sdW1uMSAmJiByb3cwID09IHJvdzEpIHtcbiAgICAgICAgICAgIHJldHVybiBzaGVldHR4dCArIGNoYXRhdEFCQyhjb2x1bW4wKSArIChyb3cwICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2hlZXR0eHQgKyBjaGF0YXRBQkMoY29sdW1uMCkgKyAocm93MCArIDEpICsgXCI6XCIgKyBjaGF0YXRBQkMoY29sdW1uMSkgKyAocm93MSArIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRjZWxscmFuZ2UgKHR4dDpzdHJpbmcsIHNoZWV0czpJYXR0cmlidXRlTGlzdD17fSwgc2hlZXRJZDpzdHJpbmc9XCIxXCIpIHtcbiAgICBsZXQgdmFsID0gdHh0LnNwbGl0KFwiIVwiKTtcblxuICAgIGxldCBzaGVldHR4dCA9IFwiXCIsXG4gICAgICAgIHJhbmdldHh0ID0gXCJcIixcbiAgICAgICAgc2hlZXRJbmRleCA9IC0xO1xuXG4gICAgaWYgKHZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNoZWV0dHh0ID0gdmFsWzBdO1xuICAgICAgICByYW5nZXR4dCA9IHZhbFsxXTtcbiAgICAgICAgXG4gICAgICAgIGxldCBzaSA9IHNoZWV0c1tzaGVldHR4dF07XG4gICAgICAgIGlmKHNpPT1udWxsKXtcbiAgICAgICAgICAgIHNoZWV0SW5kZXggPSBwYXJzZUludChzaGVldElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgc2hlZXRJbmRleCA9IHBhcnNlSW50KHNpKTtcbiAgICAgICAgfVxuICAgIH0gXG4gICAgZWxzZSB7XG4gICAgICAgIHNoZWV0SW5kZXggPSBwYXJzZUludChzaGVldElkKTtcbiAgICAgICAgcmFuZ2V0eHQgPSB2YWxbMF07XG4gICAgfVxuICAgIFxuICAgIGlmIChyYW5nZXR4dC5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xuICAgICAgICBsZXQgcm93ID0gcGFyc2VJbnQocmFuZ2V0eHQucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKSAtIDE7XG4gICAgICAgIGxldCBjb2wgPSBBQkNhdE51bShyYW5nZXR4dC5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xuXG4gICAgICAgIGlmICghaXNOYU4ocm93KSAmJiAhaXNOYU4oY29sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBcInJvd1wiOiBbcm93LCByb3ddLFxuICAgICAgICAgICAgICAgIFwiY29sdW1uXCI6IFtjb2wsIGNvbF0sXG4gICAgICAgICAgICAgICAgXCJzaGVldEluZGV4XCI6IHNoZWV0SW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0gXG4gICAgZWxzZSB7XG4gICAgICAgIGxldCByYW5nZXR4dEFycmF5OnN0cmluZ1tdID0gcmFuZ2V0eHQuc3BsaXQoXCI6XCIpO1xuICAgICAgICBsZXQgcm93ID0gW10sY29sID0gW107XG4gICAgICAgIHJvd1swXSA9IHBhcnNlSW50KHJhbmdldHh0QXJyYXlbMF0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKSAtIDE7XG4gICAgICAgIHJvd1sxXSA9IHBhcnNlSW50KHJhbmdldHh0QXJyYXlbMV0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKSAtIDE7XG4gICAgICAgIC8vIGlmIChpc05hTihyb3dbMF0pKSB7XG4gICAgICAgIC8vICAgICByb3dbMF0gPSAwO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmIChpc05hTihyb3dbMV0pKSB7XG4gICAgICAgIC8vICAgICByb3dbMV0gPSBzaGVldGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgLy8gfVxuICAgICAgICBpZiAocm93WzBdID4gcm93WzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb2xbMF0gPSBBQkNhdE51bShyYW5nZXR4dEFycmF5WzBdLnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XG4gICAgICAgIGNvbFsxXSA9IEFCQ2F0TnVtKHJhbmdldHh0QXJyYXlbMV0ucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcbiAgICAgICAgLy8gaWYgKGlzTmFOKGNvbFswXSkpIHtcbiAgICAgICAgLy8gICAgIGNvbFswXSA9IDA7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKGlzTmFOKGNvbFsxXSkpIHtcbiAgICAgICAgLy8gICAgIGNvbFsxXSA9IHNoZWV0ZGF0YVswXS5sZW5ndGggLSAxO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmIChjb2xbMF0gPiBjb2xbMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwicm93XCI6IHJvdyxcbiAgICAgICAgICAgIFwiY29sdW1uXCI6IGNvbCxcbiAgICAgICAgICAgIFwic2hlZXRJbmRleFwiOiBzaGVldEluZGV4XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vL+WIl+S4i+aghyAg5a2X5q+N6L2s5pWw5a2XXG5mdW5jdGlvbiBBQkNhdE51bShhYmM6c3RyaW5nKSB7XG4gICAgYWJjID0gYWJjLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBsZXQgYWJjX2xlbiA9IGFiYy5sZW5ndGg7XG4gICAgaWYgKGFiY19sZW4gPT0gMCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIGxldCBhYmNfYXJyYXkgPSBhYmMuc3BsaXQoXCJcIik7XG4gICAgbGV0IHdvcmRsZW4gPSBjb2x1bWVIZWFkZXJfd29yZC5sZW5ndGg7XG4gICAgbGV0IHJldCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gYWJjX2xlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChpID09IGFiY19sZW4gLSAxKSB7XG4gICAgICAgICAgICByZXQgKz0gY29sdW1lSGVhZGVyX3dvcmRfaW5kZXhbYWJjX2FycmF5W2ldXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBNYXRoLnBvdyh3b3JkbGVuLCBhYmNfbGVuIC0gaSAtIDEpICogKGNvbHVtZUhlYWRlcl93b3JkX2luZGV4W2FiY19hcnJheVtpXV0gKyAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbi8v5YiX5LiL5qCHICDmlbDlrZfovazlrZfmr41cbmZ1bmN0aW9uIGNoYXRhdEFCQyhpbmRleDpudW1iZXIpIHtcbiAgICBsZXQgd29yZGxlbiA9IGNvbHVtZUhlYWRlcl93b3JkLmxlbmd0aDtcblxuICAgIGlmIChpbmRleCA8IHdvcmRsZW4pIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtZUhlYWRlcl93b3JkW2luZGV4XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsYXN0ID0gMCwgcHJlID0gMCwgcmV0ID0gXCJcIjtcbiAgICAgICAgbGV0IGkgPSAxLCBuID0gMDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPj0gKHdvcmRsZW4gLyAod29yZGxlbiAtIDEpKSAqIChNYXRoLnBvdyh3b3JkbGVuLCBpKyspIC0gMSkpIHtcbiAgICAgICAgICAgIG4gPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluZGV4X2FiID0gaW5kZXggLSAod29yZGxlbiAvICh3b3JkbGVuIC0gMSkpICogKE1hdGgucG93KHdvcmRsZW4sIG4gLSAxKSAtIDEpOy8vOTcwXG4gICAgICAgIGxhc3QgPSBpbmRleF9hYiArIDE7XG5cbiAgICAgICAgZm9yIChsZXQgeCA9IG47IHggPiAwOyB4LS0pIHtcbiAgICAgICAgICAgIGxldCBsYXN0MSA9IGxhc3QsIHgxID0geDsvLy03MDI9MjY4LCAzXG5cbiAgICAgICAgICAgIGlmICh4ID09IDEpIHtcbiAgICAgICAgICAgICAgICBsYXN0MSA9IGxhc3QxICUgd29yZGxlbjtcblxuICAgICAgICAgICAgICAgIGlmIChsYXN0MSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QxID0gMjY7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldCArIGNvbHVtZUhlYWRlcl93b3JkW2xhc3QxIC0gMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3QxID0gTWF0aC5jZWlsKGxhc3QxIC8gTWF0aC5wb3cod29yZGxlbiwgeCAtIDEpKTtcbiAgICAgICAgICAgIC8vbGFzdDEgPSBsYXN0MSAlIHdvcmRsZW47XG4gICAgICAgICAgICByZXQgKz0gY29sdW1lSGVhZGVyX3dvcmRbbGFzdDEgLSAxXTtcblxuICAgICAgICAgICAgaWYgKHggPiAxKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IGxhc3QgLSAobGFzdDEgLSAxKSAqIHdvcmRsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKiBcbiAqIEByZXR1cm4gcmF0aW8sIGRlZmF1bHQgMC43NSAxaW4gPSAyLjU0Y20gPSAyNS40bW0gPSA3MnB0ID0gNnBjLCAgcHQgPSAxLzcyIEluLCBweCA9IDEvZHBpIEluXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldHB0VG9QeFJhdGlvQnlEUEkoKTpudW1iZXJ7XG4gICAgcmV0dXJuIDcyLzk2O1xufVxuXG4vKiogXG4gKiBAZW11cyBFTVVzLCBFeGNlbCBkcmF3aW5nIHVuaXRcbiAqIEByZXR1cm4gcGl4ZWxcbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHhCeUVNVXMoZW11czpudW1iZXIpe1xuICAgIGlmKGVtdXM9PW51bGwpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbGV0IGluY2ggPSBlbXVzLzkxNDQwMDtcbiAgICBsZXQgcHQgPSBpbmNoKjcyO1xuICAgIGxldCBweCA9IHB0IC8gZ2V0cHRUb1B4UmF0aW9CeURQSSgpO1xuICAgIHJldHVybiBweDtcbn1cblxuLyoqIFxuICogQGRvbSB4bWwgYXR0cmlidXRlIG9iamVjdFxuICogQGF0dHIgYXR0cmlidXRlIG5hbWVcbiAqIEBkIGlmIGF0dHJpYnV0ZSBpcyBudWxsLCByZXR1cm4gZGVmYXVsdCB2YWx1ZSBcbiAqIEByZXR1cm4gYXR0cmlidXRlIHZhbHVlXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFhtbEF0dGlidXRlKGRvbTpJYXR0cmlidXRlTGlzdCwgYXR0cjpzdHJpbmcsIGQ6c3RyaW5nKXtcbiAgICBsZXQgdmFsdWUgPSBkb21bYXR0cl07XG4gICAgdmFsdWUgPSB2YWx1ZT09bnVsbD9kOnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqIFxuICogQGNvbHVtbldpZHRoIEV4Y2VsIGNvbHVtbiB3aWR0aFxuICogQHJldHVybiBwaXhlbCBjb2x1bW4gd2lkdGhcbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sdW1uV2lkdGhQaXhlbChjb2x1bW5XaWR0aDpudW1iZXIpe1xuICAgIGxldCBwaXggPSBNYXRoLnJvdW5kKChjb2x1bW5XaWR0aC0wLjgzKSAqIDggKyA1KTtcbiAgICByZXR1cm4gcGl4O1xufVxuXG4vKiogXG4gKiBAcm93SGVpZ2h0IEV4Y2VsIHJvdyBoZWlnaHRcbiAqIEByZXR1cm4gcGl4ZWwgcm93IGhlaWdodFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3dIZWlnaHRQaXhlbChyb3dIZWlnaHQ6bnVtYmVyKXtcbiAgICBsZXQgcGl4ID0gTWF0aC5yb3VuZChyb3dIZWlnaHQvZ2V0cHRUb1B4UmF0aW9CeURQSSgpKTtcbiAgICByZXR1cm4gcGl4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTGlnaHRlbkRhcmtlbkNvbG9yKHNpeENvbG9yOnN0cmluZywgdGludDpudW1iZXIpe1xuICAgIGxldCBoZXg6c3RyaW5nID0gc2l4Q29sb3Iuc3Vic3RyaW5nKHNpeENvbG9yLmxlbmd0aC02LHNpeENvbG9yLmxlbmd0aCk7XG4gICAgbGV0IHJnYkFycmF5Om51bWJlcltdID0gaGV4VG9SZ2JBcnJheShcIiNcIitoZXgpO1xuICAgIGxldCBoc2xBcnJheSA9IHJnYlRvSHNsKHJnYkFycmF5WzBdLCByZ2JBcnJheVsxXSxyZ2JBcnJheVsyXSk7XG4gICAgaWYodGludD4wKXtcbiAgICAgICAgaHNsQXJyYXlbMl0gPSBoc2xBcnJheVsyXSAqICgxLjAtdGludCkgKyB0aW50O1xuICAgIH1cbiAgICBlbHNlIGlmKHRpbnQ8MCl7XG4gICAgICAgIGhzbEFycmF5WzJdID0gaHNsQXJyYXlbMl0gKiAoMS4wICsgdGludClcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgcmV0dXJuIFwiI1wiK2hleDtcbiAgICB9XG5cbiAgICBsZXQgbmV3UmdiQXJyYXkgPSBoc2xUb1JnYihoc2xBcnJheVswXSxoc2xBcnJheVsxXSxoc2xBcnJheVsyXSk7XG5cbiAgICByZXR1cm4gcmdiVG9IZXgoXCJSR0IoXCIgKyBuZXdSZ2JBcnJheS5qb2luKFwiLFwiKSArIFwiKVwiKTtcbn1cblxuXG5mdW5jdGlvbiByZ2JUb0hleChyZ2I6c3RyaW5nKXtcbiAgICAvL+WNgeWFrei/m+WItuminOiJsuWAvOeahOato+WImeihqOi+vuW8j1xuICAgIHZhciByZWcgPSAvXiMoWzAtOWEtZkEtZl17M318WzAtOWEtZkEtZl17Nn0pJC87XG4gICAgLy8g5aaC5p6c5pivcmdi6aKc6Imy6KGo56S6XG4gICAgaWYgKC9eKHJnYnxSR0IpLy50ZXN0KHJnYikpIHtcbiAgICAgICAgdmFyIGFDb2xvciA9IHJnYi5yZXBsYWNlKC8oPzpcXCh8XFwpfHJnYnxSR0IpKi9nLCBcIlwiKS5zcGxpdChcIixcIik7XG4gICAgICAgIHZhciBzdHJIZXggPSBcIiNcIjtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGFDb2xvci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGhleCA9IE51bWJlcihhQ29sb3JbaV0pLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIGhleCA9ICcwJyArIGhleDsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJIZXggKz0gaGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJIZXgubGVuZ3RoICE9PSA3KSB7XG4gICAgICAgICAgICBzdHJIZXggPSByZ2I7ICAgIFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJIZXg7XG4gICAgfSBlbHNlIGlmIChyZWcudGVzdChyZ2IpKSB7XG4gICAgICAgIHZhciBhTnVtID0gcmdiLnJlcGxhY2UoLyMvLFwiXCIpLnNwbGl0KFwiXCIpO1xuICAgICAgICBpZiAoYU51bS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgIHJldHVybiByZ2I7ICAgIFxuICAgICAgICB9IGVsc2UgaWYoYU51bS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHZhciBudW1IZXggPSBcIiNcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxhTnVtLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICAgICAgICAgIG51bUhleCArPSAoYU51bVtpXSArIGFOdW1baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bUhleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoZXhUb1JnYihoZXg6c3RyaW5nKXtcbiAgICB2YXIgc0NvbG9yID0gaGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgLy/ljYHlha3ov5vliLbpopzoibLlgLznmoTmraPliJnooajovr7lvI9cbiAgICB2YXIgcmVnID0gL14jKFswLTlhLWZBLWZdezN9fFswLTlhLWZBLWZdezZ9KSQvO1xuICAgIC8vIOWmguaenOaYrzE26L+b5Yi26aKc6ImyXG4gICAgaWYgKHNDb2xvciAmJiByZWcudGVzdChzQ29sb3IpKSB7XG4gICAgICAgIGlmIChzQ29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICB2YXIgc0NvbG9yTmV3ID0gXCIjXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTE7IGk8NDsgaSs9MSkge1xuICAgICAgICAgICAgICAgIHNDb2xvck5ldyArPSBzQ29sb3Iuc2xpY2UoaSwgaSsxKS5jb25jYXQoc0NvbG9yLnNsaWNlKGksIGkrMSkpOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNDb2xvciA9IHNDb2xvck5ldztcbiAgICAgICAgfVxuICAgICAgICAvL+WkhOeQhuWFreS9jeeahOminOiJsuWAvFxuICAgICAgICB2YXIgc0NvbG9yQ2hhbmdlID0gW107XG4gICAgICAgIGZvciAodmFyIGk9MTsgaTw3OyBpKz0yKSB7XG4gICAgICAgICAgICBzQ29sb3JDaGFuZ2UucHVzaChwYXJzZUludChcIjB4XCIrc0NvbG9yLnNsaWNlKGksIGkrMikpKTsgICAgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiUkdCKFwiICsgc0NvbG9yQ2hhbmdlLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiBzQ29sb3I7XG59XG5cbmZ1bmN0aW9uIGhleFRvUmdiQXJyYXkoaGV4OnN0cmluZyl7XG4gICAgdmFyIHNDb2xvciA9IGhleC50b0xvd2VyQ2FzZSgpO1xuICAgIC8v5Y2B5YWt6L+b5Yi26aKc6Imy5YC855qE5q2j5YiZ6KGo6L6+5byPXG4gICAgdmFyIHJlZyA9IC9eIyhbMC05YS1mQS1mXXszfXxbMC05YS1mQS1mXXs2fSkkLztcbiAgICAvLyDlpoLmnpzmmK8xNui/m+WItuminOiJslxuICAgIGlmIChzQ29sb3IgJiYgcmVnLnRlc3Qoc0NvbG9yKSkge1xuICAgICAgICBpZiAoc0NvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgdmFyIHNDb2xvck5ldyA9IFwiI1wiO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0xOyBpPDQ7IGkrPTEpIHtcbiAgICAgICAgICAgICAgICBzQ29sb3JOZXcgKz0gc0NvbG9yLnNsaWNlKGksIGkrMSkuY29uY2F0KHNDb2xvci5zbGljZShpLCBpKzEpKTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzQ29sb3IgPSBzQ29sb3JOZXc7XG4gICAgICAgIH1cbiAgICAgICAgLy/lpITnkIblha3kvY3nmoTpopzoibLlgLxcbiAgICAgICAgdmFyIHNDb2xvckNoYW5nZTpudW1iZXJbXSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTE7IGk8NzsgaSs9Mikge1xuICAgICAgICAgICAgc0NvbG9yQ2hhbmdlLnB1c2gocGFyc2VJbnQoXCIweFwiK3NDb2xvci5zbGljZShpLCBpKzIpKSk7ICAgIFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAgc0NvbG9yQ2hhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBIU0zpopzoibLlgLzovazmjaLkuLpSR0IuIFxuICog5o2i566X5YWs5byP5pS557yW6IeqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2NvbG9yX3NwYWNlLlxuICogaCwgcywg5ZKMIGwg6K6+5a6a5ZyoIFswLCAxXSDkuYvpl7RcbiAqIOi/lOWbnueahCByLCBnLCDlkowgYiDlnKggWzAsIDI1NV3kuYvpl7RcbiAqXG4gKiBAcGFyYW0gICBOdW1iZXIgIGggICAgICAg6Imy55u4XG4gKiBAcGFyYW0gICBOdW1iZXIgIHMgICAgICAg6aWx5ZKM5bqmXG4gKiBAcGFyYW0gICBOdW1iZXIgIGwgICAgICAg5Lqu5bqmXG4gKiBAcmV0dXJuICBBcnJheSAgICAgICAgICAgUkdC6Imy5YC85pWw5YC8XG4gKi9cbmZ1bmN0aW9uIGhzbFRvUmdiKGg6bnVtYmVyLCBzOm51bWJlciwgbDpudW1iZXIpIHtcbiAgICB2YXIgciwgZywgYjtcblxuICAgIGlmKHMgPT0gMCkge1xuICAgICAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGh1ZTJyZ2IgPSBmdW5jdGlvbiBodWUycmdiKHA6bnVtYmVyLCBxOm51bWJlciwgdDpudW1iZXIpIHtcbiAgICAgICAgICAgIGlmKHQgPCAwKSB0ICs9IDE7XG4gICAgICAgICAgICBpZih0ID4gMSkgdCAtPSAxO1xuICAgICAgICAgICAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICAgICAgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcbiAgICAgICAgICAgIGlmKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtNYXRoLnJvdW5kKHIgKiAyNTUpLCBNYXRoLnJvdW5kKGcgKiAyNTUpLCBNYXRoLnJvdW5kKGIgKiAyNTUpXTtcbn1cblxuXG4vKipcbiAqIFJHQiDpopzoibLlgLzovazmjaLkuLogSFNMLlxuICog6L2s5o2i5YWs5byP5Y+C6ICD6IeqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2NvbG9yX3NwYWNlLlxuICogciwgZywg5ZKMIGIg6ZyA6KaB5ZyoIFswLCAyNTVdIOiMg+WbtOWGhVxuICog6L+U5Zue55qEIGgsIHMsIOWSjCBsIOWcqCBbMCwgMV0g5LmL6Ze0XG4gKlxuICogQHBhcmFtICAgTnVtYmVyICByICAgICAgIOe6ouiJsuiJsuWAvFxuICogQHBhcmFtICAgTnVtYmVyICBnICAgICAgIOe7v+iJsuiJsuWAvFxuICogQHBhcmFtICAgTnVtYmVyICBiICAgICAgIOiTneiJsuiJsuWAvFxuICogQHJldHVybiAgQXJyYXkgICAgICAgICAgIEhTTOWQhOWAvOaVsOe7hFxuICovXG5mdW5jdGlvbiByZ2JUb0hzbChyOm51bWJlciwgZzpudW1iZXIsIGI6bnVtYmVyKSB7XG4gICAgciAvPSAyNTUsIGcgLz0gMjU1LCBiIC89IDI1NTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYgKG1heCA9PSBtaW4peyBcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSA2O1xuICAgIH1cblxuICAgIHJldHVybiBbaCwgcywgbF07XG59XG4gXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JbmRleChwcmVmaXg6c3RyaW5nKTpzdHJpbmcge1xuICAgIGlmKHByZWZpeCA9PSBudWxsKXtcbiAgICAgICAgcHJlZml4ID0gXCJTaGVldFwiO1xuICAgIH1cblxuICAgIGxldCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgXCJcIikuc3BsaXQoXCJcIik7XG5cbiAgICBsZXQgbWlkID0gXCJcIjtcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCA1OyBpKyspe1xuICAgICAgICBtaWQgKz0gdXNlckFnZW50W01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqICh1c2VyQWdlbnQubGVuZ3RoIC0gMSkpXTtcbiAgICB9XG5cbiAgICBsZXQgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgcmV0dXJuIHByZWZpeCArIFwiX1wiICsgbWlkICsgXCJfXCIgKyB0aW1lO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVDaGFyYWN0ZXIoc3RyOnN0cmluZyl7XG4gICAgaWYoc3RyPT1udWxsIHx8IHN0ci5sZW5ndGg9PTApe1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJmFtcDsvZywgXCImXCIpLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKS5yZXBsYWNlKC8mbHQ7L2csICc8JykucmVwbGFjZSgvJmd0Oy9nLCAnPicpLnJlcGxhY2UoLyZuYnNwOy9nLCAnICcpLnJlcGxhY2UoLyZhcG9zOy9nLCBcIidcIikucmVwbGFjZSgvJmlleGNsOy9nLCBcIsKhXCIpLnJlcGxhY2UoLyZjZW50Oy9nLCBcIsKiXCIpLnJlcGxhY2UoLyZwb3VuZDsvZywgXCLCo1wiKS5yZXBsYWNlKC8mY3VycmVuOy9nLCBcIsKkXCIpLnJlcGxhY2UoLyZ5ZW47L2csIFwiwqVcIikucmVwbGFjZSgvJmJydmJhcjsvZywgXCLCplwiKS5yZXBsYWNlKC8mc2VjdDsvZywgXCLCp1wiKS5yZXBsYWNlKC8mdW1sOy9nLCBcIsKoXCIpLnJlcGxhY2UoLyZjb3B5Oy9nLCBcIsKpXCIpLnJlcGxhY2UoLyZvcmRmOy9nLCBcIsKqXCIpLnJlcGxhY2UoLyZsYXF1bzsvZywgXCLCq1wiKS5yZXBsYWNlKC8mbm90Oy9nLCBcIsKsXCIpLnJlcGxhY2UoLyZzaHk7L2csIFwiwq1cIikucmVwbGFjZSgvJnJlZzsvZywgXCLCrlwiKS5yZXBsYWNlKC8mbWFjcjsvZywgXCLCr1wiKS5yZXBsYWNlKC8mZGVnOy9nLCBcIsKwXCIpLnJlcGxhY2UoLyZwbHVzbW47L2csIFwiwrFcIikucmVwbGFjZSgvJnN1cDI7L2csIFwiwrJcIikucmVwbGFjZSgvJnN1cDM7L2csIFwiwrNcIikucmVwbGFjZSgvJmFjdXRlOy9nLCBcIsK0XCIpLnJlcGxhY2UoLyZtaWNybzsvZywgXCLCtVwiKS5yZXBsYWNlKC8mcGFyYTsvZywgXCLCtlwiKS5yZXBsYWNlKC8mbWlkZG90Oy9nLCBcIsK3XCIpLnJlcGxhY2UoLyZjZWRpbDsvZywgXCLCuFwiKS5yZXBsYWNlKC8mc3VwMTsvZywgXCLCuVwiKS5yZXBsYWNlKC8mb3JkbTsvZywgXCLCulwiKS5yZXBsYWNlKC8mcmFxdW87L2csIFwiwrtcIikucmVwbGFjZSgvJmZyYWMxNDsvZywgXCLCvFwiKS5yZXBsYWNlKC8mZnJhYzEyOy9nLCBcIsK9XCIpLnJlcGxhY2UoLyZmcmFjMzQ7L2csIFwiwr5cIikucmVwbGFjZSgvJmlxdWVzdDsvZywgXCLCv1wiKS5yZXBsYWNlKC8mdGltZXM7L2csIFwiw5dcIikucmVwbGFjZSgvJmRpdmlkZTsvZywgXCLDt1wiKS5yZXBsYWNlKC8mQWdyYXZlOy9nLCBcIsOAXCIpLnJlcGxhY2UoLyZBYWN1dGU7L2csIFwiw4FcIikucmVwbGFjZSgvJkFjaXJjOy9nLCBcIsOCXCIpLnJlcGxhY2UoLyZBdGlsZGU7L2csIFwiw4NcIikucmVwbGFjZSgvJkF1bWw7L2csIFwiw4RcIikucmVwbGFjZSgvJkFyaW5nOy9nLCBcIsOFXCIpLnJlcGxhY2UoLyZBRWxpZzsvZywgXCLDhlwiKS5yZXBsYWNlKC8mQ2NlZGlsOy9nLCBcIsOHXCIpLnJlcGxhY2UoLyZFZ3JhdmU7L2csIFwiw4hcIikucmVwbGFjZSgvJkVhY3V0ZTsvZywgXCLDiVwiKS5yZXBsYWNlKC8mRWNpcmM7L2csIFwiw4pcIikucmVwbGFjZSgvJkV1bWw7L2csIFwiw4tcIikucmVwbGFjZSgvJklncmF2ZTsvZywgXCLDjFwiKS5yZXBsYWNlKC8mSWFjdXRlOy9nLCBcIsONXCIpLnJlcGxhY2UoLyZJY2lyYzsvZywgXCLDjlwiKS5yZXBsYWNlKC8mSXVtbDsvZywgXCLDj1wiKS5yZXBsYWNlKC8mRVRIOy9nLCBcIsOQXCIpLnJlcGxhY2UoLyZOdGlsZGU7L2csIFwiw5FcIikucmVwbGFjZSgvJk9ncmF2ZTsvZywgXCLDklwiKS5yZXBsYWNlKC8mT2FjdXRlOy9nLCBcIsOTXCIpLnJlcGxhY2UoLyZPY2lyYzsvZywgXCLDlFwiKS5yZXBsYWNlKC8mT3RpbGRlOy9nLCBcIsOVXCIpLnJlcGxhY2UoLyZPdW1sOy9nLCBcIsOWXCIpLnJlcGxhY2UoLyZPc2xhc2g7L2csIFwiw5hcIikucmVwbGFjZSgvJlVncmF2ZTsvZywgXCLDmVwiKS5yZXBsYWNlKC8mVWFjdXRlOy9nLCBcIsOaXCIpLnJlcGxhY2UoLyZVY2lyYzsvZywgXCLDm1wiKS5yZXBsYWNlKC8mVXVtbDsvZywgXCLDnFwiKS5yZXBsYWNlKC8mWWFjdXRlOy9nLCBcIsOdXCIpLnJlcGxhY2UoLyZUSE9STjsvZywgXCLDnlwiKS5yZXBsYWNlKC8mc3psaWc7L2csIFwiw59cIikucmVwbGFjZSgvJmFncmF2ZTsvZywgXCLDoFwiKS5yZXBsYWNlKC8mYWFjdXRlOy9nLCBcIsOhXCIpLnJlcGxhY2UoLyZhY2lyYzsvZywgXCLDolwiKS5yZXBsYWNlKC8mYXRpbGRlOy9nLCBcIsOjXCIpLnJlcGxhY2UoLyZhdW1sOy9nLCBcIsOkXCIpLnJlcGxhY2UoLyZhcmluZzsvZywgXCLDpVwiKS5yZXBsYWNlKC8mYWVsaWc7L2csIFwiw6ZcIikucmVwbGFjZSgvJmNjZWRpbDsvZywgXCLDp1wiKS5yZXBsYWNlKC8mZWdyYXZlOy9nLCBcIsOoXCIpLnJlcGxhY2UoLyZlYWN1dGU7L2csIFwiw6lcIikucmVwbGFjZSgvJmVjaXJjOy9nLCBcIsOqXCIpLnJlcGxhY2UoLyZldW1sOy9nLCBcIsOrXCIpLnJlcGxhY2UoLyZpZ3JhdmU7L2csIFwiw6xcIikucmVwbGFjZSgvJmlhY3V0ZTsvZywgXCLDrVwiKS5yZXBsYWNlKC8maWNpcmM7L2csIFwiw65cIikucmVwbGFjZSgvJml1bWw7L2csIFwiw69cIikucmVwbGFjZSgvJmV0aDsvZywgXCLDsFwiKS5yZXBsYWNlKC8mbnRpbGRlOy9nLCBcIsOxXCIpLnJlcGxhY2UoLyZvZ3JhdmU7L2csIFwiw7JcIikucmVwbGFjZSgvJm9hY3V0ZTsvZywgXCLDs1wiKS5yZXBsYWNlKC8mb2NpcmM7L2csIFwiw7RcIikucmVwbGFjZSgvJm90aWxkZTsvZywgXCLDtVwiKS5yZXBsYWNlKC8mb3VtbDsvZywgXCLDtlwiKS5yZXBsYWNlKC8mb3NsYXNoOy9nLCBcIsO4XCIpLnJlcGxhY2UoLyZ1Z3JhdmU7L2csIFwiw7lcIikucmVwbGFjZSgvJnVhY3V0ZTsvZywgXCLDulwiKS5yZXBsYWNlKC8mdWNpcmM7L2csIFwiw7tcIikucmVwbGFjZSgvJnV1bWw7L2csIFwiw7xcIikucmVwbGFjZSgvJnlhY3V0ZTsvZywgXCLDvVwiKS5yZXBsYWNlKC8mdGhvcm47L2csIFwiw75cIikucmVwbGFjZSgvJnl1bWw7L2csIFwiw79cIik7XG5cbn1cblxuXG5leHBvcnQgY2xhc3MgZnJvbXVsYVJlZiB7XG5cbiAgICBzdGF0aWMgb3BlcmF0b3IgPSAnPT18IT18PD58PD18Pj18PXwrfC18Pnw8fC98KnwlfCZ8XidcbiAgICBzdGF0aWMgZXJyb3IgPSB7XG4gICAgICAgIHY6IFwiI1ZBTFVFIVwiLCAgICAvL+mUmeivr+eahOWPguaVsOaIlui/kOeul+esplxuICAgICAgICBuOiBcIiNOQU1FP1wiLCAgICAgLy/lhazlvI/lkI3np7DplJnor69cbiAgICAgICAgbmE6IFwiI04vQVwiLCAgICAgIC8v5Ye95pWw5oiW5YWs5byP5Lit5rKh5pyJ5Y+v55So5pWw5YC8XG4gICAgICAgIHI6IFwiI1JFRiFcIiwgICAgICAvL+WIoOmZpOS6hueUseWFtuS7luWFrOW8j+W8leeUqOeahOWNleWFg+agvFxuICAgICAgICBkOiBcIiNESVYvMCFcIiwgICAgLy/pmaTmlbDmmK8w5oiW56m65Y2V5YWD5qC8XG4gICAgICAgIG5tOiBcIiNOVU0hXCIsICAgICAvL+W9k+WFrOW8j+aIluWHveaVsOS4reafkOS4quaVsOWtl+aciemXrumimOaXtlxuICAgICAgICBubDogXCIjTlVMTCFcIiwgICAgLy/kuqTlj4nov5DnrpfnrKbvvIjnqbrmoLzvvInkvb/nlKjkuI3mraPnoa5cbiAgICAgICAgc3A6IFwiI1NQSUxMIVwiICAgIC8v5pWw57uE6IyD5Zu05pyJ5YW25a6D5YC8XG4gICAgfVxuXG4gICAgc3RhdGljIG9wZXJhdG9yanNvbjpzdHJpbmdUb051bSA9IG51bGxcblxuICAgIHN0YXRpYyB0cmltKHN0cjpzdHJpbmcpIHsgIFxuICAgICAgICBpZihzdHIgPT0gbnVsbCl7ICBcbiAgICAgICAgICAgIHN0ciA9IFwiXCI7ICBcbiAgICAgICAgfSAgXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKF5cXHMqKXwoXFxzKiQpL2csIFwiXCIpOyAgXG4gICAgfVxuXG4gICAgc3RhdGljIGZ1bmN0aW9uQ29weSh0eHQ6c3RyaW5nLCBtb2RlOnN0cmluZywgc3RlcDpudW1iZXIpIHtcbiAgICAgICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoX3RoaXMub3BlcmF0b3Jqc29uID09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBhcnIgPSBfdGhpcy5vcGVyYXRvci5zcGxpdChcInxcIiksXG4gICAgICAgICAgICAgICAgb3A6c3RyaW5nVG9OdW0gPSB7fTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvcFthcnJbaV0udG9TdHJpbmcoKV0gPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy5vcGVyYXRvcmpzb24gPSBvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vZGUgPSBcImRvd25cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR4dC5zdWJzdHIoMCwgMSkgPT0gXCI9XCIpIHtcbiAgICAgICAgICAgIHR4dCA9IHR4dC5zdWJzdHIoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZnVuY3N0YWNrID0gdHh0LnNwbGl0KFwiXCIpO1xuICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICBzdHIgPSBcIlwiLFxuICAgICAgICAgICAgZnVuY3Rpb25fc3RyID0gXCJcIixcbiAgICAgICAgICAgIGlzcGFzc2J5ID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGxldCBtYXRjaENvbmZpZyA9IHtcbiAgICAgICAgICAgIFwiYnJhY2tldFwiOiAwLFxuICAgICAgICAgICAgXCJjb21tYVwiOiAwLFxuICAgICAgICAgICAgXCJzcXVvdGVcIjogMCxcbiAgICAgICAgICAgIFwiZHF1b3RlXCI6IDBcbiAgICAgICAgfTtcblxuICAgICAgICB3aGlsZSAoaSA8IGZ1bmNzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBzID0gZnVuY3N0YWNrW2ldO1xuXG4gICAgICAgICAgICBpZiAocyA9PSBcIihcIiAmJiBtYXRjaENvbmZpZy5kcXVvdGUgPT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoQ29uZmlnLmJyYWNrZXQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gc3RyICsgXCIoXCI7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IFwiKFwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgZWxzZSBpZiAocyA9PSBcIilcIiAmJiBtYXRjaENvbmZpZy5kcXVvdGUgPT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoQ29uZmlnLmJyYWNrZXQgLT0gMTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMuZnVuY3Rpb25Db3B5KHN0ciwgbW9kZSwgc3RlcCkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAnXCInICYmIG1hdGNoQ29uZmlnLnNxdW90ZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoQ29uZmlnLmRxdW90ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IHN0ciArICdcIic7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQ29uZmlnLmRxdW90ZSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQ29uZmlnLmRxdW90ZSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1wiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAnLCcgJiYgbWF0Y2hDb25maWcuZHF1b3RlID09IDApIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMuZnVuY3Rpb25Db3B5KHN0ciwgbW9kZSwgc3RlcCkgKyAnLCc7XG4gICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBlbHNlIGlmIChzID09ICcmJyAmJiBtYXRjaENvbmZpZy5kcXVvdGUgPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMuZnVuY3Rpb25Db3B5KHN0ciwgbW9kZSwgc3RlcCkgKyBcIiZcIjtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gXCImXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKHMgaW4gX3RoaXMub3BlcmF0b3Jqc29uICYmIG1hdGNoQ29uZmlnLmRxdW90ZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNfbmV4dCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGkgKyAxKSA8IGZ1bmNzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc19uZXh0ID0gZnVuY3N0YWNrW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgcCA9IGkgLSAxLCBcbiAgICAgICAgICAgICAgICAgICAgc19wcmUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYocCA+PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc19wcmUgPSBmdW5jc3RhY2tbcC0tXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocD49MCAmJiBzX3ByZSA9PVwiIFwiKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgocyArIHNfbmV4dCkgaW4gX3RoaXMub3BlcmF0b3Jqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmZ1bmN0aW9uQ29weShzdHIsIG1vZGUsIHN0ZXApICsgcyArIHNfbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IHMgKyBzX25leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoISgvW14wLTldLy50ZXN0KHNfbmV4dCkpICYmIHM9PVwiLVwiICYmIChzX3ByZT09XCIoXCIgfHwgc19wcmUgPT0gbnVsbCB8fCBzX3ByZSA9PSBcIixcIiB8fCBzX3ByZSA9PSBcIiBcIiB8fCBzX3ByZSBpbiBfdGhpcy5vcGVyYXRvcmpzb24gKSApe1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmZ1bmN0aW9uQ29weShzdHIsIG1vZGUsIHN0ZXApICsgcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpID09IGZ1bmNzdGFjay5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzY2VsbGRhdGEoX3RoaXMudHJpbShzdHIpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSBcImRvd25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmRvd25wYXJhbShfdGhpcy50cmltKHN0ciksIHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwidXBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLnVwcGFyYW0oX3RoaXMudHJpbShzdHIpLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmxlZnRwYXJhbShfdGhpcy50cmltKHN0ciksIHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLnJpZ2h0cGFyYW0oX3RoaXMudHJpbShzdHIpLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy50cmltKHN0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb25fc3RyO1xuICAgIH1cblxuXG4gICAgc3RhdGljIGRvd25wYXJhbSh0eHQ6c3RyaW5nLCBzdGVwOm51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVwYXJhbShcImRcIiwgdHh0LCBzdGVwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBwYXJhbSh0eHQ6c3RyaW5nLCBzdGVwOm51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVwYXJhbShcInVcIiwgdHh0LCBzdGVwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbGVmdHBhcmFtKHR4dDpzdHJpbmcsIHN0ZXA6bnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZXBhcmFtKFwibFwiLCB0eHQsIHN0ZXApO1xuICAgIH1cblxuICAgIHN0YXRpYyByaWdodHBhcmFtICh0eHQ6c3RyaW5nLCBzdGVwOm51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVwYXJhbShcInJcIiwgdHh0LCBzdGVwKTtcbiAgICB9XG5cblxuICAgIHN0YXRpYyB1cGRhdGVwYXJhbSAob3JpZW50OnN0cmluZywgdHh0OnN0cmluZywgc3RlcDpudW1iZXIpIHtcbiAgICAgICAgbGV0IF90aGlzID0gdGhpcztcbiAgICAgICAgbGV0IHZhbCA9IHR4dC5zcGxpdChcIiFcIiksXG4gICAgICAgICAgICByYW5nZXR4dCwgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgXG4gICAgICAgIGlmICh2YWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmFuZ2V0eHQgPSB2YWxbMV07XG4gICAgICAgICAgICBwcmVmaXggPSB2YWxbMF0gKyBcIiFcIjtcbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByYW5nZXR4dCA9IHZhbFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyYW5nZXR4dC5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xuICAgICAgICAgICAgbGV0IHJvdyA9IHBhcnNlSW50KHJhbmdldHh0LnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSk7XG4gICAgICAgICAgICBsZXQgY29sID0gQUJDYXROdW0ocmFuZ2V0eHQucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcbiAgICAgICAgICAgIGxldCBmcmVlem9uRnVjID0gX3RoaXMuaXNmcmVlem9uRnVjKHJhbmdldHh0KTtcbiAgICAgICAgICAgIGxldCAkcm93ID0gZnJlZXpvbkZ1Y1swXSA/IFwiJFwiIDogXCJcIixcbiAgICAgICAgICAgICAgICAkY29sID0gZnJlZXpvbkZ1Y1sxXSA/IFwiJFwiIDogXCJcIjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG9yaWVudCA9PSBcInVcIiAmJiAhZnJlZXpvbkZ1Y1swXSkge1xuICAgICAgICAgICAgICAgIHJvdyAtPSBzdGVwO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PSBcInJcIiAmJiAhZnJlZXpvbkZ1Y1sxXSkge1xuICAgICAgICAgICAgICAgIGNvbCArPSBzdGVwO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PSBcImxcIiAmJiAhZnJlZXpvbkZ1Y1sxXSkge1xuICAgICAgICAgICAgICAgIGNvbCAtPSBzdGVwO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKCFmcmVlem9uRnVjWzBdKSB7XG4gICAgICAgICAgICAgICAgcm93ICs9IHN0ZXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHJvdyA8IDAgfHwgY29sIDwgMCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVycm9yLnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghaXNOYU4ocm93KSAmJiAhaXNOYU4oY29sKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkY29sICsgY2hhdGF0QUJDKGNvbCkgKyAkcm93ICsgKHJvdyk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKHJvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJHJvdyArIChyb3cpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc05hTihjb2wpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICRjb2wgKyBjaGF0YXRBQkMoY29sKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdldHh0ID0gcmFuZ2V0eHQuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgbGV0IHJvdyA9IFtdLFxuICAgICAgICAgICAgICAgIGNvbCA9IFtdO1xuXG4gICAgICAgICAgICByb3dbMF0gPSBwYXJzZUludChyYW5nZXR4dFswXS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpO1xuICAgICAgICAgICAgcm93WzFdID0gcGFyc2VJbnQocmFuZ2V0eHRbMV0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKTtcbiAgICAgICAgICAgIGlmIChyb3dbMF0gPiByb3dbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb2xbMF0gPSBBQkNhdE51bShyYW5nZXR4dFswXS5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xuICAgICAgICAgICAgY29sWzFdID0gQUJDYXROdW0ocmFuZ2V0eHRbMV0ucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcbiAgICAgICAgICAgIGlmIChjb2xbMF0gPiBjb2xbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZnJlZXpvbkZ1YzAgPSBfdGhpcy5pc2ZyZWV6b25GdWMocmFuZ2V0eHRbMF0pO1xuICAgICAgICAgICAgbGV0IGZyZWV6b25GdWMxID0gX3RoaXMuaXNmcmVlem9uRnVjKHJhbmdldHh0WzFdKTtcbiAgICAgICAgICAgIGxldCAkcm93MCA9IGZyZWV6b25GdWMwWzBdID8gXCIkXCIgOiBcIlwiLFxuICAgICAgICAgICAgICAgICRjb2wwID0gZnJlZXpvbkZ1YzBbMV0gPyBcIiRcIiA6IFwiXCI7XG4gICAgICAgICAgICBsZXQgJHJvdzEgPSBmcmVlem9uRnVjMVswXSA/IFwiJFwiIDogXCJcIixcbiAgICAgICAgICAgICAgICAkY29sMSA9IGZyZWV6b25GdWMxWzFdID8gXCIkXCIgOiBcIlwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAob3JpZW50ID09IFwidVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMFswXSkge1xuICAgICAgICAgICAgICAgICAgICByb3dbMF0gLT0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMxWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1sxXSAtPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBlbHNlIGlmIChvcmllbnQgPT0gXCJyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMwWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbFswXSArPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzFbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sWzFdICs9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PSBcImxcIikge1xuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzBbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sWzBdIC09IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xbMV0gLT0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMFswXSkge1xuICAgICAgICAgICAgICAgICAgICByb3dbMF0gKz0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMxWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1sxXSArPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocm93WzBdIDwgMCB8fCBjb2xbMF0gPCAwKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXJyb3IucjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbFswXSkgJiYgaXNOYU4oY29sWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkcm93MCArIChyb3dbMF0pICsgXCI6XCIgKyAkcm93MSArIChyb3dbMV0pO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHJvd1swXSkgJiYgaXNOYU4ocm93WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkY29sMCArIGNoYXRhdEFCQyhjb2xbMF0pICsgXCI6XCIgKyAkY29sMSArIGNoYXRhdEFCQyhjb2xbMV0pO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkY29sMCArIGNoYXRhdEFCQyhjb2xbMF0pICsgJHJvdzAgKyAocm93WzBdKSArIFwiOlwiICsgJGNvbDEgKyBjaGF0YXRBQkMoY29sWzFdKSArICRyb3cxICsgKHJvd1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHN0YXRpYyBpc2NlbGxkYXRhKHR4dDpzdHJpbmcpIHsgLy/liKTmlq3mmK/lkKbkuLrljZXlhYPmoLzmoLzlvI9cbiAgICAgICAgbGV0IHZhbCA9IHR4dC5zcGxpdChcIiFcIiksXG4gICAgICAgICAgICByYW5nZXR4dDtcblxuICAgICAgICBpZiAodmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJhbmdldHh0ID0gdmFsWzFdO1xuICAgICAgICB9IFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdldHh0ID0gdmFsWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlZ19jZWxsID0gL14oKFthLXpBLVpdKyl8KFskXVthLXpBLVpdKykpKChbMC05XSspfChbJF1bMC05XSspKSQvZzsgLy/lop7liqDmraPliJnliKTmlq3ljZXlhYPmoLzkuLrlrZfmr40r5pWw5a2X55qE5qC85byP77ya5aaCIEExOkIzXG4gICAgICAgIGxldCByZWdfY2VsbFJhbmdlID0gL14oKCgoW2EtekEtWl0rKXwoWyRdW2EtekEtWl0rKSkoKFswLTldKyl8KFskXVswLTldKykpKXwoKChbYS16QS1aXSspfChbJF1bYS16QS1aXSspKSkpJC9nOyAvL+WinuWKoOato+WImeWIpOaWreWNleWFg+agvOS4uuWtl+avjSvmlbDlrZfmiJblrZfmr43nmoTmoLzlvI/vvJrlpoIgQTE6QjPvvIxBOkFcbiAgICAgICAgXG4gICAgICAgIGlmIChyYW5nZXR4dC5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xuICAgICAgICAgICAgbGV0IHJvdyA9IHBhcnNlSW50KHJhbmdldHh0LnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSkgLSAxO1xuICAgICAgICAgICAgbGV0IGNvbCA9IEFCQ2F0TnVtKHJhbmdldHh0LnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghaXNOYU4ocm93KSAmJiAhaXNOYU4oY29sKSAmJiByYW5nZXR4dC50b1N0cmluZygpLm1hdGNoKHJlZ19jZWxsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc05hTihyb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc05hTihjb2wpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWdfY2VsbFJhbmdlID0gL14oKCgoW2EtekEtWl0rKXwoWyRdW2EtekEtWl0rKSkoKFswLTldKyl8KFskXVswLTldKykpKXwoKChbYS16QS1aXSspfChbJF1bYS16QS1aXSspKSl8KCgoWzAtOV0rKXwoWyRdWzAtOV0rcykpKSkkL2c7XG5cbiAgICAgICAgICAgIHJhbmdldHh0ID0gcmFuZ2V0eHQuc3BsaXQoXCI6XCIpO1xuXG4gICAgICAgICAgICBsZXQgcm93ID0gW10sY29sID0gW107XG4gICAgICAgICAgICByb3dbMF0gPSBwYXJzZUludChyYW5nZXR4dFswXS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpIC0gMTtcbiAgICAgICAgICAgIHJvd1sxXSA9IHBhcnNlSW50KHJhbmdldHh0WzFdLnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSkgLSAxO1xuICAgICAgICAgICAgaWYgKHJvd1swXSA+IHJvd1sxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sWzBdID0gQUJDYXROdW0ocmFuZ2V0eHRbMF0ucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcbiAgICAgICAgICAgIGNvbFsxXSA9IEFCQ2F0TnVtKHJhbmdldHh0WzFdLnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XG4gICAgICAgICAgICBpZiAoY29sWzBdID4gY29sWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihyYW5nZXR4dFswXS50b1N0cmluZygpLm1hdGNoKHJlZ19jZWxsUmFuZ2UpICYmIHJhbmdldHh0WzFdLnRvU3RyaW5nKCkubWF0Y2gocmVnX2NlbGxSYW5nZSkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaXNmcmVlem9uRnVjKHR4dDpzdHJpbmcpIHtcbiAgICAgICAgbGV0IHJvdyA9IHR4dC5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIik7XG4gICAgICAgIGxldCBjb2wgPSB0eHQucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpO1xuICAgICAgICBsZXQgcm93JCA9IHR4dC5zdWJzdHIodHh0LmluZGV4T2Yocm93KSAtIDEsIDEpO1xuICAgICAgICBsZXQgY29sJCA9IHR4dC5zdWJzdHIodHh0LmluZGV4T2YoY29sKSAtIDEsIDEpO1xuICAgICAgICBsZXQgcmV0ID0gW2ZhbHNlLCBmYWxzZV07XG5cbiAgICAgICAgaWYgKHJvdyQgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIHJldFswXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbCQgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIHJldFsxXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hpbmVzZSh0ZW1wOnN0cmluZyk6Ym9vbGVhblxueyBcbiAgICB2YXIgcmUgPSAvW15cXHU0ZTAwLVxcdTlmYTVdLzsgXG4gICAgdmFyIHJlZyA9IC9bXFx1MzAwMnxcXHVmZjFmfFxcdWZmMDF8XFx1ZmYwY3xcXHUzMDAxfFxcdWZmMWJ8XFx1ZmYxYXxcXHUyMDFjfFxcdTIwMWR8XFx1MjAxOHxcXHUyMDE5fFxcdWZmMDh8XFx1ZmYwOXxcXHUzMDBhfFxcdTMwMGJ8XFx1MzAwOHxcXHUzMDA5fFxcdTMwMTB8XFx1MzAxMXxcXHUzMDBlfFxcdTMwMGZ8XFx1MzAwY3xcXHUzMDBkfFxcdWZlNDN8XFx1ZmU0NHxcXHUzMDE0fFxcdTMwMTV8XFx1MjAyNnxcXHUyMDE0fFxcdWZmNWV8XFx1ZmU0ZnxcXHVmZmU1XS87XG4gICAgaWYocmVnLnRlc3QodGVtcCkpIHJldHVybiB0cnVlOyBcbiAgICBpZihyZS50ZXN0KHRlbXApKSByZXR1cm4gZmFsc2U7IFxuXHRyZXR1cm4gdHJ1ZTsgXG59XG4gXG5leHBvcnQgZnVuY3Rpb24gaXNKYXBhbmVzZSh0ZW1wOnN0cmluZyk6Ym9vbGVhblxueyBcblx0dmFyIHJlID0gL1teXFx1MDgwMC1cXHU0ZTAwXS87IFxuXHRpZihyZS50ZXN0KHRlbXApKSByZXR1cm4gZmFsc2U7IFxuXHRyZXR1cm4gdHJ1ZTsgXG59XG4gXG5leHBvcnQgZnVuY3Rpb24gaXNLb2VyYShjaHI6YW55KTpib29sZWFuIHtcblx0XG5cdGlmKCgoY2hyID4gMHgzMTMwICYmIGNociA8IDB4MzE4RikgfHwgXG5cdCAgICAoY2hyID49IDB4QUMwMCAmJiBjaHIgPD0gMHhEN0EzKSkpIFxuXHR7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb250YWluTXVsdGlUeXBlKHN0cjpzdHJpbmcpOmJvb2xlYW4ge1xuXHRcbiAgICBsZXQgaXNVbmljb2RlID0gZmFsc2U7XG4gICAgaWYoZXNjYXBlKHN0cikuaW5kZXhPZihcIiV1XCIpPi0xKXtcbiAgICAgICAgaXNVbmljb2RlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgaXNOb3QgPSBmYWxzZTtcbiAgICBsZXQgcmVnID0gL1swLTlhLXpdL2dpOyBcbiAgICBpZihyZWcudGVzdChzdHIpKXtcbiAgICAgICAgaXNOb3QgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCByZUVuU2lnbiA9IC9bXFx4MDAtXFx4ZmZdKy9nO1xuICAgIGlmKHJlRW5TaWduLnRlc3Qoc3RyKSl7XG4gICAgICAgIGlzTm90ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZihpc1VuaWNvZGUgJiYgaXNOb3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbn1cblxuXG5cblxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmluYXJ5Q29udGVudCAocGF0aDphbnksIG9wdGlvbnM6YW55KSB7XG4gICAgbGV0IHByb21pc2UsIHJlc29sdmU6YW55LCByZWplY3Q6YW55O1xuICAgIGxldCBjYWxsYmFjazphbnk7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIC8vIHRha2VuIGZyb20galF1ZXJ5XG4gICAgbGV0IGNyZWF0ZVN0YW5kYXJkWEhSID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgfSBjYXRjaCggZSApIHt9XG4gICAgfVxuXG4gICAgbGV0IGNyZWF0ZUFjdGl2ZVhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgICAgfSBjYXRjaCggZSApIHt9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdFxuICAgIHZhciBjcmVhdGVYSFIgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuQWN0aXZlWE9iamVjdCkgP1xuICAgICAgICAvKiBNaWNyb3NvZnQgZmFpbGVkIHRvIHByb3Blcmx5XG4gICAgICAgICogaW1wbGVtZW50IHRoZSBYTUxIdHRwUmVxdWVzdCBpbiBJRTcgKGNhbid0IHJlcXVlc3QgbG9jYWwgZmlsZXMpLFxuICAgICAgICAqIHNvIHdlIHVzZSB0aGUgQWN0aXZlWE9iamVjdCB3aGVuIGl0IGlzIGF2YWlsYWJsZVxuICAgICAgICAqIEFkZGl0aW9uYWxseSBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgaW4gSUU3L0lFOCBzb1xuICAgICAgICAqIHdlIG5lZWQgYSBmYWxsYmFjay5cbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTdGFuZGFyZFhIUigpIHx8IGNyZWF0ZUFjdGl2ZVhIUigpO1xuICAgIH0gOlxuICAgICAgICAvLyBGb3IgYWxsIG90aGVyIGJyb3dzZXJzLCB1c2UgdGhlIHN0YW5kYXJkIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuICAgICAgICBjcmVhdGVTdGFuZGFyZFhIUjtcblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGlibGUgY2FsbGJhY2tcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGNhbGxiYWNrIGluc2lkZSBvcHRpb25zIG9iamVjdFxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgcmVzb2x2ZSA9IGZ1bmN0aW9uIChkYXRhOmFueSkgeyBjYWxsYmFjayhudWxsLCBkYXRhKTsgfTtcbiAgICByZWplY3QgPSBmdW5jdGlvbiAoZXJyOmFueSkgeyBjYWxsYmFjayhlcnIsIG51bGwpOyB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHhociA9IGNyZWF0ZVhIUigpO1xuXG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCB0cnVlKTtcblxuICAgICAgICAvLyByZWNlbnQgYnJvd3NlcnNcbiAgICAgICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4geGhyKSB7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb2xkZXIgYnJvd3NlclxuICAgICAgICBpZih4aHIub3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChldmVudDpFdmVudCkge1xuICAgICAgICAgICAgLy8gdXNlIGB4aHJgIGFuZCBub3QgYHRoaXNgLi4uIHRoYW5rcyBJRVxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCB8fCB4aHIuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZ1bmN0aW9uICh4aHI6WE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgeGhyLnJlc3BvbnNlVGV4dCwgdGhlIDB4RkYgbWFzayBpcyBhcHBsaWVkIGJ5IEpTWmlwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSh4aHIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWpheCBlcnJvciBmb3IgXCIgKyBwYXRoICsgXCIgOiBcIiArIHRoaXMuc3RhdHVzICsgXCIgXCIgKyB0aGlzLnN0YXR1c1RleHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYob3B0aW9ucy5wcm9ncmVzcykge1xuICAgICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlOmFueSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogZS5sb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiBlLnRvdGFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlKSwgbnVsbCk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBhIHByb21pc2Ugb3IgdW5kZWZpbmVkIGRlcGVuZGluZyBvbiB3aGV0aGVyIGEgY2FsbGJhY2sgd2FzXG4gICAgLy8gcHJvdmlkZWRcbiAgICByZXR1cm4gcHJvbWlzZTtcbn0iLCJpbXBvcnQgeyBMdWNreUZpbGUgfSBmcm9tIFwiLi9Ub0x1Y2t5U2hlZXQvTHVja3lGaWxlXCI7XG4vLyBpbXBvcnQge1NlY3VyaXR5RG9vcixDYXJ9IGZyb20gJy4vY29udGVudCc7XG5cbmltcG9ydCB7SGFuZGxlWmlwfSBmcm9tICcuL0hhbmRsZVppcCc7XG5cbmltcG9ydCB7SXVwbG9hZGZpbGVMaXN0fSBmcm9tIFwiLi9JQ29tbW9uXCI7XG5pbXBvcnQgeyBMdWNreVNoZWV0IH0gZnJvbSBcIi4vVG9MdWNreVNoZWV0L0x1Y2t5U2hlZXRcIjtcblxuLy9kZW1vXG5mdW5jdGlvbiBkZW1vSGFuZGxlcigpe1xuICAgIGxldCB1cGxvYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIkx1Y2t5ZXhjZWwtZGVtby1maWxlXCIpO1xuICAgIGxldCBzZWxlY3RBRGVtbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiTHVja3lleGNlbC1zZWxlY3QtZGVtb1wiKTtcbiAgICBsZXQgZG93bmxvZERlbW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIkx1Y2t5ZXhjZWwtZG93bmxvZC1maWxlXCIpO1xuICAgIGxldCBtYXNrID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsdWNreS1tYXNrLWRlbW9cIik7XG4gICAgaWYodXBsb2FkKXtcbiAgICAgICAgXG4gICAgICAgIHdpbmRvdy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGV2dCl7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVzOkZpbGVMaXN0ID0gKGV2dC50YXJnZXQgYXMgYW55KS5maWxlcztcbiAgICAgICAgICAgICAgICBpZihmaWxlcz09bnVsbCB8fCBmaWxlcy5sZW5ndGg9PTApe1xuICAgICAgICAgICAgICAgICAgICBhbGVydChcIk5vIGZpbGVzIHdhaXQgZm9yIGltcG9ydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZmlsZXNbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4QXJyID0gbmFtZS5zcGxpdChcIi5cIiksIHN1ZmZpeCA9IHN1ZmZpeEFycltzdWZmaXhBcnIubGVuZ3RoLTFdO1xuICAgICAgICAgICAgICAgIGlmKHN1ZmZpeCE9XCJ4bHN4XCIpe1xuICAgICAgICAgICAgICAgICAgICBhbGVydChcIkN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHRoZSBpbXBvcnQgb2YgeGxzeCBmaWxlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBMdWNreUV4Y2VsLnRyYW5zZm9ybUV4Y2VsVG9MdWNreShmaWxlc1swXSwgZnVuY3Rpb24oZXhwb3J0SnNvbjphbnksIGx1Y2t5c2hlZXRmaWxlOnN0cmluZyl7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihleHBvcnRKc29uLnNoZWV0cz09bnVsbCB8fCBleHBvcnRKc29uLnNoZWV0cy5sZW5ndGg9PTApe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gcmVhZCB0aGUgY29udGVudCBvZiB0aGUgZXhjZWwgZmlsZSwgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgeGxzIGZpbGVzIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhleHBvcnRKc29uLCBsdWNreXNoZWV0ZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sdWNreXNoZWV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sdWNreXNoZWV0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6ICdsdWNreXNoZWV0JywgLy9sdWNreXNoZWV0IGlzIHRoZSBjb250YWluZXIgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dpbmZvYmFyOmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTpleHBvcnRKc29uLnNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOmV4cG9ydEpzb24uaW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckluZm86ZXhwb3J0SnNvbi5pbmZvLm5hbWUuY3JlYXRvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZWxlY3RBRGVtby5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGV2dCl7XG4gICAgICAgICAgICAgICAgdmFyIG9iajphbnkgPSBzZWxlY3RBRGVtbztcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBvYmouc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmoub3B0aW9uc1tpbmRleF0udmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBvYmoub3B0aW9uc1tpbmRleF0uaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgIGlmKHZhbHVlPT1cIlwiKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndmFsdWUgOj4+ICcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBtYXNrLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICAgICAgICAgICAgICBMdWNreUV4Y2VsLnRyYW5zZm9ybUV4Y2VsVG9MdWNreUJ5VXJsKHZhbHVlLCBuYW1lLCBmdW5jdGlvbihleHBvcnRKc29uOmFueSwgbHVja3lzaGVldGZpbGU6c3RyaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKGV4cG9ydEpzb24uc2hlZXRzPT1udWxsIHx8IGV4cG9ydEpzb24uc2hlZXRzLmxlbmd0aD09MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIkZhaWxlZCB0byByZWFkIHRoZSBjb250ZW50IG9mIHRoZSBleGNlbCBmaWxlLCBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCB4bHMgZmlsZXMhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4cG9ydEpzb24sIGx1Y2t5c2hlZXRmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFzay5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sdWNreXNoZWV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sdWNreXNoZWV0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6ICdsdWNreXNoZWV0JywgLy9sdWNreXNoZWV0IGlzIHRoZSBjb250YWluZXIgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dpbmZvYmFyOmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTpleHBvcnRKc29uLnNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOmV4cG9ydEpzb24uaW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckluZm86ZXhwb3J0SnNvbi5pbmZvLm5hbWUuY3JlYXRvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb3dubG9kRGVtby5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KXtcbiAgICAgICAgICAgICAgICB2YXIgb2JqOmFueSA9IHNlbGVjdEFEZW1vO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG9iai5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iai5vcHRpb25zW2luZGV4XS52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmKHZhbHVlLmxlbmd0aD09MCl7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiUGxlYXNlIHNlbGVjdCBhIGRlbW8gZmlsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBlbGVtSUY6YW55ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJMdWNreS1kb3dubG9hZC1mcmFtZVwiKTtcbiAgICAgICAgICAgICAgICBpZihlbGVtSUY9PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICBlbGVtSUYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtSUYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtSUYuaWQgPSBcIkx1Y2t5LWRvd25sb2FkLWZyYW1lXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbUlGKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbUlGLnNyYyA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gZWxlbUlGLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbUlGKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZGVtb0hhbmRsZXIoKTtcblxuLy8gYXBpXG5leHBvcnQgY2xhc3MgTHVja3lFeGNlbHtcbiAgICBzdGF0aWMgdHJhbnNmb3JtRXhjZWxUb0x1Y2t5KGV4Y2VsRmlsZTpGaWxlLCBjYWxsQmFjaz86KGZpbGVzOkl1cGxvYWRmaWxlTGlzdCwgZnM/OnN0cmluZyk9PnZvaWQpe1xuICAgICAgICBsZXQgaGFuZGxlWmlwOkhhbmRsZVppcCA9IG5ldyBIYW5kbGVaaXAoZXhjZWxGaWxlKTtcbiAgICAgICAgaGFuZGxlWmlwLnVuemlwRmlsZShmdW5jdGlvbihmaWxlczpJdXBsb2FkZmlsZUxpc3Qpe1xuICAgICAgICAgICAgbGV0IGx1Y2t5RmlsZSA9IG5ldyBMdWNreUZpbGUoZmlsZXMsIGV4Y2VsRmlsZS5uYW1lKTtcbiAgICAgICAgICAgIGxldCBsdWNreXNoZWV0ZmlsZSA9IGx1Y2t5RmlsZS5QYXJzZSgpO1xuICAgICAgICAgICAgbGV0IGV4cG9ydEpzb24gPSBKU09OLnBhcnNlKGx1Y2t5c2hlZXRmaWxlKTtcbiAgICAgICAgICAgIGlmKGNhbGxCYWNrICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgY2FsbEJhY2soZXhwb3J0SnNvbiwgbHVja3lzaGVldGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycjpFcnJvcil7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB0cmFuc2Zvcm1FeGNlbFRvTHVja3lCeVVybCh1cmw6c3RyaW5nLCBuYW1lOnN0cmluZywgY2FsbEJhY2s/OihmaWxlczpJdXBsb2FkZmlsZUxpc3QsIGZzPzpzdHJpbmcpPT52b2lkKXtcbiAgICAgICAgbGV0IGhhbmRsZVppcDpIYW5kbGVaaXAgPSBuZXcgSGFuZGxlWmlwKCk7XG4gICAgICAgIGhhbmRsZVppcC51bnppcEZpbGVCeVVybCh1cmwsIGZ1bmN0aW9uKGZpbGVzOkl1cGxvYWRmaWxlTGlzdCl7XG4gICAgICAgICAgICBsZXQgbHVja3lGaWxlID0gbmV3IEx1Y2t5RmlsZShmaWxlcywgbmFtZSk7XG4gICAgICAgICAgICBsZXQgbHVja3lzaGVldGZpbGUgPSBsdWNreUZpbGUuUGFyc2UoKTtcbiAgICAgICAgICAgIGxldCBleHBvcnRKc29uID0gSlNPTi5wYXJzZShsdWNreXNoZWV0ZmlsZSk7XG4gICAgICAgICAgICBpZihjYWxsQmFjayAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIGNhbGxCYWNrKGV4cG9ydEpzb24sIGx1Y2t5c2hlZXRmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyOkVycm9yKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHRyYW5zZm9ybUx1Y2t5VG9FeGNlbChMdWNreUZpbGU6IGFueSwgY2FsbEJhY2s/OiAoZmlsZXM6IHN0cmluZykgPT4gdm9pZCkge1xuICAgICAgICBcbiAgICB9XG59XG5cblxuXG4iXX0="}